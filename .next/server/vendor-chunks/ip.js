/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ip";
exports.ids = ["vendor-chunks/ip"];
exports.modules = {

/***/ "(ssr)/./node_modules/ip/lib/ip.js":
/*!***********************************!*\
  !*** ./node_modules/ip/lib/ip.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const ip = exports;\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\nconst os = __webpack_require__(/*! os */ \"os\");\nip.toBuffer = function(ip, buff, offset) {\n    offset = ~~offset;\n    let result;\n    if (this.isV4Format(ip)) {\n        result = buff || Buffer.alloc(offset + 4);\n        ip.split(/\\./g).map((byte)=>{\n            result[offset++] = parseInt(byte, 10) & 0xff;\n        });\n    } else if (this.isV6Format(ip)) {\n        const sections = ip.split(\":\", 8);\n        let i;\n        for(i = 0; i < sections.length; i++){\n            const isv4 = this.isV4Format(sections[i]);\n            let v4Buffer;\n            if (isv4) {\n                v4Buffer = this.toBuffer(sections[i]);\n                sections[i] = v4Buffer.slice(0, 2).toString(\"hex\");\n            }\n            if (v4Buffer && ++i < 8) {\n                sections.splice(i, 0, v4Buffer.slice(2, 4).toString(\"hex\"));\n            }\n        }\n        if (sections[0] === \"\") {\n            while(sections.length < 8)sections.unshift(\"0\");\n        } else if (sections[sections.length - 1] === \"\") {\n            while(sections.length < 8)sections.push(\"0\");\n        } else if (sections.length < 8) {\n            for(i = 0; i < sections.length && sections[i] !== \"\"; i++);\n            const argv = [\n                i,\n                1\n            ];\n            for(i = 9 - sections.length; i > 0; i--){\n                argv.push(\"0\");\n            }\n            sections.splice(...argv);\n        }\n        result = buff || Buffer.alloc(offset + 16);\n        for(i = 0; i < sections.length; i++){\n            const word = parseInt(sections[i], 16);\n            result[offset++] = word >> 8 & 0xff;\n            result[offset++] = word & 0xff;\n        }\n    }\n    if (!result) {\n        throw Error(`Invalid ip address: ${ip}`);\n    }\n    return result;\n};\nip.toString = function(buff, offset, length) {\n    offset = ~~offset;\n    length = length || buff.length - offset;\n    let result = [];\n    if (length === 4) {\n        // IPv4\n        for(let i = 0; i < length; i++){\n            result.push(buff[offset + i]);\n        }\n        result = result.join(\".\");\n    } else if (length === 16) {\n        // IPv6\n        for(let i = 0; i < length; i += 2){\n            result.push(buff.readUInt16BE(offset + i).toString(16));\n        }\n        result = result.join(\":\");\n        result = result.replace(/(^|:)0(:0)*:0(:|$)/, \"$1::$3\");\n        result = result.replace(/:{3,4}/, \"::\");\n    }\n    return result;\n};\nconst ipv4Regex = /^(\\d{1,3}\\.){3,3}\\d{1,3}$/;\nconst ipv6Regex = /^(::)?(((\\d{1,3}\\.){3}(\\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;\nip.isV4Format = function(ip) {\n    return ipv4Regex.test(ip);\n};\nip.isV6Format = function(ip) {\n    return ipv6Regex.test(ip);\n};\nfunction _normalizeFamily(family) {\n    if (family === 4) {\n        return \"ipv4\";\n    }\n    if (family === 6) {\n        return \"ipv6\";\n    }\n    return family ? family.toLowerCase() : \"ipv4\";\n}\nip.fromPrefixLen = function(prefixlen, family) {\n    if (prefixlen > 32) {\n        family = \"ipv6\";\n    } else {\n        family = _normalizeFamily(family);\n    }\n    let len = 4;\n    if (family === \"ipv6\") {\n        len = 16;\n    }\n    const buff = Buffer.alloc(len);\n    for(let i = 0, n = buff.length; i < n; ++i){\n        let bits = 8;\n        if (prefixlen < 8) {\n            bits = prefixlen;\n        }\n        prefixlen -= bits;\n        buff[i] = ~(0xff >> bits) & 0xff;\n    }\n    return ip.toString(buff);\n};\nip.mask = function(addr, mask) {\n    addr = ip.toBuffer(addr);\n    mask = ip.toBuffer(mask);\n    const result = Buffer.alloc(Math.max(addr.length, mask.length));\n    // Same protocol - do bitwise and\n    let i;\n    if (addr.length === mask.length) {\n        for(i = 0; i < addr.length; i++){\n            result[i] = addr[i] & mask[i];\n        }\n    } else if (mask.length === 4) {\n        // IPv6 address and IPv4 mask\n        // (Mask low bits)\n        for(i = 0; i < mask.length; i++){\n            result[i] = addr[addr.length - 4 + i] & mask[i];\n        }\n    } else {\n        // IPv6 mask and IPv4 addr\n        for(i = 0; i < result.length - 6; i++){\n            result[i] = 0;\n        }\n        // ::ffff:ipv4\n        result[10] = 0xff;\n        result[11] = 0xff;\n        for(i = 0; i < addr.length; i++){\n            result[i + 12] = addr[i] & mask[i + 12];\n        }\n        i += 12;\n    }\n    for(; i < result.length; i++){\n        result[i] = 0;\n    }\n    return ip.toString(result);\n};\nip.cidr = function(cidrString) {\n    const cidrParts = cidrString.split(\"/\");\n    const addr = cidrParts[0];\n    if (cidrParts.length !== 2) {\n        throw new Error(`invalid CIDR subnet: ${addr}`);\n    }\n    const mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));\n    return ip.mask(addr, mask);\n};\nip.subnet = function(addr, mask) {\n    const networkAddress = ip.toLong(ip.mask(addr, mask));\n    // Calculate the mask's length.\n    const maskBuffer = ip.toBuffer(mask);\n    let maskLength = 0;\n    for(let i = 0; i < maskBuffer.length; i++){\n        if (maskBuffer[i] === 0xff) {\n            maskLength += 8;\n        } else {\n            let octet = maskBuffer[i] & 0xff;\n            while(octet){\n                octet = octet << 1 & 0xff;\n                maskLength++;\n            }\n        }\n    }\n    const numberOfAddresses = 2 ** (32 - maskLength);\n    return {\n        networkAddress: ip.fromLong(networkAddress),\n        firstAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress) : ip.fromLong(networkAddress + 1),\n        lastAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress + numberOfAddresses - 1) : ip.fromLong(networkAddress + numberOfAddresses - 2),\n        broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),\n        subnetMask: mask,\n        subnetMaskLength: maskLength,\n        numHosts: numberOfAddresses <= 2 ? numberOfAddresses : numberOfAddresses - 2,\n        length: numberOfAddresses,\n        contains (other) {\n            return networkAddress === ip.toLong(ip.mask(other, mask));\n        }\n    };\n};\nip.cidrSubnet = function(cidrString) {\n    const cidrParts = cidrString.split(\"/\");\n    const addr = cidrParts[0];\n    if (cidrParts.length !== 2) {\n        throw new Error(`invalid CIDR subnet: ${addr}`);\n    }\n    const mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));\n    return ip.subnet(addr, mask);\n};\nip.not = function(addr) {\n    const buff = ip.toBuffer(addr);\n    for(let i = 0; i < buff.length; i++){\n        buff[i] = 0xff ^ buff[i];\n    }\n    return ip.toString(buff);\n};\nip.or = function(a, b) {\n    a = ip.toBuffer(a);\n    b = ip.toBuffer(b);\n    // same protocol\n    if (a.length === b.length) {\n        for(let i = 0; i < a.length; ++i){\n            a[i] |= b[i];\n        }\n        return ip.toString(a);\n    // mixed protocols\n    }\n    let buff = a;\n    let other = b;\n    if (b.length > a.length) {\n        buff = b;\n        other = a;\n    }\n    const offset = buff.length - other.length;\n    for(let i = offset; i < buff.length; ++i){\n        buff[i] |= other[i - offset];\n    }\n    return ip.toString(buff);\n};\nip.isEqual = function(a, b) {\n    a = ip.toBuffer(a);\n    b = ip.toBuffer(b);\n    // Same protocol\n    if (a.length === b.length) {\n        for(let i = 0; i < a.length; i++){\n            if (a[i] !== b[i]) return false;\n        }\n        return true;\n    }\n    // Swap\n    if (b.length === 4) {\n        const t = b;\n        b = a;\n        a = t;\n    }\n    // a - IPv4, b - IPv6\n    for(let i = 0; i < 10; i++){\n        if (b[i] !== 0) return false;\n    }\n    const word = b.readUInt16BE(10);\n    if (word !== 0 && word !== 0xffff) return false;\n    for(let i = 0; i < 4; i++){\n        if (a[i] !== b[i + 12]) return false;\n    }\n    return true;\n};\nip.isPrivate = function(addr) {\n    return /^(::f{4}:)?10\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?192\\.168\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?172\\.(1[6-9]|2\\d|30|31)\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?169\\.254\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) || /^f[cd][0-9a-f]{2}:/i.test(addr) || /^fe80:/i.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);\n};\nip.isPublic = function(addr) {\n    return !ip.isPrivate(addr);\n};\nip.isLoopback = function(addr) {\n    return /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})/.test(addr) || /^fe80::1$/.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);\n};\nip.loopback = function(family) {\n    //\n    // Default to `ipv4`\n    //\n    family = _normalizeFamily(family);\n    if (family !== \"ipv4\" && family !== \"ipv6\") {\n        throw new Error(\"family must be ipv4 or ipv6\");\n    }\n    return family === \"ipv4\" ? \"127.0.0.1\" : \"fe80::1\";\n};\n//\n// ### function address (name, family)\n// #### @name {string|'public'|'private'} **Optional** Name or security\n//      of the network interface.\n// #### @family {ipv4|ipv6} **Optional** IP family of the address (defaults\n//      to ipv4).\n//\n// Returns the address for the network interface on the current system with\n// the specified `name`:\n//   * String: First `family` address of the interface.\n//             If not found see `undefined`.\n//   * 'public': the first public ip address of family.\n//   * 'private': the first private ip address of family.\n//   * undefined: First address with `ipv4` or loopback address `127.0.0.1`.\n//\nip.address = function(name, family) {\n    const interfaces = os.networkInterfaces();\n    //\n    // Default to `ipv4`\n    //\n    family = _normalizeFamily(family);\n    //\n    // If a specific network interface has been named,\n    // return the address.\n    //\n    if (name && name !== \"private\" && name !== \"public\") {\n        const res = interfaces[name].filter((details)=>{\n            const itemFamily = _normalizeFamily(details.family);\n            return itemFamily === family;\n        });\n        if (res.length === 0) {\n            return undefined;\n        }\n        return res[0].address;\n    }\n    const all = Object.keys(interfaces).map((nic)=>{\n        //\n        // Note: name will only be `public` or `private`\n        // when this is called.\n        //\n        const addresses = interfaces[nic].filter((details)=>{\n            details.family = _normalizeFamily(details.family);\n            if (details.family !== family || ip.isLoopback(details.address)) {\n                return false;\n            }\n            if (!name) {\n                return true;\n            }\n            return name === \"public\" ? ip.isPrivate(details.address) : ip.isPublic(details.address);\n        });\n        return addresses.length ? addresses[0].address : undefined;\n    }).filter(Boolean);\n    return !all.length ? ip.loopback(family) : all[0];\n};\nip.toLong = function(ip) {\n    let ipl = 0;\n    ip.split(\".\").forEach((octet)=>{\n        ipl <<= 8;\n        ipl += parseInt(octet);\n    });\n    return ipl >>> 0;\n};\nip.fromLong = function(ipl) {\n    return `${ipl >>> 24}.${ipl >> 16 & 255}.${ipl >> 8 & 255}.${ipl & 255}`;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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VWtELEdBQUcsQ0FBQyxFQUFFO0FBQ25EO0FBRUF0RixHQUFHb0QsTUFBTSxHQUFHLFNBQVVwRCxFQUFFO0lBQ3RCLElBQUk0RixNQUFNO0lBQ1Y1RixHQUFHVyxLQUFLLENBQUMsS0FBS2tGLE9BQU8sQ0FBQyxDQUFDdEM7UUFDckJxQyxRQUFRO1FBQ1JBLE9BQU85RSxTQUFTeUM7SUFDbEI7SUFDQSxPQUFRcUMsUUFBUTtBQUNsQjtBQUVBNUYsR0FBR3lELFFBQVEsR0FBRyxTQUFVbUMsR0FBRztJQUN6QixPQUFRLENBQUMsRUFBRUEsUUFBUSxHQUFHLENBQUMsRUFDckJBLE9BQU8sS0FBSyxJQUFJLENBQUMsRUFDakJBLE9BQU8sSUFBSSxJQUFJLENBQUMsRUFDaEJBLE1BQU0sSUFBSSxDQUFDO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWF1dGgtcmVnaXN0ZXIvLi9ub2RlX21vZHVsZXMvaXAvbGliL2lwLmpzP2QyNTgiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgaXAgPSBleHBvcnRzO1xuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuXG5pcC50b0J1ZmZlciA9IGZ1bmN0aW9uIChpcCwgYnVmZiwgb2Zmc2V0KSB7XG4gIG9mZnNldCA9IH5+b2Zmc2V0O1xuXG4gIGxldCByZXN1bHQ7XG5cbiAgaWYgKHRoaXMuaXNWNEZvcm1hdChpcCkpIHtcbiAgICByZXN1bHQgPSBidWZmIHx8IEJ1ZmZlci5hbGxvYyhvZmZzZXQgKyA0KTtcbiAgICBpcC5zcGxpdCgvXFwuL2cpLm1hcCgoYnl0ZSkgPT4ge1xuICAgICAgcmVzdWx0W29mZnNldCsrXSA9IHBhcnNlSW50KGJ5dGUsIDEwKSAmIDB4ZmY7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodGhpcy5pc1Y2Rm9ybWF0KGlwKSkge1xuICAgIGNvbnN0IHNlY3Rpb25zID0gaXAuc3BsaXQoJzonLCA4KTtcblxuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXN2NCA9IHRoaXMuaXNWNEZvcm1hdChzZWN0aW9uc1tpXSk7XG4gICAgICBsZXQgdjRCdWZmZXI7XG5cbiAgICAgIGlmIChpc3Y0KSB7XG4gICAgICAgIHY0QnVmZmVyID0gdGhpcy50b0J1ZmZlcihzZWN0aW9uc1tpXSk7XG4gICAgICAgIHNlY3Rpb25zW2ldID0gdjRCdWZmZXIuc2xpY2UoMCwgMikudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodjRCdWZmZXIgJiYgKytpIDwgOCkge1xuICAgICAgICBzZWN0aW9ucy5zcGxpY2UoaSwgMCwgdjRCdWZmZXIuc2xpY2UoMiwgNCkudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VjdGlvbnNbMF0gPT09ICcnKSB7XG4gICAgICB3aGlsZSAoc2VjdGlvbnMubGVuZ3RoIDwgOCkgc2VjdGlvbnMudW5zaGlmdCgnMCcpO1xuICAgIH0gZWxzZSBpZiAoc2VjdGlvbnNbc2VjdGlvbnMubGVuZ3RoIC0gMV0gPT09ICcnKSB7XG4gICAgICB3aGlsZSAoc2VjdGlvbnMubGVuZ3RoIDwgOCkgc2VjdGlvbnMucHVzaCgnMCcpO1xuICAgIH0gZWxzZSBpZiAoc2VjdGlvbnMubGVuZ3RoIDwgOCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aCAmJiBzZWN0aW9uc1tpXSAhPT0gJyc7IGkrKyk7XG4gICAgICBjb25zdCBhcmd2ID0gW2ksIDFdO1xuICAgICAgZm9yIChpID0gOSAtIHNlY3Rpb25zLmxlbmd0aDsgaSA+IDA7IGktLSkge1xuICAgICAgICBhcmd2LnB1c2goJzAnKTtcbiAgICAgIH1cbiAgICAgIHNlY3Rpb25zLnNwbGljZSguLi5hcmd2KTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSBidWZmIHx8IEJ1ZmZlci5hbGxvYyhvZmZzZXQgKyAxNik7XG4gICAgZm9yIChpID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB3b3JkID0gcGFyc2VJbnQoc2VjdGlvbnNbaV0sIDE2KTtcbiAgICAgIHJlc3VsdFtvZmZzZXQrK10gPSAod29yZCA+PiA4KSAmIDB4ZmY7XG4gICAgICByZXN1bHRbb2Zmc2V0KytdID0gd29yZCAmIDB4ZmY7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFyZXN1bHQpIHtcbiAgICB0aHJvdyBFcnJvcihgSW52YWxpZCBpcCBhZGRyZXNzOiAke2lwfWApO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmlwLnRvU3RyaW5nID0gZnVuY3Rpb24gKGJ1ZmYsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IH5+b2Zmc2V0O1xuICBsZW5ndGggPSBsZW5ndGggfHwgKGJ1ZmYubGVuZ3RoIC0gb2Zmc2V0KTtcblxuICBsZXQgcmVzdWx0ID0gW107XG4gIGlmIChsZW5ndGggPT09IDQpIHtcbiAgICAvLyBJUHY0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goYnVmZltvZmZzZXQgKyBpXSk7XG4gICAgfVxuICAgIHJlc3VsdCA9IHJlc3VsdC5qb2luKCcuJyk7XG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSAxNikge1xuICAgIC8vIElQdjZcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICByZXN1bHQucHVzaChidWZmLnJlYWRVSW50MTZCRShvZmZzZXQgKyBpKS50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICByZXN1bHQgPSByZXN1bHQuam9pbignOicpO1xuICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC8oXnw6KTAoOjApKjowKDp8JCkvLCAnJDE6OiQzJyk7XG4gICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoLzp7Myw0fS8sICc6OicpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGlwdjRSZWdleCA9IC9eKFxcZHsxLDN9XFwuKXszLDN9XFxkezEsM30kLztcbmNvbnN0IGlwdjZSZWdleCA9IC9eKDo6KT8oKChcXGR7MSwzfVxcLil7M30oXFxkezEsM30pezF9KT8oWzAtOWEtZl0pezAsNH06ezAsMn0pezEsOH0oOjopPyQvaTtcblxuaXAuaXNWNEZvcm1hdCA9IGZ1bmN0aW9uIChpcCkge1xuICByZXR1cm4gaXB2NFJlZ2V4LnRlc3QoaXApO1xufTtcblxuaXAuaXNWNkZvcm1hdCA9IGZ1bmN0aW9uIChpcCkge1xuICByZXR1cm4gaXB2NlJlZ2V4LnRlc3QoaXApO1xufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUZhbWlseShmYW1pbHkpIHtcbiAgaWYgKGZhbWlseSA9PT0gNCkge1xuICAgIHJldHVybiAnaXB2NCc7XG4gIH1cbiAgaWYgKGZhbWlseSA9PT0gNikge1xuICAgIHJldHVybiAnaXB2Nic7XG4gIH1cbiAgcmV0dXJuIGZhbWlseSA/IGZhbWlseS50b0xvd2VyQ2FzZSgpIDogJ2lwdjQnO1xufVxuXG5pcC5mcm9tUHJlZml4TGVuID0gZnVuY3Rpb24gKHByZWZpeGxlbiwgZmFtaWx5KSB7XG4gIGlmIChwcmVmaXhsZW4gPiAzMikge1xuICAgIGZhbWlseSA9ICdpcHY2JztcbiAgfSBlbHNlIHtcbiAgICBmYW1pbHkgPSBfbm9ybWFsaXplRmFtaWx5KGZhbWlseSk7XG4gIH1cblxuICBsZXQgbGVuID0gNDtcbiAgaWYgKGZhbWlseSA9PT0gJ2lwdjYnKSB7XG4gICAgbGVuID0gMTY7XG4gIH1cbiAgY29uc3QgYnVmZiA9IEJ1ZmZlci5hbGxvYyhsZW4pO1xuXG4gIGZvciAobGV0IGkgPSAwLCBuID0gYnVmZi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBsZXQgYml0cyA9IDg7XG4gICAgaWYgKHByZWZpeGxlbiA8IDgpIHtcbiAgICAgIGJpdHMgPSBwcmVmaXhsZW47XG4gICAgfVxuICAgIHByZWZpeGxlbiAtPSBiaXRzO1xuXG4gICAgYnVmZltpXSA9IH4oMHhmZiA+PiBiaXRzKSAmIDB4ZmY7XG4gIH1cblxuICByZXR1cm4gaXAudG9TdHJpbmcoYnVmZik7XG59O1xuXG5pcC5tYXNrID0gZnVuY3Rpb24gKGFkZHIsIG1hc2spIHtcbiAgYWRkciA9IGlwLnRvQnVmZmVyKGFkZHIpO1xuICBtYXNrID0gaXAudG9CdWZmZXIobWFzayk7XG5cbiAgY29uc3QgcmVzdWx0ID0gQnVmZmVyLmFsbG9jKE1hdGgubWF4KGFkZHIubGVuZ3RoLCBtYXNrLmxlbmd0aCkpO1xuXG4gIC8vIFNhbWUgcHJvdG9jb2wgLSBkbyBiaXR3aXNlIGFuZFxuICBsZXQgaTtcbiAgaWYgKGFkZHIubGVuZ3RoID09PSBtYXNrLmxlbmd0aCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBhZGRyLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBhZGRyW2ldICYgbWFza1tpXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobWFzay5sZW5ndGggPT09IDQpIHtcbiAgICAvLyBJUHY2IGFkZHJlc3MgYW5kIElQdjQgbWFza1xuICAgIC8vIChNYXNrIGxvdyBiaXRzKVxuICAgIGZvciAoaSA9IDA7IGkgPCBtYXNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBhZGRyW2FkZHIubGVuZ3RoIC0gNCArIGldICYgbWFza1tpXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSVB2NiBtYXNrIGFuZCBJUHY0IGFkZHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aCAtIDY7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gMDtcbiAgICB9XG5cbiAgICAvLyA6OmZmZmY6aXB2NFxuICAgIHJlc3VsdFsxMF0gPSAweGZmO1xuICAgIHJlc3VsdFsxMV0gPSAweGZmO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhZGRyLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbaSArIDEyXSA9IGFkZHJbaV0gJiBtYXNrW2kgKyAxMl07XG4gICAgfVxuICAgIGkgKz0gMTI7XG4gIH1cbiAgZm9yICg7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIGlwLnRvU3RyaW5nKHJlc3VsdCk7XG59O1xuXG5pcC5jaWRyID0gZnVuY3Rpb24gKGNpZHJTdHJpbmcpIHtcbiAgY29uc3QgY2lkclBhcnRzID0gY2lkclN0cmluZy5zcGxpdCgnLycpO1xuXG4gIGNvbnN0IGFkZHIgPSBjaWRyUGFydHNbMF07XG4gIGlmIChjaWRyUGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIENJRFIgc3VibmV0OiAke2FkZHJ9YCk7XG4gIH1cblxuICBjb25zdCBtYXNrID0gaXAuZnJvbVByZWZpeExlbihwYXJzZUludChjaWRyUGFydHNbMV0sIDEwKSk7XG5cbiAgcmV0dXJuIGlwLm1hc2soYWRkciwgbWFzayk7XG59O1xuXG5pcC5zdWJuZXQgPSBmdW5jdGlvbiAoYWRkciwgbWFzaykge1xuICBjb25zdCBuZXR3b3JrQWRkcmVzcyA9IGlwLnRvTG9uZyhpcC5tYXNrKGFkZHIsIG1hc2spKTtcblxuICAvLyBDYWxjdWxhdGUgdGhlIG1hc2sncyBsZW5ndGguXG4gIGNvbnN0IG1hc2tCdWZmZXIgPSBpcC50b0J1ZmZlcihtYXNrKTtcbiAgbGV0IG1hc2tMZW5ndGggPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWFza0J1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChtYXNrQnVmZmVyW2ldID09PSAweGZmKSB7XG4gICAgICBtYXNrTGVuZ3RoICs9IDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBvY3RldCA9IG1hc2tCdWZmZXJbaV0gJiAweGZmO1xuICAgICAgd2hpbGUgKG9jdGV0KSB7XG4gICAgICAgIG9jdGV0ID0gKG9jdGV0IDw8IDEpICYgMHhmZjtcbiAgICAgICAgbWFza0xlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG51bWJlck9mQWRkcmVzc2VzID0gMiAqKiAoMzIgLSBtYXNrTGVuZ3RoKTtcblxuICByZXR1cm4ge1xuICAgIG5ldHdvcmtBZGRyZXNzOiBpcC5mcm9tTG9uZyhuZXR3b3JrQWRkcmVzcyksXG4gICAgZmlyc3RBZGRyZXNzOiBudW1iZXJPZkFkZHJlc3NlcyA8PSAyXG4gICAgICA/IGlwLmZyb21Mb25nKG5ldHdvcmtBZGRyZXNzKVxuICAgICAgOiBpcC5mcm9tTG9uZyhuZXR3b3JrQWRkcmVzcyArIDEpLFxuICAgIGxhc3RBZGRyZXNzOiBudW1iZXJPZkFkZHJlc3NlcyA8PSAyXG4gICAgICA/IGlwLmZyb21Mb25nKG5ldHdvcmtBZGRyZXNzICsgbnVtYmVyT2ZBZGRyZXNzZXMgLSAxKVxuICAgICAgOiBpcC5mcm9tTG9uZyhuZXR3b3JrQWRkcmVzcyArIG51bWJlck9mQWRkcmVzc2VzIC0gMiksXG4gICAgYnJvYWRjYXN0QWRkcmVzczogaXAuZnJvbUxvbmcobmV0d29ya0FkZHJlc3MgKyBudW1iZXJPZkFkZHJlc3NlcyAtIDEpLFxuICAgIHN1Ym5ldE1hc2s6IG1hc2ssXG4gICAgc3VibmV0TWFza0xlbmd0aDogbWFza0xlbmd0aCxcbiAgICBudW1Ib3N0czogbnVtYmVyT2ZBZGRyZXNzZXMgPD0gMlxuICAgICAgPyBudW1iZXJPZkFkZHJlc3NlcyA6IG51bWJlck9mQWRkcmVzc2VzIC0gMixcbiAgICBsZW5ndGg6IG51bWJlck9mQWRkcmVzc2VzLFxuICAgIGNvbnRhaW5zKG90aGVyKSB7XG4gICAgICByZXR1cm4gbmV0d29ya0FkZHJlc3MgPT09IGlwLnRvTG9uZyhpcC5tYXNrKG90aGVyLCBtYXNrKSk7XG4gICAgfSxcbiAgfTtcbn07XG5cbmlwLmNpZHJTdWJuZXQgPSBmdW5jdGlvbiAoY2lkclN0cmluZykge1xuICBjb25zdCBjaWRyUGFydHMgPSBjaWRyU3RyaW5nLnNwbGl0KCcvJyk7XG5cbiAgY29uc3QgYWRkciA9IGNpZHJQYXJ0c1swXTtcbiAgaWYgKGNpZHJQYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgQ0lEUiBzdWJuZXQ6ICR7YWRkcn1gKTtcbiAgfVxuXG4gIGNvbnN0IG1hc2sgPSBpcC5mcm9tUHJlZml4TGVuKHBhcnNlSW50KGNpZHJQYXJ0c1sxXSwgMTApKTtcblxuICByZXR1cm4gaXAuc3VibmV0KGFkZHIsIG1hc2spO1xufTtcblxuaXAubm90ID0gZnVuY3Rpb24gKGFkZHIpIHtcbiAgY29uc3QgYnVmZiA9IGlwLnRvQnVmZmVyKGFkZHIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmYubGVuZ3RoOyBpKyspIHtcbiAgICBidWZmW2ldID0gMHhmZiBeIGJ1ZmZbaV07XG4gIH1cbiAgcmV0dXJuIGlwLnRvU3RyaW5nKGJ1ZmYpO1xufTtcblxuaXAub3IgPSBmdW5jdGlvbiAoYSwgYikge1xuICBhID0gaXAudG9CdWZmZXIoYSk7XG4gIGIgPSBpcC50b0J1ZmZlcihiKTtcblxuICAvLyBzYW1lIHByb3RvY29sXG4gIGlmIChhLmxlbmd0aCA9PT0gYi5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgIGFbaV0gfD0gYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGlwLnRvU3RyaW5nKGEpO1xuXG4gIC8vIG1peGVkIHByb3RvY29sc1xuICB9XG4gIGxldCBidWZmID0gYTtcbiAgbGV0IG90aGVyID0gYjtcbiAgaWYgKGIubGVuZ3RoID4gYS5sZW5ndGgpIHtcbiAgICBidWZmID0gYjtcbiAgICBvdGhlciA9IGE7XG4gIH1cblxuICBjb25zdCBvZmZzZXQgPSBidWZmLmxlbmd0aCAtIG90aGVyLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGJ1ZmYubGVuZ3RoOyArK2kpIHtcbiAgICBidWZmW2ldIHw9IG90aGVyW2kgLSBvZmZzZXRdO1xuICB9XG5cbiAgcmV0dXJuIGlwLnRvU3RyaW5nKGJ1ZmYpO1xufTtcblxuaXAuaXNFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGEgPSBpcC50b0J1ZmZlcihhKTtcbiAgYiA9IGlwLnRvQnVmZmVyKGIpO1xuXG4gIC8vIFNhbWUgcHJvdG9jb2xcbiAgaWYgKGEubGVuZ3RoID09PSBiLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBTd2FwXG4gIGlmIChiLmxlbmd0aCA9PT0gNCkge1xuICAgIGNvbnN0IHQgPSBiO1xuICAgIGIgPSBhO1xuICAgIGEgPSB0O1xuICB9XG5cbiAgLy8gYSAtIElQdjQsIGIgLSBJUHY2XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgIGlmIChiW2ldICE9PSAwKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCB3b3JkID0gYi5yZWFkVUludDE2QkUoMTApO1xuICBpZiAod29yZCAhPT0gMCAmJiB3b3JkICE9PSAweGZmZmYpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGlmIChhW2ldICE9PSBiW2kgKyAxMl0pIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuaXAuaXNQcml2YXRlID0gZnVuY3Rpb24gKGFkZHIpIHtcbiAgcmV0dXJuIC9eKDo6Zns0fTopPzEwXFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pJC9pXG4gICAgLnRlc3QoYWRkcilcbiAgICB8fCAvXig6OmZ7NH06KT8xOTJcXC4xNjhcXC4oWzAtOV17MSwzfSlcXC4oWzAtOV17MSwzfSkkL2kudGVzdChhZGRyKVxuICAgIHx8IC9eKDo6Zns0fTopPzE3MlxcLigxWzYtOV18MlxcZHwzMHwzMSlcXC4oWzAtOV17MSwzfSlcXC4oWzAtOV17MSwzfSkkL2lcbiAgICAgIC50ZXN0KGFkZHIpXG4gICAgfHwgL14oOjpmezR9Oik/MTI3XFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pJC9pLnRlc3QoYWRkcilcbiAgICB8fCAvXig6OmZ7NH06KT8xNjlcXC4yNTRcXC4oWzAtOV17MSwzfSlcXC4oWzAtOV17MSwzfSkkL2kudGVzdChhZGRyKVxuICAgIHx8IC9eZltjZF1bMC05YS1mXXsyfTovaS50ZXN0KGFkZHIpXG4gICAgfHwgL15mZTgwOi9pLnRlc3QoYWRkcilcbiAgICB8fCAvXjo6MSQvLnRlc3QoYWRkcilcbiAgICB8fCAvXjo6JC8udGVzdChhZGRyKTtcbn07XG5cbmlwLmlzUHVibGljID0gZnVuY3Rpb24gKGFkZHIpIHtcbiAgcmV0dXJuICFpcC5pc1ByaXZhdGUoYWRkcik7XG59O1xuXG5pcC5pc0xvb3BiYWNrID0gZnVuY3Rpb24gKGFkZHIpIHtcbiAgcmV0dXJuIC9eKDo6Zns0fTopPzEyN1xcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KS9cbiAgICAudGVzdChhZGRyKVxuICAgIHx8IC9eZmU4MDo6MSQvLnRlc3QoYWRkcilcbiAgICB8fCAvXjo6MSQvLnRlc3QoYWRkcilcbiAgICB8fCAvXjo6JC8udGVzdChhZGRyKTtcbn07XG5cbmlwLmxvb3BiYWNrID0gZnVuY3Rpb24gKGZhbWlseSkge1xuICAvL1xuICAvLyBEZWZhdWx0IHRvIGBpcHY0YFxuICAvL1xuICBmYW1pbHkgPSBfbm9ybWFsaXplRmFtaWx5KGZhbWlseSk7XG5cbiAgaWYgKGZhbWlseSAhPT0gJ2lwdjQnICYmIGZhbWlseSAhPT0gJ2lwdjYnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmYW1pbHkgbXVzdCBiZSBpcHY0IG9yIGlwdjYnKTtcbiAgfVxuXG4gIHJldHVybiBmYW1pbHkgPT09ICdpcHY0JyA/ICcxMjcuMC4wLjEnIDogJ2ZlODA6OjEnO1xufTtcblxuLy9cbi8vICMjIyBmdW5jdGlvbiBhZGRyZXNzIChuYW1lLCBmYW1pbHkpXG4vLyAjIyMjIEBuYW1lIHtzdHJpbmd8J3B1YmxpYyd8J3ByaXZhdGUnfSAqKk9wdGlvbmFsKiogTmFtZSBvciBzZWN1cml0eVxuLy8gICAgICBvZiB0aGUgbmV0d29yayBpbnRlcmZhY2UuXG4vLyAjIyMjIEBmYW1pbHkge2lwdjR8aXB2Nn0gKipPcHRpb25hbCoqIElQIGZhbWlseSBvZiB0aGUgYWRkcmVzcyAoZGVmYXVsdHNcbi8vICAgICAgdG8gaXB2NCkuXG4vL1xuLy8gUmV0dXJucyB0aGUgYWRkcmVzcyBmb3IgdGhlIG5ldHdvcmsgaW50ZXJmYWNlIG9uIHRoZSBjdXJyZW50IHN5c3RlbSB3aXRoXG4vLyB0aGUgc3BlY2lmaWVkIGBuYW1lYDpcbi8vICAgKiBTdHJpbmc6IEZpcnN0IGBmYW1pbHlgIGFkZHJlc3Mgb2YgdGhlIGludGVyZmFjZS5cbi8vICAgICAgICAgICAgIElmIG5vdCBmb3VuZCBzZWUgYHVuZGVmaW5lZGAuXG4vLyAgICogJ3B1YmxpYyc6IHRoZSBmaXJzdCBwdWJsaWMgaXAgYWRkcmVzcyBvZiBmYW1pbHkuXG4vLyAgICogJ3ByaXZhdGUnOiB0aGUgZmlyc3QgcHJpdmF0ZSBpcCBhZGRyZXNzIG9mIGZhbWlseS5cbi8vICAgKiB1bmRlZmluZWQ6IEZpcnN0IGFkZHJlc3Mgd2l0aCBgaXB2NGAgb3IgbG9vcGJhY2sgYWRkcmVzcyBgMTI3LjAuMC4xYC5cbi8vXG5pcC5hZGRyZXNzID0gZnVuY3Rpb24gKG5hbWUsIGZhbWlseSkge1xuICBjb25zdCBpbnRlcmZhY2VzID0gb3MubmV0d29ya0ludGVyZmFjZXMoKTtcblxuICAvL1xuICAvLyBEZWZhdWx0IHRvIGBpcHY0YFxuICAvL1xuICBmYW1pbHkgPSBfbm9ybWFsaXplRmFtaWx5KGZhbWlseSk7XG5cbiAgLy9cbiAgLy8gSWYgYSBzcGVjaWZpYyBuZXR3b3JrIGludGVyZmFjZSBoYXMgYmVlbiBuYW1lZCxcbiAgLy8gcmV0dXJuIHRoZSBhZGRyZXNzLlxuICAvL1xuICBpZiAobmFtZSAmJiBuYW1lICE9PSAncHJpdmF0ZScgJiYgbmFtZSAhPT0gJ3B1YmxpYycpIHtcbiAgICBjb25zdCByZXMgPSBpbnRlcmZhY2VzW25hbWVdLmZpbHRlcigoZGV0YWlscykgPT4ge1xuICAgICAgY29uc3QgaXRlbUZhbWlseSA9IF9ub3JtYWxpemVGYW1pbHkoZGV0YWlscy5mYW1pbHkpO1xuICAgICAgcmV0dXJuIGl0ZW1GYW1pbHkgPT09IGZhbWlseTtcbiAgICB9KTtcbiAgICBpZiAocmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1swXS5hZGRyZXNzO1xuICB9XG5cbiAgY29uc3QgYWxsID0gT2JqZWN0LmtleXMoaW50ZXJmYWNlcykubWFwKChuaWMpID0+IHtcbiAgICAvL1xuICAgIC8vIE5vdGU6IG5hbWUgd2lsbCBvbmx5IGJlIGBwdWJsaWNgIG9yIGBwcml2YXRlYFxuICAgIC8vIHdoZW4gdGhpcyBpcyBjYWxsZWQuXG4gICAgLy9cbiAgICBjb25zdCBhZGRyZXNzZXMgPSBpbnRlcmZhY2VzW25pY10uZmlsdGVyKChkZXRhaWxzKSA9PiB7XG4gICAgICBkZXRhaWxzLmZhbWlseSA9IF9ub3JtYWxpemVGYW1pbHkoZGV0YWlscy5mYW1pbHkpO1xuICAgICAgaWYgKGRldGFpbHMuZmFtaWx5ICE9PSBmYW1pbHkgfHwgaXAuaXNMb29wYmFjayhkZXRhaWxzLmFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gaWYgKCFuYW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFtZSA9PT0gJ3B1YmxpYycgPyBpcC5pc1ByaXZhdGUoZGV0YWlscy5hZGRyZXNzKVxuICAgICAgICA6IGlwLmlzUHVibGljKGRldGFpbHMuYWRkcmVzcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYWRkcmVzc2VzLmxlbmd0aCA/IGFkZHJlc3Nlc1swXS5hZGRyZXNzIDogdW5kZWZpbmVkO1xuICB9KS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgcmV0dXJuICFhbGwubGVuZ3RoID8gaXAubG9vcGJhY2soZmFtaWx5KSA6IGFsbFswXTtcbn07XG5cbmlwLnRvTG9uZyA9IGZ1bmN0aW9uIChpcCkge1xuICBsZXQgaXBsID0gMDtcbiAgaXAuc3BsaXQoJy4nKS5mb3JFYWNoKChvY3RldCkgPT4ge1xuICAgIGlwbCA8PD0gODtcbiAgICBpcGwgKz0gcGFyc2VJbnQob2N0ZXQpO1xuICB9KTtcbiAgcmV0dXJuIChpcGwgPj4+IDApO1xufTtcblxuaXAuZnJvbUxvbmcgPSBmdW5jdGlvbiAoaXBsKSB7XG4gIHJldHVybiAoYCR7aXBsID4+PiAyNH0uJHtcbiAgICBpcGwgPj4gMTYgJiAyNTV9LiR7XG4gICAgaXBsID4+IDggJiAyNTV9LiR7XG4gICAgaXBsICYgMjU1fWApO1xufTtcbiJdLCJuYW1lcyI6WyJpcCIsImV4cG9ydHMiLCJCdWZmZXIiLCJyZXF1aXJlIiwib3MiLCJ0b0J1ZmZlciIsImJ1ZmYiLCJvZmZzZXQiLCJyZXN1bHQiLCJpc1Y0Rm9ybWF0IiwiYWxsb2MiLCJzcGxpdCIsIm1hcCIsImJ5dGUiLCJwYXJzZUludCIsImlzVjZGb3JtYXQiLCJzZWN0aW9ucyIsImkiLCJsZW5ndGgiLCJpc3Y0IiwidjRCdWZmZXIiLCJzbGljZSIsInRvU3RyaW5nIiwic3BsaWNlIiwidW5zaGlmdCIsInB1c2giLCJhcmd2Iiwid29yZCIsIkVycm9yIiwiam9pbiIsInJlYWRVSW50MTZCRSIsInJlcGxhY2UiLCJpcHY0UmVnZXgiLCJpcHY2UmVnZXgiLCJ0ZXN0IiwiX25vcm1hbGl6ZUZhbWlseSIsImZhbWlseSIsInRvTG93ZXJDYXNlIiwiZnJvbVByZWZpeExlbiIsInByZWZpeGxlbiIsImxlbiIsIm4iLCJiaXRzIiwibWFzayIsImFkZHIiLCJNYXRoIiwibWF4IiwiY2lkciIsImNpZHJTdHJpbmciLCJjaWRyUGFydHMiLCJzdWJuZXQiLCJuZXR3b3JrQWRkcmVzcyIsInRvTG9uZyIsIm1hc2tCdWZmZXIiLCJtYXNrTGVuZ3RoIiwib2N0ZXQiLCJudW1iZXJPZkFkZHJlc3NlcyIsImZyb21Mb25nIiwiZmlyc3RBZGRyZXNzIiwibGFzdEFkZHJlc3MiLCJicm9hZGNhc3RBZGRyZXNzIiwic3VibmV0TWFzayIsInN1Ym5ldE1hc2tMZW5ndGgiLCJudW1Ib3N0cyIsImNvbnRhaW5zIiwib3RoZXIiLCJjaWRyU3VibmV0Iiwibm90Iiwib3IiLCJhIiwiYiIsImlzRXF1YWwiLCJ0IiwiaXNQcml2YXRlIiwiaXNQdWJsaWMiLCJpc0xvb3BiYWNrIiwibG9vcGJhY2siLCJhZGRyZXNzIiwibmFtZSIsImludGVyZmFjZXMiLCJuZXR3b3JrSW50ZXJmYWNlcyIsInJlcyIsImZpbHRlciIsImRldGFpbHMiLCJpdGVtRmFtaWx5IiwidW5kZWZpbmVkIiwiYWxsIiwiT2JqZWN0Iiwia2V5cyIsIm5pYyIsImFkZHJlc3NlcyIsIkJvb2xlYW4iLCJpcGwiLCJmb3JFYWNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ip/lib/ip.js\n");

/***/ })

};
;