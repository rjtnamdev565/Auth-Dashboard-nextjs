/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/openid-client";
exports.ids = ["vendor-chunks/openid-client"];
exports.modules = {

/***/ "(rsc)/./node_modules/openid-client/lib/client.js":
/*!**************************************************!*\
  !*** ./node_modules/openid-client/lib/client.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { inspect } = __webpack_require__(/*! util */ \"util\");\nconst stdhttp = __webpack_require__(/*! http */ \"http\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst { strict: assert } = __webpack_require__(/*! assert */ \"assert\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst jose = __webpack_require__(/*! jose */ \"(rsc)/./node_modules/jose/dist/node/cjs/index.js\");\nconst tokenHash = __webpack_require__(/*! oidc-token-hash */ \"(rsc)/./node_modules/oidc-token-hash/lib/index.js\");\nconst isKeyObject = __webpack_require__(/*! ./helpers/is_key_object */ \"(rsc)/./node_modules/openid-client/lib/helpers/is_key_object.js\");\nconst decodeJWT = __webpack_require__(/*! ./helpers/decode_jwt */ \"(rsc)/./node_modules/openid-client/lib/helpers/decode_jwt.js\");\nconst base64url = __webpack_require__(/*! ./helpers/base64url */ \"(rsc)/./node_modules/openid-client/lib/helpers/base64url.js\");\nconst defaults = __webpack_require__(/*! ./helpers/defaults */ \"(rsc)/./node_modules/openid-client/lib/helpers/defaults.js\");\nconst parseWwwAuthenticate = __webpack_require__(/*! ./helpers/www_authenticate_parser */ \"(rsc)/./node_modules/openid-client/lib/helpers/www_authenticate_parser.js\");\nconst { assertSigningAlgValuesSupport, assertIssuerConfiguration } = __webpack_require__(/*! ./helpers/assert */ \"(rsc)/./node_modules/openid-client/lib/helpers/assert.js\");\nconst pick = __webpack_require__(/*! ./helpers/pick */ \"(rsc)/./node_modules/openid-client/lib/helpers/pick.js\");\nconst isPlainObject = __webpack_require__(/*! ./helpers/is_plain_object */ \"(rsc)/./node_modules/openid-client/lib/helpers/is_plain_object.js\");\nconst processResponse = __webpack_require__(/*! ./helpers/process_response */ \"(rsc)/./node_modules/openid-client/lib/helpers/process_response.js\");\nconst TokenSet = __webpack_require__(/*! ./token_set */ \"(rsc)/./node_modules/openid-client/lib/token_set.js\");\nconst { OPError, RPError } = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/openid-client/lib/errors.js\");\nconst now = __webpack_require__(/*! ./helpers/unix_timestamp */ \"(rsc)/./node_modules/openid-client/lib/helpers/unix_timestamp.js\");\nconst { random } = __webpack_require__(/*! ./helpers/generators */ \"(rsc)/./node_modules/openid-client/lib/helpers/generators.js\");\nconst request = __webpack_require__(/*! ./helpers/request */ \"(rsc)/./node_modules/openid-client/lib/helpers/request.js\");\nconst { CLOCK_TOLERANCE } = __webpack_require__(/*! ./helpers/consts */ \"(rsc)/./node_modules/openid-client/lib/helpers/consts.js\");\nconst { keystores } = __webpack_require__(/*! ./helpers/weak_cache */ \"(rsc)/./node_modules/openid-client/lib/helpers/weak_cache.js\");\nconst KeyStore = __webpack_require__(/*! ./helpers/keystore */ \"(rsc)/./node_modules/openid-client/lib/helpers/keystore.js\");\nconst clone = __webpack_require__(/*! ./helpers/deep_clone */ \"(rsc)/./node_modules/openid-client/lib/helpers/deep_clone.js\");\nconst { authenticatedPost, resolveResponseType, resolveRedirectUri } = __webpack_require__(/*! ./helpers/client */ \"(rsc)/./node_modules/openid-client/lib/helpers/client.js\");\nconst { queryKeyStore } = __webpack_require__(/*! ./helpers/issuer */ \"(rsc)/./node_modules/openid-client/lib/helpers/issuer.js\");\nconst DeviceFlowHandle = __webpack_require__(/*! ./device_flow_handle */ \"(rsc)/./node_modules/openid-client/lib/device_flow_handle.js\");\nconst [major, minor] = process.version.slice(1).split(\".\").map((str)=>parseInt(str, 10));\nconst rsaPssParams = major >= 17 || major === 16 && minor >= 9;\nconst retryAttempt = Symbol();\nconst skipNonceCheck = Symbol();\nconst skipMaxAgeCheck = Symbol();\nfunction pickCb(input) {\n    return pick(input, \"access_token\", \"code\", \"error_description\", \"error_uri\", \"error\", \"expires_in\", \"id_token\", \"iss\", \"response\", \"session_state\", \"state\", \"token_type\");\n}\nfunction authorizationHeaderValue(token, tokenType = \"Bearer\") {\n    return `${tokenType} ${token}`;\n}\nfunction verifyPresence(payload, jwt, prop) {\n    if (payload[prop] === undefined) {\n        throw new RPError({\n            message: `missing required JWT property ${prop}`,\n            jwt\n        });\n    }\n}\nfunction authorizationParams(params) {\n    const authParams = {\n        client_id: this.client_id,\n        scope: \"openid\",\n        response_type: resolveResponseType.call(this),\n        redirect_uri: resolveRedirectUri.call(this),\n        ...params\n    };\n    Object.entries(authParams).forEach(([key, value])=>{\n        if (value === null || value === undefined) {\n            delete authParams[key];\n        } else if (key === \"claims\" && typeof value === \"object\") {\n            authParams[key] = JSON.stringify(value);\n        } else if (key === \"resource\" && Array.isArray(value)) {\n            authParams[key] = value;\n        } else if (typeof value !== \"string\") {\n            authParams[key] = String(value);\n        }\n    });\n    return authParams;\n}\nfunction getKeystore(jwks) {\n    if (!isPlainObject(jwks) || !Array.isArray(jwks.keys) || jwks.keys.some((k)=>!isPlainObject(k) || !(\"kty\" in k))) {\n        throw new TypeError(\"jwks must be a JSON Web Key Set formatted object\");\n    }\n    return KeyStore.fromJWKS(jwks, {\n        onlyPrivate: true\n    });\n}\n// if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead\n// this is in place to take care of most common pitfalls when first using discovered Issuers without\n// the support for default values defined by Discovery 1.0\nfunction checkBasicSupport(client, properties) {\n    try {\n        const supported = client.issuer.token_endpoint_auth_methods_supported;\n        if (!supported.includes(properties.token_endpoint_auth_method)) {\n            if (supported.includes(\"client_secret_post\")) {\n                properties.token_endpoint_auth_method = \"client_secret_post\";\n            }\n        }\n    } catch (err) {}\n}\nfunction handleCommonMistakes(client, metadata, properties) {\n    if (!metadata.token_endpoint_auth_method) {\n        // if no explicit value was provided\n        checkBasicSupport(client, properties);\n    }\n    // :fp: c'mon people... RTFM\n    if (metadata.redirect_uri) {\n        if (metadata.redirect_uris) {\n            throw new TypeError(\"provide a redirect_uri or redirect_uris, not both\");\n        }\n        properties.redirect_uris = [\n            metadata.redirect_uri\n        ];\n        delete properties.redirect_uri;\n    }\n    if (metadata.response_type) {\n        if (metadata.response_types) {\n            throw new TypeError(\"provide a response_type or response_types, not both\");\n        }\n        properties.response_types = [\n            metadata.response_type\n        ];\n        delete properties.response_type;\n    }\n}\nfunction getDefaultsForEndpoint(endpoint, issuer, properties) {\n    if (!issuer[`${endpoint}_endpoint`]) return;\n    const tokenEndpointAuthMethod = properties.token_endpoint_auth_method;\n    const tokenEndpointAuthSigningAlg = properties.token_endpoint_auth_signing_alg;\n    const eam = `${endpoint}_endpoint_auth_method`;\n    const easa = `${endpoint}_endpoint_auth_signing_alg`;\n    if (properties[eam] === undefined && properties[easa] === undefined) {\n        if (tokenEndpointAuthMethod !== undefined) {\n            properties[eam] = tokenEndpointAuthMethod;\n        }\n        if (tokenEndpointAuthSigningAlg !== undefined) {\n            properties[easa] = tokenEndpointAuthSigningAlg;\n        }\n    }\n}\nclass BaseClient {\n    #metadata;\n    #issuer;\n    #aadIssValidation;\n    #additionalAuthorizedParties;\n    constructor(issuer, aadIssValidation, metadata = {}, jwks, options){\n        this.#metadata = new Map();\n        this.#issuer = issuer;\n        this.#aadIssValidation = aadIssValidation;\n        if (typeof metadata.client_id !== \"string\" || !metadata.client_id) {\n            throw new TypeError(\"client_id is required\");\n        }\n        const properties = {\n            grant_types: [\n                \"authorization_code\"\n            ],\n            id_token_signed_response_alg: \"RS256\",\n            authorization_signed_response_alg: \"RS256\",\n            response_types: [\n                \"code\"\n            ],\n            token_endpoint_auth_method: \"client_secret_basic\",\n            ...this.fapi() ? {\n                grant_types: [\n                    \"authorization_code\",\n                    \"implicit\"\n                ],\n                id_token_signed_response_alg: \"PS256\",\n                authorization_signed_response_alg: \"PS256\",\n                response_types: [\n                    \"code id_token\"\n                ],\n                tls_client_certificate_bound_access_tokens: true,\n                token_endpoint_auth_method: undefined\n            } : undefined,\n            ...metadata\n        };\n        if (this.fapi()) {\n            switch(properties.token_endpoint_auth_method){\n                case \"self_signed_tls_client_auth\":\n                case \"tls_client_auth\":\n                    break;\n                case \"private_key_jwt\":\n                    if (!jwks) {\n                        throw new TypeError(\"jwks is required\");\n                    }\n                    break;\n                case undefined:\n                    throw new TypeError(\"token_endpoint_auth_method is required\");\n                default:\n                    throw new TypeError(\"invalid or unsupported token_endpoint_auth_method\");\n            }\n        }\n        handleCommonMistakes(this, metadata, properties);\n        assertSigningAlgValuesSupport(\"token\", this.issuer, properties);\n        [\n            \"introspection\",\n            \"revocation\"\n        ].forEach((endpoint)=>{\n            getDefaultsForEndpoint(endpoint, this.issuer, properties);\n            assertSigningAlgValuesSupport(endpoint, this.issuer, properties);\n        });\n        Object.entries(properties).forEach(([key, value])=>{\n            this.#metadata.set(key, value);\n            if (!this[key]) {\n                Object.defineProperty(this, key, {\n                    get () {\n                        return this.#metadata.get(key);\n                    },\n                    enumerable: true\n                });\n            }\n        });\n        if (jwks !== undefined) {\n            const keystore = getKeystore.call(this, jwks);\n            keystores.set(this, keystore);\n        }\n        if (options != null && options.additionalAuthorizedParties) {\n            this.#additionalAuthorizedParties = clone(options.additionalAuthorizedParties);\n        }\n        this[CLOCK_TOLERANCE] = 0;\n    }\n    authorizationUrl(params = {}) {\n        if (!isPlainObject(params)) {\n            throw new TypeError(\"params must be a plain object\");\n        }\n        assertIssuerConfiguration(this.issuer, \"authorization_endpoint\");\n        const target = url.parse(this.issuer.authorization_endpoint, true);\n        target.search = null;\n        target.query = {\n            ...target.query,\n            ...authorizationParams.call(this, params)\n        };\n        return url.format(target);\n    }\n    authorizationPost(params = {}) {\n        if (!isPlainObject(params)) {\n            throw new TypeError(\"params must be a plain object\");\n        }\n        const inputs = authorizationParams.call(this, params);\n        const formInputs = Object.keys(inputs).map((name)=>`<input type=\"hidden\" name=\"${name}\" value=\"${inputs[name]}\"/>`).join(\"\\n\");\n        return `<!DOCTYPE html>\n<head>\n<title>Requesting Authorization</title>\n</head>\n<body onload=\"javascript:document.forms[0].submit()\">\n<form method=\"post\" action=\"${this.issuer.authorization_endpoint}\">\n  ${formInputs}\n</form>\n</body>\n</html>`;\n    }\n    endSessionUrl(params = {}) {\n        assertIssuerConfiguration(this.issuer, \"end_session_endpoint\");\n        const { 0: postLogout, length } = this.post_logout_redirect_uris || [];\n        const { post_logout_redirect_uri = length === 1 ? postLogout : undefined } = params;\n        let id_token_hint;\n        ({ id_token_hint, ...params } = params);\n        if (id_token_hint instanceof TokenSet) {\n            if (!id_token_hint.id_token) {\n                throw new TypeError(\"id_token not present in TokenSet\");\n            }\n            id_token_hint = id_token_hint.id_token;\n        }\n        const target = url.parse(this.issuer.end_session_endpoint, true);\n        target.search = null;\n        defaults(target.query, params, {\n            post_logout_redirect_uri,\n            client_id: this.client_id\n        }, {\n            id_token_hint\n        });\n        Object.entries(target.query).forEach(([key, value])=>{\n            if (value === null || value === undefined) {\n                delete target.query[key];\n            }\n        });\n        return url.format(target);\n    }\n    callbackParams(input) {\n        const isIncomingMessage = input instanceof stdhttp.IncomingMessage || input && input.method && input.url;\n        const isString = typeof input === \"string\";\n        if (!isString && !isIncomingMessage) {\n            throw new TypeError(\"#callbackParams only accepts string urls, http.IncomingMessage or a lookalike\");\n        }\n        if (isIncomingMessage) {\n            switch(input.method){\n                case \"GET\":\n                    return pickCb(url.parse(input.url, true).query);\n                case \"POST\":\n                    if (input.body === undefined) {\n                        throw new TypeError(\"incoming message body missing, include a body parser prior to this method call\");\n                    }\n                    switch(typeof input.body){\n                        case \"object\":\n                        case \"string\":\n                            if (Buffer.isBuffer(input.body)) {\n                                return pickCb(querystring.parse(input.body.toString(\"utf-8\")));\n                            }\n                            if (typeof input.body === \"string\") {\n                                return pickCb(querystring.parse(input.body));\n                            }\n                            return pickCb(input.body);\n                        default:\n                            throw new TypeError(\"invalid IncomingMessage body object\");\n                    }\n                default:\n                    throw new TypeError(\"invalid IncomingMessage method\");\n            }\n        } else {\n            return pickCb(url.parse(input, true).query);\n        }\n    }\n    async callback(redirectUri, parameters, checks = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n        let params = pickCb(parameters);\n        if (checks.jarm && !(\"response\" in parameters)) {\n            throw new RPError({\n                message: \"expected a JARM response\",\n                checks,\n                params\n            });\n        } else if (\"response\" in parameters) {\n            const decrypted = await this.decryptJARM(params.response);\n            params = await this.validateJARM(decrypted);\n        }\n        if (this.default_max_age && !checks.max_age) {\n            checks.max_age = this.default_max_age;\n        }\n        if (params.state && !checks.state) {\n            throw new TypeError(\"checks.state argument is missing\");\n        }\n        if (!params.state && checks.state) {\n            throw new RPError({\n                message: \"state missing from the response\",\n                checks,\n                params\n            });\n        }\n        if (checks.state !== params.state) {\n            throw new RPError({\n                printf: [\n                    \"state mismatch, expected %s, got: %s\",\n                    checks.state,\n                    params.state\n                ],\n                checks,\n                params\n            });\n        }\n        if (\"iss\" in params) {\n            assertIssuerConfiguration(this.issuer, \"issuer\");\n            if (params.iss !== this.issuer.issuer) {\n                throw new RPError({\n                    printf: [\n                        \"iss mismatch, expected %s, got: %s\",\n                        this.issuer.issuer,\n                        params.iss\n                    ],\n                    params\n                });\n            }\n        } else if (this.issuer.authorization_response_iss_parameter_supported && !(\"id_token\" in params) && !(\"response\" in parameters)) {\n            throw new RPError({\n                message: \"iss missing from the response\",\n                params\n            });\n        }\n        if (params.error) {\n            throw new OPError(params);\n        }\n        const RESPONSE_TYPE_REQUIRED_PARAMS = {\n            code: [\n                \"code\"\n            ],\n            id_token: [\n                \"id_token\"\n            ],\n            token: [\n                \"access_token\",\n                \"token_type\"\n            ]\n        };\n        if (checks.response_type) {\n            for (const type of checks.response_type.split(\" \")){\n                if (type === \"none\") {\n                    if (params.code || params.id_token || params.access_token) {\n                        throw new RPError({\n                            message: 'unexpected params encountered for \"none\" response',\n                            checks,\n                            params\n                        });\n                    }\n                } else {\n                    for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]){\n                        if (!params[param]) {\n                            throw new RPError({\n                                message: `${param} missing from response`,\n                                checks,\n                                params\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        if (params.id_token) {\n            const tokenset = new TokenSet(params);\n            await this.decryptIdToken(tokenset);\n            await this.validateIdToken(tokenset, checks.nonce, \"authorization\", checks.max_age, checks.state);\n            if (!params.code) {\n                return tokenset;\n            }\n        }\n        if (params.code) {\n            const tokenset = await this.grant({\n                ...exchangeBody,\n                grant_type: \"authorization_code\",\n                code: params.code,\n                redirect_uri: redirectUri,\n                code_verifier: checks.code_verifier\n            }, {\n                clientAssertionPayload,\n                DPoP\n            });\n            await this.decryptIdToken(tokenset);\n            await this.validateIdToken(tokenset, checks.nonce, \"token\", checks.max_age);\n            if (params.session_state) {\n                tokenset.session_state = params.session_state;\n            }\n            return tokenset;\n        }\n        return new TokenSet(params);\n    }\n    async oauthCallback(redirectUri, parameters, checks = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n        let params = pickCb(parameters);\n        if (checks.jarm && !(\"response\" in parameters)) {\n            throw new RPError({\n                message: \"expected a JARM response\",\n                checks,\n                params\n            });\n        } else if (\"response\" in parameters) {\n            const decrypted = await this.decryptJARM(params.response);\n            params = await this.validateJARM(decrypted);\n        }\n        if (params.state && !checks.state) {\n            throw new TypeError(\"checks.state argument is missing\");\n        }\n        if (!params.state && checks.state) {\n            throw new RPError({\n                message: \"state missing from the response\",\n                checks,\n                params\n            });\n        }\n        if (checks.state !== params.state) {\n            throw new RPError({\n                printf: [\n                    \"state mismatch, expected %s, got: %s\",\n                    checks.state,\n                    params.state\n                ],\n                checks,\n                params\n            });\n        }\n        if (\"iss\" in params) {\n            assertIssuerConfiguration(this.issuer, \"issuer\");\n            if (params.iss !== this.issuer.issuer) {\n                throw new RPError({\n                    printf: [\n                        \"iss mismatch, expected %s, got: %s\",\n                        this.issuer.issuer,\n                        params.iss\n                    ],\n                    params\n                });\n            }\n        } else if (this.issuer.authorization_response_iss_parameter_supported && !(\"id_token\" in params) && !(\"response\" in parameters)) {\n            throw new RPError({\n                message: \"iss missing from the response\",\n                params\n            });\n        }\n        if (params.error) {\n            throw new OPError(params);\n        }\n        if (typeof params.id_token === \"string\" && params.id_token.length) {\n            throw new RPError({\n                message: \"id_token detected in the response, you must use client.callback() instead of client.oauthCallback()\",\n                params\n            });\n        }\n        delete params.id_token;\n        const RESPONSE_TYPE_REQUIRED_PARAMS = {\n            code: [\n                \"code\"\n            ],\n            token: [\n                \"access_token\",\n                \"token_type\"\n            ]\n        };\n        if (checks.response_type) {\n            for (const type of checks.response_type.split(\" \")){\n                if (type === \"none\") {\n                    if (params.code || params.id_token || params.access_token) {\n                        throw new RPError({\n                            message: 'unexpected params encountered for \"none\" response',\n                            checks,\n                            params\n                        });\n                    }\n                }\n                if (RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n                    for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]){\n                        if (!params[param]) {\n                            throw new RPError({\n                                message: `${param} missing from response`,\n                                checks,\n                                params\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        if (params.code) {\n            const tokenset = await this.grant({\n                ...exchangeBody,\n                grant_type: \"authorization_code\",\n                code: params.code,\n                redirect_uri: redirectUri,\n                code_verifier: checks.code_verifier\n            }, {\n                clientAssertionPayload,\n                DPoP\n            });\n            if (typeof tokenset.id_token === \"string\" && tokenset.id_token.length) {\n                throw new RPError({\n                    message: \"id_token detected in the response, you must use client.callback() instead of client.oauthCallback()\",\n                    params\n                });\n            }\n            delete tokenset.id_token;\n            return tokenset;\n        }\n        return new TokenSet(params);\n    }\n    async decryptIdToken(token) {\n        if (!this.id_token_encrypted_response_alg) {\n            return token;\n        }\n        let idToken = token;\n        if (idToken instanceof TokenSet) {\n            if (!idToken.id_token) {\n                throw new TypeError(\"id_token not present in TokenSet\");\n            }\n            idToken = idToken.id_token;\n        }\n        const expectedAlg = this.id_token_encrypted_response_alg;\n        const expectedEnc = this.id_token_encrypted_response_enc;\n        const result = await this.decryptJWE(idToken, expectedAlg, expectedEnc);\n        if (token instanceof TokenSet) {\n            token.id_token = result;\n            return token;\n        }\n        return result;\n    }\n    async validateJWTUserinfo(body) {\n        const expectedAlg = this.userinfo_signed_response_alg;\n        return this.validateJWT(body, expectedAlg, []);\n    }\n    async decryptJARM(response) {\n        if (!this.authorization_encrypted_response_alg) {\n            return response;\n        }\n        const expectedAlg = this.authorization_encrypted_response_alg;\n        const expectedEnc = this.authorization_encrypted_response_enc;\n        return this.decryptJWE(response, expectedAlg, expectedEnc);\n    }\n    async decryptJWTUserinfo(body) {\n        if (!this.userinfo_encrypted_response_alg) {\n            return body;\n        }\n        const expectedAlg = this.userinfo_encrypted_response_alg;\n        const expectedEnc = this.userinfo_encrypted_response_enc;\n        return this.decryptJWE(body, expectedAlg, expectedEnc);\n    }\n    async decryptJWE(jwe, expectedAlg, expectedEnc = \"A128CBC-HS256\") {\n        const header = JSON.parse(base64url.decode(jwe.split(\".\")[0]));\n        if (header.alg !== expectedAlg) {\n            throw new RPError({\n                printf: [\n                    \"unexpected JWE alg received, expected %s, got: %s\",\n                    expectedAlg,\n                    header.alg\n                ],\n                jwt: jwe\n            });\n        }\n        if (header.enc !== expectedEnc) {\n            throw new RPError({\n                printf: [\n                    \"unexpected JWE enc received, expected %s, got: %s\",\n                    expectedEnc,\n                    header.enc\n                ],\n                jwt: jwe\n            });\n        }\n        const getPlaintext = (result)=>new TextDecoder().decode(result.plaintext);\n        let plaintext;\n        if (expectedAlg.match(/^(?:RSA|ECDH)/)) {\n            const keystore = await keystores.get(this);\n            for (const { keyObject: key } of keystore.all({\n                ...jose.decodeProtectedHeader(jwe),\n                use: \"enc\"\n            })){\n                plaintext = await jose.compactDecrypt(jwe, key).then(getPlaintext, ()=>{});\n                if (plaintext) break;\n            }\n        } else {\n            plaintext = await jose.compactDecrypt(jwe, this.secretForAlg(expectedAlg === \"dir\" ? expectedEnc : expectedAlg)).then(getPlaintext, ()=>{});\n        }\n        if (!plaintext) {\n            throw new RPError({\n                message: \"failed to decrypt JWE\",\n                jwt: jwe\n            });\n        }\n        return plaintext;\n    }\n    async validateIdToken(tokenSet, nonce, returnedBy, maxAge, state) {\n        let idToken = tokenSet;\n        const expectedAlg = this.id_token_signed_response_alg;\n        const isTokenSet = idToken instanceof TokenSet;\n        if (isTokenSet) {\n            if (!idToken.id_token) {\n                throw new TypeError(\"id_token not present in TokenSet\");\n            }\n            idToken = idToken.id_token;\n        }\n        idToken = String(idToken);\n        const timestamp = now();\n        const { protected: header, payload, key } = await this.validateJWT(idToken, expectedAlg);\n        if (typeof maxAge === \"number\" || maxAge !== skipMaxAgeCheck && this.require_auth_time) {\n            if (!payload.auth_time) {\n                throw new RPError({\n                    message: \"missing required JWT property auth_time\",\n                    jwt: idToken\n                });\n            }\n            if (typeof payload.auth_time !== \"number\") {\n                throw new RPError({\n                    message: \"JWT auth_time claim must be a JSON numeric value\",\n                    jwt: idToken\n                });\n            }\n        }\n        if (typeof maxAge === \"number\" && payload.auth_time + maxAge < timestamp - this[CLOCK_TOLERANCE]) {\n            throw new RPError({\n                printf: [\n                    \"too much time has elapsed since the last End-User authentication, max_age %i, auth_time: %i, now %i\",\n                    maxAge,\n                    payload.auth_time,\n                    timestamp - this[CLOCK_TOLERANCE]\n                ],\n                now: timestamp,\n                tolerance: this[CLOCK_TOLERANCE],\n                auth_time: payload.auth_time,\n                jwt: idToken\n            });\n        }\n        if (nonce !== skipNonceCheck && (payload.nonce || nonce !== undefined) && payload.nonce !== nonce) {\n            throw new RPError({\n                printf: [\n                    \"nonce mismatch, expected %s, got: %s\",\n                    nonce,\n                    payload.nonce\n                ],\n                jwt: idToken\n            });\n        }\n        if (returnedBy === \"authorization\") {\n            if (!payload.at_hash && tokenSet.access_token) {\n                throw new RPError({\n                    message: \"missing required property at_hash\",\n                    jwt: idToken\n                });\n            }\n            if (!payload.c_hash && tokenSet.code) {\n                throw new RPError({\n                    message: \"missing required property c_hash\",\n                    jwt: idToken\n                });\n            }\n            if (this.fapi()) {\n                if (!payload.s_hash && (tokenSet.state || state)) {\n                    throw new RPError({\n                        message: \"missing required property s_hash\",\n                        jwt: idToken\n                    });\n                }\n            }\n            if (payload.s_hash) {\n                if (!state) {\n                    throw new TypeError('cannot verify s_hash, \"checks.state\" property not provided');\n                }\n                try {\n                    tokenHash.validate({\n                        claim: \"s_hash\",\n                        source: \"state\"\n                    }, payload.s_hash, state, header.alg, key.jwk && key.jwk.crv);\n                } catch (err) {\n                    throw new RPError({\n                        message: err.message,\n                        jwt: idToken\n                    });\n                }\n            }\n        }\n        if (this.fapi() && payload.iat < timestamp - 3600) {\n            throw new RPError({\n                printf: [\n                    \"JWT issued too far in the past, now %i, iat %i\",\n                    timestamp,\n                    payload.iat\n                ],\n                now: timestamp,\n                tolerance: this[CLOCK_TOLERANCE],\n                iat: payload.iat,\n                jwt: idToken\n            });\n        }\n        if (tokenSet.access_token && payload.at_hash !== undefined) {\n            try {\n                tokenHash.validate({\n                    claim: \"at_hash\",\n                    source: \"access_token\"\n                }, payload.at_hash, tokenSet.access_token, header.alg, key.jwk && key.jwk.crv);\n            } catch (err) {\n                throw new RPError({\n                    message: err.message,\n                    jwt: idToken\n                });\n            }\n        }\n        if (tokenSet.code && payload.c_hash !== undefined) {\n            try {\n                tokenHash.validate({\n                    claim: \"c_hash\",\n                    source: \"code\"\n                }, payload.c_hash, tokenSet.code, header.alg, key.jwk && key.jwk.crv);\n            } catch (err) {\n                throw new RPError({\n                    message: err.message,\n                    jwt: idToken\n                });\n            }\n        }\n        return tokenSet;\n    }\n    async validateJWT(jwt, expectedAlg, required = [\n        \"iss\",\n        \"sub\",\n        \"aud\",\n        \"exp\",\n        \"iat\"\n    ]) {\n        const isSelfIssued = this.issuer.issuer === \"https://self-issued.me\";\n        const timestamp = now();\n        let header;\n        let payload;\n        try {\n            ({ header, payload } = decodeJWT(jwt, {\n                complete: true\n            }));\n        } catch (err) {\n            throw new RPError({\n                printf: [\n                    \"failed to decode JWT (%s: %s)\",\n                    err.name,\n                    err.message\n                ],\n                jwt\n            });\n        }\n        if (header.alg !== expectedAlg) {\n            throw new RPError({\n                printf: [\n                    \"unexpected JWT alg received, expected %s, got: %s\",\n                    expectedAlg,\n                    header.alg\n                ],\n                jwt\n            });\n        }\n        if (isSelfIssued) {\n            required = [\n                ...required,\n                \"sub_jwk\"\n            ];\n        }\n        required.forEach(verifyPresence.bind(undefined, payload, jwt));\n        if (payload.iss !== undefined) {\n            let expectedIss = this.issuer.issuer;\n            if (this.#aadIssValidation) {\n                expectedIss = this.issuer.issuer.replace(\"{tenantid}\", payload.tid);\n            }\n            if (payload.iss !== expectedIss) {\n                throw new RPError({\n                    printf: [\n                        \"unexpected iss value, expected %s, got: %s\",\n                        expectedIss,\n                        payload.iss\n                    ],\n                    jwt\n                });\n            }\n        }\n        if (payload.iat !== undefined) {\n            if (typeof payload.iat !== \"number\") {\n                throw new RPError({\n                    message: \"JWT iat claim must be a JSON numeric value\",\n                    jwt\n                });\n            }\n        }\n        if (payload.nbf !== undefined) {\n            if (typeof payload.nbf !== \"number\") {\n                throw new RPError({\n                    message: \"JWT nbf claim must be a JSON numeric value\",\n                    jwt\n                });\n            }\n            if (payload.nbf > timestamp + this[CLOCK_TOLERANCE]) {\n                throw new RPError({\n                    printf: [\n                        \"JWT not active yet, now %i, nbf %i\",\n                        timestamp + this[CLOCK_TOLERANCE],\n                        payload.nbf\n                    ],\n                    now: timestamp,\n                    tolerance: this[CLOCK_TOLERANCE],\n                    nbf: payload.nbf,\n                    jwt\n                });\n            }\n        }\n        if (payload.exp !== undefined) {\n            if (typeof payload.exp !== \"number\") {\n                throw new RPError({\n                    message: \"JWT exp claim must be a JSON numeric value\",\n                    jwt\n                });\n            }\n            if (timestamp - this[CLOCK_TOLERANCE] >= payload.exp) {\n                throw new RPError({\n                    printf: [\n                        \"JWT expired, now %i, exp %i\",\n                        timestamp - this[CLOCK_TOLERANCE],\n                        payload.exp\n                    ],\n                    now: timestamp,\n                    tolerance: this[CLOCK_TOLERANCE],\n                    exp: payload.exp,\n                    jwt\n                });\n            }\n        }\n        if (payload.aud !== undefined) {\n            if (Array.isArray(payload.aud)) {\n                if (payload.aud.length > 1 && !payload.azp) {\n                    throw new RPError({\n                        message: \"missing required JWT property azp\",\n                        jwt\n                    });\n                }\n                if (!payload.aud.includes(this.client_id)) {\n                    throw new RPError({\n                        printf: [\n                            \"aud is missing the client_id, expected %s to be included in %j\",\n                            this.client_id,\n                            payload.aud\n                        ],\n                        jwt\n                    });\n                }\n            } else if (payload.aud !== this.client_id) {\n                throw new RPError({\n                    printf: [\n                        \"aud mismatch, expected %s, got: %s\",\n                        this.client_id,\n                        payload.aud\n                    ],\n                    jwt\n                });\n            }\n        }\n        if (payload.azp !== undefined) {\n            let additionalAuthorizedParties = this.#additionalAuthorizedParties;\n            if (typeof additionalAuthorizedParties === \"string\") {\n                additionalAuthorizedParties = [\n                    this.client_id,\n                    additionalAuthorizedParties\n                ];\n            } else if (Array.isArray(additionalAuthorizedParties)) {\n                additionalAuthorizedParties = [\n                    this.client_id,\n                    ...additionalAuthorizedParties\n                ];\n            } else {\n                additionalAuthorizedParties = [\n                    this.client_id\n                ];\n            }\n            if (!additionalAuthorizedParties.includes(payload.azp)) {\n                throw new RPError({\n                    printf: [\n                        \"azp mismatch, got: %s\",\n                        payload.azp\n                    ],\n                    jwt\n                });\n            }\n        }\n        let keys;\n        if (isSelfIssued) {\n            try {\n                assert(isPlainObject(payload.sub_jwk));\n                const key = await jose.importJWK(payload.sub_jwk, header.alg);\n                assert.equal(key.type, \"public\");\n                keys = [\n                    {\n                        keyObject: key\n                    }\n                ];\n            } catch (err) {\n                throw new RPError({\n                    message: \"failed to use sub_jwk claim as an asymmetric JSON Web Key\",\n                    jwt\n                });\n            }\n            if (await jose.calculateJwkThumbprint(payload.sub_jwk) !== payload.sub) {\n                throw new RPError({\n                    message: \"failed to match the subject with sub_jwk\",\n                    jwt\n                });\n            }\n        } else if (header.alg.startsWith(\"HS\")) {\n            keys = [\n                this.secretForAlg(header.alg)\n            ];\n        } else if (header.alg !== \"none\") {\n            keys = await queryKeyStore.call(this.issuer, {\n                ...header,\n                use: \"sig\"\n            });\n        }\n        if (!keys && header.alg === \"none\") {\n            return {\n                protected: header,\n                payload\n            };\n        }\n        for (const key of keys){\n            const verified = await jose.compactVerify(jwt, key instanceof Uint8Array ? key : key.keyObject).catch(()=>{});\n            if (verified) {\n                return {\n                    payload,\n                    protected: verified.protectedHeader,\n                    key\n                };\n            }\n        }\n        throw new RPError({\n            message: \"failed to validate JWT signature\",\n            jwt\n        });\n    }\n    async refresh(refreshToken, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n        let token = refreshToken;\n        if (token instanceof TokenSet) {\n            if (!token.refresh_token) {\n                throw new TypeError(\"refresh_token not present in TokenSet\");\n            }\n            token = token.refresh_token;\n        }\n        const tokenset = await this.grant({\n            ...exchangeBody,\n            grant_type: \"refresh_token\",\n            refresh_token: String(token)\n        }, {\n            clientAssertionPayload,\n            DPoP\n        });\n        if (tokenset.id_token) {\n            await this.decryptIdToken(tokenset);\n            await this.validateIdToken(tokenset, skipNonceCheck, \"token\", skipMaxAgeCheck);\n            if (refreshToken instanceof TokenSet && refreshToken.id_token) {\n                const expectedSub = refreshToken.claims().sub;\n                const actualSub = tokenset.claims().sub;\n                if (actualSub !== expectedSub) {\n                    throw new RPError({\n                        printf: [\n                            \"sub mismatch, expected %s, got: %s\",\n                            expectedSub,\n                            actualSub\n                        ],\n                        jwt: tokenset.id_token\n                    });\n                }\n            }\n        }\n        return tokenset;\n    }\n    async requestResource(resourceUrl, accessToken, { method, headers, body, DPoP, tokenType = DPoP ? \"DPoP\" : accessToken instanceof TokenSet ? accessToken.token_type : \"Bearer\" } = {}, retry) {\n        if (accessToken instanceof TokenSet) {\n            if (!accessToken.access_token) {\n                throw new TypeError(\"access_token not present in TokenSet\");\n            }\n            accessToken = accessToken.access_token;\n        }\n        if (!accessToken) {\n            throw new TypeError(\"no access token provided\");\n        } else if (typeof accessToken !== \"string\") {\n            throw new TypeError(\"invalid access token provided\");\n        }\n        const requestOpts = {\n            headers: {\n                Authorization: authorizationHeaderValue(accessToken, tokenType),\n                ...headers\n            },\n            body\n        };\n        const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n        const response = await request.call(this, {\n            ...requestOpts,\n            responseType: \"buffer\",\n            method,\n            url: resourceUrl\n        }, {\n            accessToken,\n            mTLS,\n            DPoP\n        });\n        const wwwAuthenticate = response.headers[\"www-authenticate\"];\n        if (retry !== retryAttempt && wwwAuthenticate && wwwAuthenticate.toLowerCase().startsWith(\"dpop \") && parseWwwAuthenticate(wwwAuthenticate).error === \"use_dpop_nonce\") {\n            return this.requestResource(resourceUrl, accessToken, {\n                method,\n                headers,\n                body,\n                DPoP,\n                tokenType\n            });\n        }\n        return response;\n    }\n    async userinfo(accessToken, { method = \"GET\", via = \"header\", tokenType, params, DPoP } = {}) {\n        assertIssuerConfiguration(this.issuer, \"userinfo_endpoint\");\n        const options = {\n            tokenType,\n            method: String(method).toUpperCase(),\n            DPoP\n        };\n        if (options.method !== \"GET\" && options.method !== \"POST\") {\n            throw new TypeError(\"#userinfo() method can only be POST or a GET\");\n        }\n        if (via === \"body\" && options.method !== \"POST\") {\n            throw new TypeError(\"can only send body on POST\");\n        }\n        const jwt = !!(this.userinfo_signed_response_alg || this.userinfo_encrypted_response_alg);\n        if (jwt) {\n            options.headers = {\n                Accept: \"application/jwt\"\n            };\n        } else {\n            options.headers = {\n                Accept: \"application/json\"\n            };\n        }\n        const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n        let targetUrl;\n        if (mTLS && this.issuer.mtls_endpoint_aliases) {\n            targetUrl = this.issuer.mtls_endpoint_aliases.userinfo_endpoint;\n        }\n        targetUrl = new url.URL(targetUrl || this.issuer.userinfo_endpoint);\n        if (via === \"body\") {\n            options.headers.Authorization = undefined;\n            options.headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n            options.body = new url.URLSearchParams();\n            options.body.append(\"access_token\", accessToken instanceof TokenSet ? accessToken.access_token : accessToken);\n        }\n        // handle additional parameters, GET via querystring, POST via urlencoded body\n        if (params) {\n            if (options.method === \"GET\") {\n                Object.entries(params).forEach(([key, value])=>{\n                    targetUrl.searchParams.append(key, value);\n                });\n            } else if (options.body) {\n                // POST && via body\n                Object.entries(params).forEach(([key, value])=>{\n                    options.body.append(key, value);\n                });\n            } else {\n                // POST && via header\n                options.body = new url.URLSearchParams();\n                options.headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n                Object.entries(params).forEach(([key, value])=>{\n                    options.body.append(key, value);\n                });\n            }\n        }\n        if (options.body) {\n            options.body = options.body.toString();\n        }\n        const response = await this.requestResource(targetUrl, accessToken, options);\n        let parsed = processResponse(response, {\n            bearer: true\n        });\n        if (jwt) {\n            if (!/^application\\/jwt/.test(response.headers[\"content-type\"])) {\n                throw new RPError({\n                    message: \"expected application/jwt response from the userinfo_endpoint\",\n                    response\n                });\n            }\n            const body = response.body.toString();\n            const userinfo = await this.decryptJWTUserinfo(body);\n            if (!this.userinfo_signed_response_alg) {\n                try {\n                    parsed = JSON.parse(userinfo);\n                    assert(isPlainObject(parsed));\n                } catch (err) {\n                    throw new RPError({\n                        message: \"failed to parse userinfo JWE payload as JSON\",\n                        jwt: userinfo\n                    });\n                }\n            } else {\n                ({ payload: parsed } = await this.validateJWTUserinfo(userinfo));\n            }\n        } else {\n            try {\n                parsed = JSON.parse(response.body);\n            } catch (err) {\n                Object.defineProperty(err, \"response\", {\n                    value: response\n                });\n                throw err;\n            }\n        }\n        if (accessToken instanceof TokenSet && accessToken.id_token) {\n            const expectedSub = accessToken.claims().sub;\n            if (parsed.sub !== expectedSub) {\n                throw new RPError({\n                    printf: [\n                        \"userinfo sub mismatch, expected %s, got: %s\",\n                        expectedSub,\n                        parsed.sub\n                    ],\n                    body: parsed,\n                    jwt: accessToken.id_token\n                });\n            }\n        }\n        return parsed;\n    }\n    encryptionSecret(len) {\n        const hash = len <= 256 ? \"sha256\" : len <= 384 ? \"sha384\" : len <= 512 ? \"sha512\" : false;\n        if (!hash) {\n            throw new Error(\"unsupported symmetric encryption key derivation\");\n        }\n        return crypto.createHash(hash).update(this.client_secret).digest().slice(0, len / 8);\n    }\n    secretForAlg(alg) {\n        if (!this.client_secret) {\n            throw new TypeError(\"client_secret is required\");\n        }\n        if (/^A(\\d{3})(?:GCM)?KW$/.test(alg)) {\n            return this.encryptionSecret(parseInt(RegExp.$1, 10));\n        }\n        if (/^A(\\d{3})(?:GCM|CBC-HS(\\d{3}))$/.test(alg)) {\n            return this.encryptionSecret(parseInt(RegExp.$2 || RegExp.$1, 10));\n        }\n        return new TextEncoder().encode(this.client_secret);\n    }\n    async grant(body, { clientAssertionPayload, DPoP } = {}, retry) {\n        assertIssuerConfiguration(this.issuer, \"token_endpoint\");\n        const response = await authenticatedPost.call(this, \"token\", {\n            form: body,\n            responseType: \"json\"\n        }, {\n            clientAssertionPayload,\n            DPoP\n        });\n        let responseBody;\n        try {\n            responseBody = processResponse(response);\n        } catch (err) {\n            if (retry !== retryAttempt && err instanceof OPError && err.error === \"use_dpop_nonce\") {\n                return this.grant(body, {\n                    clientAssertionPayload,\n                    DPoP\n                }, retryAttempt);\n            }\n            throw err;\n        }\n        return new TokenSet(responseBody);\n    }\n    async deviceAuthorization(params = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n        assertIssuerConfiguration(this.issuer, \"device_authorization_endpoint\");\n        assertIssuerConfiguration(this.issuer, \"token_endpoint\");\n        const body = authorizationParams.call(this, {\n            client_id: this.client_id,\n            redirect_uri: null,\n            response_type: null,\n            ...params\n        });\n        const response = await authenticatedPost.call(this, \"device_authorization\", {\n            responseType: \"json\",\n            form: body\n        }, {\n            clientAssertionPayload,\n            endpointAuthMethod: \"token\"\n        });\n        const responseBody = processResponse(response);\n        return new DeviceFlowHandle({\n            client: this,\n            exchangeBody,\n            clientAssertionPayload,\n            response: responseBody,\n            maxAge: params.max_age,\n            DPoP\n        });\n    }\n    async revoke(token, hint, { revokeBody, clientAssertionPayload } = {}) {\n        assertIssuerConfiguration(this.issuer, \"revocation_endpoint\");\n        if (hint !== undefined && typeof hint !== \"string\") {\n            throw new TypeError(\"hint must be a string\");\n        }\n        const form = {\n            ...revokeBody,\n            token\n        };\n        if (hint) {\n            form.token_type_hint = hint;\n        }\n        const response = await authenticatedPost.call(this, \"revocation\", {\n            form\n        }, {\n            clientAssertionPayload\n        });\n        processResponse(response, {\n            body: false\n        });\n    }\n    async introspect(token, hint, { introspectBody, clientAssertionPayload } = {}) {\n        assertIssuerConfiguration(this.issuer, \"introspection_endpoint\");\n        if (hint !== undefined && typeof hint !== \"string\") {\n            throw new TypeError(\"hint must be a string\");\n        }\n        const form = {\n            ...introspectBody,\n            token\n        };\n        if (hint) {\n            form.token_type_hint = hint;\n        }\n        const response = await authenticatedPost.call(this, \"introspection\", {\n            form,\n            responseType: \"json\"\n        }, {\n            clientAssertionPayload\n        });\n        const responseBody = processResponse(response);\n        return responseBody;\n    }\n    static async register(metadata, options = {}) {\n        const { initialAccessToken, jwks, ...clientOptions } = options;\n        assertIssuerConfiguration(this.issuer, \"registration_endpoint\");\n        if (jwks !== undefined && !(metadata.jwks || metadata.jwks_uri)) {\n            const keystore = await getKeystore.call(this, jwks);\n            metadata.jwks = keystore.toJWKS();\n        }\n        const response = await request.call(this, {\n            headers: {\n                Accept: \"application/json\",\n                ...initialAccessToken ? {\n                    Authorization: authorizationHeaderValue(initialAccessToken)\n                } : undefined\n            },\n            responseType: \"json\",\n            json: metadata,\n            url: this.issuer.registration_endpoint,\n            method: \"POST\"\n        });\n        const responseBody = processResponse(response, {\n            statusCode: 201,\n            bearer: true\n        });\n        return new this(responseBody, jwks, clientOptions);\n    }\n    get metadata() {\n        return clone(Object.fromEntries(this.#metadata.entries()));\n    }\n    static async fromUri(registrationClientUri, registrationAccessToken, jwks, clientOptions) {\n        const response = await request.call(this, {\n            method: \"GET\",\n            url: registrationClientUri,\n            responseType: \"json\",\n            headers: {\n                Authorization: authorizationHeaderValue(registrationAccessToken),\n                Accept: \"application/json\"\n            }\n        });\n        const responseBody = processResponse(response, {\n            bearer: true\n        });\n        return new this(responseBody, jwks, clientOptions);\n    }\n    async requestObject(requestObject = {}, { sign: signingAlgorithm = this.request_object_signing_alg || \"none\", encrypt: { alg: eKeyManagement = this.request_object_encryption_alg, enc: eContentEncryption = this.request_object_encryption_enc || \"A128CBC-HS256\" } = {} } = {}) {\n        if (!isPlainObject(requestObject)) {\n            throw new TypeError(\"requestObject must be a plain object\");\n        }\n        let signed;\n        let key;\n        const unix = now();\n        const header = {\n            alg: signingAlgorithm,\n            typ: \"oauth-authz-req+jwt\"\n        };\n        const payload = JSON.stringify(defaults({}, requestObject, {\n            iss: this.client_id,\n            aud: this.issuer.issuer,\n            client_id: this.client_id,\n            jti: random(),\n            iat: unix,\n            exp: unix + 300,\n            ...this.fapi() ? {\n                nbf: unix\n            } : undefined\n        }));\n        if (signingAlgorithm === \"none\") {\n            signed = [\n                base64url.encode(JSON.stringify(header)),\n                base64url.encode(payload),\n                \"\"\n            ].join(\".\");\n        } else {\n            const symmetric = signingAlgorithm.startsWith(\"HS\");\n            if (symmetric) {\n                key = this.secretForAlg(signingAlgorithm);\n            } else {\n                const keystore = await keystores.get(this);\n                if (!keystore) {\n                    throw new TypeError(`no keystore present for client, cannot sign using alg ${signingAlgorithm}`);\n                }\n                key = keystore.get({\n                    alg: signingAlgorithm,\n                    use: \"sig\"\n                });\n                if (!key) {\n                    throw new TypeError(`no key to sign with found for alg ${signingAlgorithm}`);\n                }\n            }\n            signed = await new jose.CompactSign(new TextEncoder().encode(payload)).setProtectedHeader({\n                ...header,\n                kid: symmetric ? undefined : key.jwk.kid\n            }).sign(symmetric ? key : key.keyObject);\n        }\n        if (!eKeyManagement) {\n            return signed;\n        }\n        const fields = {\n            alg: eKeyManagement,\n            enc: eContentEncryption,\n            cty: \"oauth-authz-req+jwt\"\n        };\n        if (fields.alg.match(/^(RSA|ECDH)/)) {\n            [key] = await queryKeyStore.call(this.issuer, {\n                alg: fields.alg,\n                use: \"enc\"\n            }, {\n                allowMulti: true\n            });\n        } else {\n            key = this.secretForAlg(fields.alg === \"dir\" ? fields.enc : fields.alg);\n        }\n        return new jose.CompactEncrypt(new TextEncoder().encode(signed)).setProtectedHeader({\n            ...fields,\n            kid: key instanceof Uint8Array ? undefined : key.jwk.kid\n        }).encrypt(key instanceof Uint8Array ? key : key.keyObject);\n    }\n    async pushedAuthorizationRequest(params = {}, { clientAssertionPayload } = {}) {\n        assertIssuerConfiguration(this.issuer, \"pushed_authorization_request_endpoint\");\n        const body = {\n            ...\"request\" in params ? params : authorizationParams.call(this, params),\n            client_id: this.client_id\n        };\n        const response = await authenticatedPost.call(this, \"pushed_authorization_request\", {\n            responseType: \"json\",\n            form: body\n        }, {\n            clientAssertionPayload,\n            endpointAuthMethod: \"token\"\n        });\n        const responseBody = processResponse(response, {\n            statusCode: 201\n        });\n        if (!(\"expires_in\" in responseBody)) {\n            throw new RPError({\n                message: \"expected expires_in in Pushed Authorization Successful Response\",\n                response\n            });\n        }\n        if (typeof responseBody.expires_in !== \"number\") {\n            throw new RPError({\n                message: \"invalid expires_in value in Pushed Authorization Successful Response\",\n                response\n            });\n        }\n        if (!(\"request_uri\" in responseBody)) {\n            throw new RPError({\n                message: \"expected request_uri in Pushed Authorization Successful Response\",\n                response\n            });\n        }\n        if (typeof responseBody.request_uri !== \"string\") {\n            throw new RPError({\n                message: \"invalid request_uri value in Pushed Authorization Successful Response\",\n                response\n            });\n        }\n        return responseBody;\n    }\n    get issuer() {\n        return this.#issuer;\n    }\n    /* istanbul ignore next */ [inspect.custom]() {\n        return `${this.constructor.name} ${inspect(this.metadata, {\n            depth: Infinity,\n            colors: process.stdout.isTTY,\n            compact: false,\n            sorted: true\n        })}`;\n    }\n    fapi() {\n        return this.constructor.name === \"FAPI1Client\";\n    }\n    async validateJARM(response) {\n        const expectedAlg = this.authorization_signed_response_alg;\n        const { payload } = await this.validateJWT(response, expectedAlg, [\n            \"iss\",\n            \"exp\",\n            \"aud\"\n        ]);\n        return pickCb(payload);\n    }\n    /**\n   * @name dpopProof\n   * @api private\n   */ async dpopProof(payload, privateKeyInput, accessToken) {\n        if (!isPlainObject(payload)) {\n            throw new TypeError(\"payload must be a plain object\");\n        }\n        let privateKey;\n        if (isKeyObject(privateKeyInput)) {\n            privateKey = privateKeyInput;\n        } else {\n            privateKey = crypto.createPrivateKey(privateKeyInput);\n        }\n        if (privateKey.type !== \"private\") {\n            throw new TypeError('\"DPoP\" option must be a private key');\n        }\n        let alg;\n        switch(privateKey.asymmetricKeyType){\n            case \"ed25519\":\n            case \"ed448\":\n                alg = \"EdDSA\";\n                break;\n            case \"ec\":\n                alg = determineEcAlgorithm(privateKey, privateKeyInput);\n                break;\n            case \"rsa\":\n            case rsaPssParams && \"rsa-pss\":\n                alg = determineRsaAlgorithm(privateKey, privateKeyInput, this.issuer.dpop_signing_alg_values_supported);\n                break;\n            default:\n                throw new TypeError(\"unsupported DPoP private key asymmetric key type\");\n        }\n        if (!alg) {\n            throw new TypeError(\"could not determine DPoP JWS Algorithm\");\n        }\n        return new jose.SignJWT({\n            ath: accessToken ? base64url.encode(crypto.createHash(\"sha256\").update(accessToken).digest()) : undefined,\n            ...payload\n        }).setProtectedHeader({\n            alg,\n            typ: \"dpop+jwt\",\n            jwk: await getJwk(privateKey, privateKeyInput)\n        }).setIssuedAt().setJti(random()).sign(privateKey);\n    }\n}\nconst RSPS = /^(?:RS|PS)(?:256|384|512)$/;\nfunction determineRsaAlgorithm(privateKey, privateKeyInput, valuesSupported) {\n    if (typeof privateKeyInput === \"object\" && typeof privateKeyInput.key === \"object\" && privateKeyInput.key.alg) {\n        return privateKeyInput.key.alg;\n    }\n    if (Array.isArray(valuesSupported)) {\n        let candidates = valuesSupported.filter(RegExp.prototype.test.bind(RSPS));\n        if (privateKey.asymmetricKeyType === \"rsa-pss\") {\n            candidates = candidates.filter((value)=>value.startsWith(\"PS\"));\n        }\n        return [\n            \"PS256\",\n            \"PS384\",\n            \"PS512\",\n            \"RS256\",\n            \"RS384\",\n            \"RS384\"\n        ].find((preferred)=>candidates.includes(preferred));\n    }\n    return \"PS256\";\n}\nconst p256 = Buffer.from([\n    42,\n    134,\n    72,\n    206,\n    61,\n    3,\n    1,\n    7\n]);\nconst p384 = Buffer.from([\n    43,\n    129,\n    4,\n    0,\n    34\n]);\nconst p521 = Buffer.from([\n    43,\n    129,\n    4,\n    0,\n    35\n]);\nconst secp256k1 = Buffer.from([\n    43,\n    129,\n    4,\n    0,\n    10\n]);\nfunction determineEcAlgorithm(privateKey, privateKeyInput) {\n    // If input was a JWK\n    switch(typeof privateKeyInput === \"object\" && typeof privateKeyInput.key === \"object\" && privateKeyInput.key.crv){\n        case \"P-256\":\n            return \"ES256\";\n        case \"secp256k1\":\n            return \"ES256K\";\n        case \"P-384\":\n            return \"ES384\";\n        case \"P-512\":\n            return \"ES512\";\n        default:\n            break;\n    }\n    const buf = privateKey.export({\n        format: \"der\",\n        type: \"pkcs8\"\n    });\n    const i = buf[1] < 128 ? 17 : 18;\n    const len = buf[i];\n    const curveOid = buf.slice(i + 1, i + 1 + len);\n    if (curveOid.equals(p256)) {\n        return \"ES256\";\n    }\n    if (curveOid.equals(p384)) {\n        return \"ES384\";\n    }\n    if (curveOid.equals(p521)) {\n        return \"ES512\";\n    }\n    if (curveOid.equals(secp256k1)) {\n        return \"ES256K\";\n    }\n    throw new TypeError(\"unsupported DPoP private key curve\");\n}\nconst jwkCache = new WeakMap();\nasync function getJwk(privateKey, privateKeyInput) {\n    if (typeof privateKeyInput === \"object\" && typeof privateKeyInput.key === \"object\" && privateKeyInput.key.crv) {\n        return pick(privateKeyInput.key, \"kty\", \"crv\", \"x\", \"y\", \"e\", \"n\");\n    }\n    if (jwkCache.has(privateKeyInput)) {\n        return jwkCache.get(privateKeyInput);\n    }\n    const jwk = pick(await jose.exportJWK(privateKey), \"kty\", \"crv\", \"x\", \"y\", \"e\", \"n\");\n    if (isKeyObject(privateKeyInput)) {\n        jwkCache.set(privateKeyInput, jwk);\n    }\n    return jwk;\n}\nmodule.exports = (issuer, aadIssValidation = false)=>class Client extends BaseClient {\n        constructor(...args){\n            super(issuer, aadIssValidation, ...args);\n        }\n        static get issuer() {\n            return issuer;\n        }\n    };\nmodule.exports.BaseClient = BaseClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBRUEsT0FBTyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU1FLFNBQVNGLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUcsUUFBUUMsTUFBTSxFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBQ25DLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1NLE1BQU1OLG1CQUFPQSxDQUFDO0FBRXBCLE1BQU1PLE9BQU9QLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1RLFlBQVlSLG1CQUFPQSxDQUFDO0FBRTFCLE1BQU1TLGNBQWNULG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1VLFlBQVlWLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1XLFlBQVlYLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1ZLFdBQVdaLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU1hLHVCQUF1QmIsbUJBQU9BLENBQUM7QUFDckMsTUFBTSxFQUFFYyw2QkFBNkIsRUFBRUMseUJBQXlCLEVBQUUsR0FBR2YsbUJBQU9BLENBQUM7QUFDN0UsTUFBTWdCLE9BQU9oQixtQkFBT0EsQ0FBQztBQUNyQixNQUFNaUIsZ0JBQWdCakIsbUJBQU9BLENBQUM7QUFDOUIsTUFBTWtCLGtCQUFrQmxCLG1CQUFPQSxDQUFDO0FBQ2hDLE1BQU1tQixXQUFXbkIsbUJBQU9BLENBQUM7QUFDekIsTUFBTSxFQUFFb0IsT0FBTyxFQUFFQyxPQUFPLEVBQUUsR0FBR3JCLG1CQUFPQSxDQUFDO0FBQ3JDLE1BQU1zQixNQUFNdEIsbUJBQU9BLENBQUM7QUFDcEIsTUFBTSxFQUFFdUIsTUFBTSxFQUFFLEdBQUd2QixtQkFBT0EsQ0FBQztBQUMzQixNQUFNd0IsVUFBVXhCLG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU0sRUFBRXlCLGVBQWUsRUFBRSxH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WUFDbEIsT0FBT0E7UUFDVDtJQUNGO0FBQ0YwUyx5QkFBeUIsR0FBRzFSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hdXRoLXJlZ2lzdGVyLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2NsaWVudC5qcz9kNGZjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgaW5zcGVjdCB9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3Qgc3RkaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgeyBzdHJpY3Q6IGFzc2VydCB9ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5jb25zdCBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5jb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3Qgam9zZSA9IHJlcXVpcmUoJ2pvc2UnKTtcbmNvbnN0IHRva2VuSGFzaCA9IHJlcXVpcmUoJ29pZGMtdG9rZW4taGFzaCcpO1xuXG5jb25zdCBpc0tleU9iamVjdCA9IHJlcXVpcmUoJy4vaGVscGVycy9pc19rZXlfb2JqZWN0Jyk7XG5jb25zdCBkZWNvZGVKV1QgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGVjb2RlX2p3dCcpO1xuY29uc3QgYmFzZTY0dXJsID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Jhc2U2NHVybCcpO1xuY29uc3QgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGVmYXVsdHMnKTtcbmNvbnN0IHBhcnNlV3d3QXV0aGVudGljYXRlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3d3d19hdXRoZW50aWNhdGVfcGFyc2VyJyk7XG5jb25zdCB7IGFzc2VydFNpZ25pbmdBbGdWYWx1ZXNTdXBwb3J0LCBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvYXNzZXJ0Jyk7XG5jb25zdCBwaWNrID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BpY2snKTtcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNfcGxhaW5fb2JqZWN0Jyk7XG5jb25zdCBwcm9jZXNzUmVzcG9uc2UgPSByZXF1aXJlKCcuL2hlbHBlcnMvcHJvY2Vzc19yZXNwb25zZScpO1xuY29uc3QgVG9rZW5TZXQgPSByZXF1aXJlKCcuL3Rva2VuX3NldCcpO1xuY29uc3QgeyBPUEVycm9yLCBSUEVycm9yIH0gPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3Qgbm93ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3VuaXhfdGltZXN0YW1wJyk7XG5jb25zdCB7IHJhbmRvbSB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2dlbmVyYXRvcnMnKTtcbmNvbnN0IHJlcXVlc3QgPSByZXF1aXJlKCcuL2hlbHBlcnMvcmVxdWVzdCcpO1xuY29uc3QgeyBDTE9DS19UT0xFUkFOQ0UgfSA9IHJlcXVpcmUoJy4vaGVscGVycy9jb25zdHMnKTtcbmNvbnN0IHsga2V5c3RvcmVzIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvd2Vha19jYWNoZScpO1xuY29uc3QgS2V5U3RvcmUgPSByZXF1aXJlKCcuL2hlbHBlcnMva2V5c3RvcmUnKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2RlZXBfY2xvbmUnKTtcbmNvbnN0IHsgYXV0aGVudGljYXRlZFBvc3QsIHJlc29sdmVSZXNwb25zZVR5cGUsIHJlc29sdmVSZWRpcmVjdFVyaSB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2NsaWVudCcpO1xuY29uc3QgeyBxdWVyeUtleVN0b3JlIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNzdWVyJyk7XG5jb25zdCBEZXZpY2VGbG93SGFuZGxlID0gcmVxdWlyZSgnLi9kZXZpY2VfZmxvd19oYW5kbGUnKTtcblxuY29uc3QgW21ham9yLCBtaW5vcl0gPSBwcm9jZXNzLnZlcnNpb25cbiAgLnNsaWNlKDEpXG4gIC5zcGxpdCgnLicpXG4gIC5tYXAoKHN0cikgPT4gcGFyc2VJbnQoc3RyLCAxMCkpO1xuXG5jb25zdCByc2FQc3NQYXJhbXMgPSBtYWpvciA+PSAxNyB8fCAobWFqb3IgPT09IDE2ICYmIG1pbm9yID49IDkpO1xuY29uc3QgcmV0cnlBdHRlbXB0ID0gU3ltYm9sKCk7XG5jb25zdCBza2lwTm9uY2VDaGVjayA9IFN5bWJvbCgpO1xuY29uc3Qgc2tpcE1heEFnZUNoZWNrID0gU3ltYm9sKCk7XG5cbmZ1bmN0aW9uIHBpY2tDYihpbnB1dCkge1xuICByZXR1cm4gcGljayhcbiAgICBpbnB1dCxcbiAgICAnYWNjZXNzX3Rva2VuJywgLy8gT0F1dGggMi4wXG4gICAgJ2NvZGUnLCAvLyBPQXV0aCAyLjBcbiAgICAnZXJyb3JfZGVzY3JpcHRpb24nLCAvLyBPQXV0aCAyLjBcbiAgICAnZXJyb3JfdXJpJywgLy8gT0F1dGggMi4wXG4gICAgJ2Vycm9yJywgLy8gT0F1dGggMi4wXG4gICAgJ2V4cGlyZXNfaW4nLCAvLyBPQXV0aCAyLjBcbiAgICAnaWRfdG9rZW4nLCAvLyBPSURDIENvcmUgMS4wXG4gICAgJ2lzcycsIC8vIGRyYWZ0LWlldGYtb2F1dGgtaXNzLWF1dGgtcmVzcFxuICAgICdyZXNwb25zZScsIC8vIEZBUEkgSkFSTVxuICAgICdzZXNzaW9uX3N0YXRlJywgLy8gT0lEQyBTZXNzaW9uIE1hbmFnZW1lbnRcbiAgICAnc3RhdGUnLCAvLyBPQXV0aCAyLjBcbiAgICAndG9rZW5fdHlwZScsIC8vIE9BdXRoIDIuMFxuICApO1xufVxuXG5mdW5jdGlvbiBhdXRob3JpemF0aW9uSGVhZGVyVmFsdWUodG9rZW4sIHRva2VuVHlwZSA9ICdCZWFyZXInKSB7XG4gIHJldHVybiBgJHt0b2tlblR5cGV9ICR7dG9rZW59YDtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5UHJlc2VuY2UocGF5bG9hZCwgand0LCBwcm9wKSB7XG4gIGlmIChwYXlsb2FkW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgbWlzc2luZyByZXF1aXJlZCBKV1QgcHJvcGVydHkgJHtwcm9wfWAsXG4gICAgICBqd3QsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXV0aG9yaXphdGlvblBhcmFtcyhwYXJhbXMpIHtcbiAgY29uc3QgYXV0aFBhcmFtcyA9IHtcbiAgICBjbGllbnRfaWQ6IHRoaXMuY2xpZW50X2lkLFxuICAgIHNjb3BlOiAnb3BlbmlkJyxcbiAgICByZXNwb25zZV90eXBlOiByZXNvbHZlUmVzcG9uc2VUeXBlLmNhbGwodGhpcyksXG4gICAgcmVkaXJlY3RfdXJpOiByZXNvbHZlUmVkaXJlY3RVcmkuY2FsbCh0aGlzKSxcbiAgICAuLi5wYXJhbXMsXG4gIH07XG5cbiAgT2JqZWN0LmVudHJpZXMoYXV0aFBhcmFtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbGV0ZSBhdXRoUGFyYW1zW2tleV07XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdjbGFpbXMnICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGF1dGhQYXJhbXNba2V5XSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3Jlc291cmNlJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgYXV0aFBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBhdXRoUGFyYW1zW2tleV0gPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGF1dGhQYXJhbXM7XG59XG5cbmZ1bmN0aW9uIGdldEtleXN0b3JlKGp3a3MpIHtcbiAgaWYgKFxuICAgICFpc1BsYWluT2JqZWN0KGp3a3MpIHx8XG4gICAgIUFycmF5LmlzQXJyYXkoandrcy5rZXlzKSB8fFxuICAgIGp3a3Mua2V5cy5zb21lKChrKSA9PiAhaXNQbGFpbk9iamVjdChrKSB8fCAhKCdrdHknIGluIGspKVxuICApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdqd2tzIG11c3QgYmUgYSBKU09OIFdlYiBLZXkgU2V0IGZvcm1hdHRlZCBvYmplY3QnKTtcbiAgfVxuXG4gIHJldHVybiBLZXlTdG9yZS5mcm9tSldLUyhqd2tzLCB7IG9ubHlQcml2YXRlOiB0cnVlIH0pO1xufVxuXG4vLyBpZiBhbiBPUCBkb2VzbnQgc3VwcG9ydCBjbGllbnRfc2VjcmV0X2Jhc2ljIGJ1dCBzdXBwb3J0cyBjbGllbnRfc2VjcmV0X3Bvc3QsIHVzZSBpdCBpbnN0ZWFkXG4vLyB0aGlzIGlzIGluIHBsYWNlIHRvIHRha2UgY2FyZSBvZiBtb3N0IGNvbW1vbiBwaXRmYWxscyB3aGVuIGZpcnN0IHVzaW5nIGRpc2NvdmVyZWQgSXNzdWVycyB3aXRob3V0XG4vLyB0aGUgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMgZGVmaW5lZCBieSBEaXNjb3ZlcnkgMS4wXG5mdW5jdGlvbiBjaGVja0Jhc2ljU3VwcG9ydChjbGllbnQsIHByb3BlcnRpZXMpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdXBwb3J0ZWQgPSBjbGllbnQuaXNzdWVyLnRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kc19zdXBwb3J0ZWQ7XG4gICAgaWYgKCFzdXBwb3J0ZWQuaW5jbHVkZXMocHJvcGVydGllcy50b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZCkpIHtcbiAgICAgIGlmIChzdXBwb3J0ZWQuaW5jbHVkZXMoJ2NsaWVudF9zZWNyZXRfcG9zdCcpKSB7XG4gICAgICAgIHByb3BlcnRpZXMudG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QgPSAnY2xpZW50X3NlY3JldF9wb3N0JztcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge31cbn1cblxuZnVuY3Rpb24gaGFuZGxlQ29tbW9uTWlzdGFrZXMoY2xpZW50LCBtZXRhZGF0YSwgcHJvcGVydGllcykge1xuICBpZiAoIW1ldGFkYXRhLnRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kKSB7XG4gICAgLy8gaWYgbm8gZXhwbGljaXQgdmFsdWUgd2FzIHByb3ZpZGVkXG4gICAgY2hlY2tCYXNpY1N1cHBvcnQoY2xpZW50LCBwcm9wZXJ0aWVzKTtcbiAgfVxuXG4gIC8vIDpmcDogYydtb24gcGVvcGxlLi4uIFJURk1cbiAgaWYgKG1ldGFkYXRhLnJlZGlyZWN0X3VyaSkge1xuICAgIGlmIChtZXRhZGF0YS5yZWRpcmVjdF91cmlzKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm92aWRlIGEgcmVkaXJlY3RfdXJpIG9yIHJlZGlyZWN0X3VyaXMsIG5vdCBib3RoJyk7XG4gICAgfVxuICAgIHByb3BlcnRpZXMucmVkaXJlY3RfdXJpcyA9IFttZXRhZGF0YS5yZWRpcmVjdF91cmldO1xuICAgIGRlbGV0ZSBwcm9wZXJ0aWVzLnJlZGlyZWN0X3VyaTtcbiAgfVxuXG4gIGlmIChtZXRhZGF0YS5yZXNwb25zZV90eXBlKSB7XG4gICAgaWYgKG1ldGFkYXRhLnJlc3BvbnNlX3R5cGVzKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm92aWRlIGEgcmVzcG9uc2VfdHlwZSBvciByZXNwb25zZV90eXBlcywgbm90IGJvdGgnKTtcbiAgICB9XG4gICAgcHJvcGVydGllcy5yZXNwb25zZV90eXBlcyA9IFttZXRhZGF0YS5yZXNwb25zZV90eXBlXTtcbiAgICBkZWxldGUgcHJvcGVydGllcy5yZXNwb25zZV90eXBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRzRm9yRW5kcG9pbnQoZW5kcG9pbnQsIGlzc3VlciwgcHJvcGVydGllcykge1xuICBpZiAoIWlzc3VlcltgJHtlbmRwb2ludH1fZW5kcG9pbnRgXSkgcmV0dXJuO1xuXG4gIGNvbnN0IHRva2VuRW5kcG9pbnRBdXRoTWV0aG9kID0gcHJvcGVydGllcy50b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZDtcbiAgY29uc3QgdG9rZW5FbmRwb2ludEF1dGhTaWduaW5nQWxnID0gcHJvcGVydGllcy50b2tlbl9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnO1xuXG4gIGNvbnN0IGVhbSA9IGAke2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX21ldGhvZGA7XG4gIGNvbnN0IGVhc2EgPSBgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9zaWduaW5nX2FsZ2A7XG5cbiAgaWYgKHByb3BlcnRpZXNbZWFtXSA9PT0gdW5kZWZpbmVkICYmIHByb3BlcnRpZXNbZWFzYV0gPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0b2tlbkVuZHBvaW50QXV0aE1ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcm9wZXJ0aWVzW2VhbV0gPSB0b2tlbkVuZHBvaW50QXV0aE1ldGhvZDtcbiAgICB9XG4gICAgaWYgKHRva2VuRW5kcG9pbnRBdXRoU2lnbmluZ0FsZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcm9wZXJ0aWVzW2Vhc2FdID0gdG9rZW5FbmRwb2ludEF1dGhTaWduaW5nQWxnO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBCYXNlQ2xpZW50IHtcbiAgI21ldGFkYXRhO1xuICAjaXNzdWVyO1xuICAjYWFkSXNzVmFsaWRhdGlvbjtcbiAgI2FkZGl0aW9uYWxBdXRob3JpemVkUGFydGllcztcbiAgY29uc3RydWN0b3IoaXNzdWVyLCBhYWRJc3NWYWxpZGF0aW9uLCBtZXRhZGF0YSA9IHt9LCBqd2tzLCBvcHRpb25zKSB7XG4gICAgdGhpcy4jbWV0YWRhdGEgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy4jaXNzdWVyID0gaXNzdWVyO1xuICAgIHRoaXMuI2FhZElzc1ZhbGlkYXRpb24gPSBhYWRJc3NWYWxpZGF0aW9uO1xuXG4gICAgaWYgKHR5cGVvZiBtZXRhZGF0YS5jbGllbnRfaWQgIT09ICdzdHJpbmcnIHx8ICFtZXRhZGF0YS5jbGllbnRfaWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NsaWVudF9pZCBpcyByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICBncmFudF90eXBlczogWydhdXRob3JpemF0aW9uX2NvZGUnXSxcbiAgICAgIGlkX3Rva2VuX3NpZ25lZF9yZXNwb25zZV9hbGc6ICdSUzI1NicsXG4gICAgICBhdXRob3JpemF0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGc6ICdSUzI1NicsXG4gICAgICByZXNwb25zZV90eXBlczogWydjb2RlJ10sXG4gICAgICB0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZDogJ2NsaWVudF9zZWNyZXRfYmFzaWMnLFxuICAgICAgLi4uKHRoaXMuZmFwaSgpXG4gICAgICAgID8ge1xuICAgICAgICAgICAgZ3JhbnRfdHlwZXM6IFsnYXV0aG9yaXphdGlvbl9jb2RlJywgJ2ltcGxpY2l0J10sXG4gICAgICAgICAgICBpZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnOiAnUFMyNTYnLFxuICAgICAgICAgICAgYXV0aG9yaXphdGlvbl9zaWduZWRfcmVzcG9uc2VfYWxnOiAnUFMyNTYnLFxuICAgICAgICAgICAgcmVzcG9uc2VfdHlwZXM6IFsnY29kZSBpZF90b2tlbiddLFxuICAgICAgICAgICAgdGxzX2NsaWVudF9jZXJ0aWZpY2F0ZV9ib3VuZF9hY2Nlc3NfdG9rZW5zOiB0cnVlLFxuICAgICAgICAgICAgdG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkKSxcbiAgICAgIC4uLm1ldGFkYXRhLFxuICAgIH07XG5cbiAgICBpZiAodGhpcy5mYXBpKCkpIHtcbiAgICAgIHN3aXRjaCAocHJvcGVydGllcy50b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZCkge1xuICAgICAgICBjYXNlICdzZWxmX3NpZ25lZF90bHNfY2xpZW50X2F1dGgnOlxuICAgICAgICBjYXNlICd0bHNfY2xpZW50X2F1dGgnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwcml2YXRlX2tleV9qd3QnOlxuICAgICAgICAgIGlmICghandrcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignandrcyBpcyByZXF1aXJlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIHRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlQ29tbW9uTWlzdGFrZXModGhpcywgbWV0YWRhdGEsIHByb3BlcnRpZXMpO1xuXG4gICAgYXNzZXJ0U2lnbmluZ0FsZ1ZhbHVlc1N1cHBvcnQoJ3Rva2VuJywgdGhpcy5pc3N1ZXIsIHByb3BlcnRpZXMpO1xuICAgIFsnaW50cm9zcGVjdGlvbicsICdyZXZvY2F0aW9uJ10uZm9yRWFjaCgoZW5kcG9pbnQpID0+IHtcbiAgICAgIGdldERlZmF1bHRzRm9yRW5kcG9pbnQoZW5kcG9pbnQsIHRoaXMuaXNzdWVyLCBwcm9wZXJ0aWVzKTtcbiAgICAgIGFzc2VydFNpZ25pbmdBbGdWYWx1ZXNTdXBwb3J0KGVuZHBvaW50LCB0aGlzLmlzc3VlciwgcHJvcGVydGllcyk7XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZW50cmllcyhwcm9wZXJ0aWVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIHRoaXMuI21ldGFkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgIGlmICghdGhpc1trZXldKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jbWV0YWRhdGEuZ2V0KGtleSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChqd2tzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGtleXN0b3JlID0gZ2V0S2V5c3RvcmUuY2FsbCh0aGlzLCBqd2tzKTtcbiAgICAgIGtleXN0b3Jlcy5zZXQodGhpcywga2V5c3RvcmUpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5hZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXMpIHtcbiAgICAgIHRoaXMuI2FkZGl0aW9uYWxBdXRob3JpemVkUGFydGllcyA9IGNsb25lKG9wdGlvbnMuYWRkaXRpb25hbEF1dGhvcml6ZWRQYXJ0aWVzKTtcbiAgICB9XG5cbiAgICB0aGlzW0NMT0NLX1RPTEVSQU5DRV0gPSAwO1xuICB9XG5cbiAgYXV0aG9yaXphdGlvblVybChwYXJhbXMgPSB7fSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChwYXJhbXMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbXMgbXVzdCBiZSBhIHBsYWluIG9iamVjdCcpO1xuICAgIH1cbiAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKHRoaXMuaXNzdWVyLCAnYXV0aG9yaXphdGlvbl9lbmRwb2ludCcpO1xuICAgIGNvbnN0IHRhcmdldCA9IHVybC5wYXJzZSh0aGlzLmlzc3Vlci5hdXRob3JpemF0aW9uX2VuZHBvaW50LCB0cnVlKTtcbiAgICB0YXJnZXQuc2VhcmNoID0gbnVsbDtcbiAgICB0YXJnZXQucXVlcnkgPSB7XG4gICAgICAuLi50YXJnZXQucXVlcnksXG4gICAgICAuLi5hdXRob3JpemF0aW9uUGFyYW1zLmNhbGwodGhpcywgcGFyYW1zKSxcbiAgICB9O1xuICAgIHJldHVybiB1cmwuZm9ybWF0KHRhcmdldCk7XG4gIH1cblxuICBhdXRob3JpemF0aW9uUG9zdChwYXJhbXMgPSB7fSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChwYXJhbXMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbXMgbXVzdCBiZSBhIHBsYWluIG9iamVjdCcpO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dHMgPSBhdXRob3JpemF0aW9uUGFyYW1zLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICBjb25zdCBmb3JtSW5wdXRzID0gT2JqZWN0LmtleXMoaW5wdXRzKVxuICAgICAgLm1hcCgobmFtZSkgPT4gYDxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cIiR7bmFtZX1cIiB2YWx1ZT1cIiR7aW5wdXRzW25hbWVdfVwiLz5gKVxuICAgICAgLmpvaW4oJ1xcbicpO1xuXG4gICAgcmV0dXJuIGA8IURPQ1RZUEUgaHRtbD5cbjxoZWFkPlxuPHRpdGxlPlJlcXVlc3RpbmcgQXV0aG9yaXphdGlvbjwvdGl0bGU+XG48L2hlYWQ+XG48Ym9keSBvbmxvYWQ9XCJqYXZhc2NyaXB0OmRvY3VtZW50LmZvcm1zWzBdLnN1Ym1pdCgpXCI+XG48Zm9ybSBtZXRob2Q9XCJwb3N0XCIgYWN0aW9uPVwiJHt0aGlzLmlzc3Vlci5hdXRob3JpemF0aW9uX2VuZHBvaW50fVwiPlxuICAke2Zvcm1JbnB1dHN9XG48L2Zvcm0+XG48L2JvZHk+XG48L2h0bWw+YDtcbiAgfVxuXG4gIGVuZFNlc3Npb25VcmwocGFyYW1zID0ge30pIHtcbiAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKHRoaXMuaXNzdWVyLCAnZW5kX3Nlc3Npb25fZW5kcG9pbnQnKTtcblxuICAgIGNvbnN0IHsgMDogcG9zdExvZ291dCwgbGVuZ3RoIH0gPSB0aGlzLnBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaXMgfHwgW107XG5cbiAgICBjb25zdCB7IHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSA9IGxlbmd0aCA9PT0gMSA/IHBvc3RMb2dvdXQgOiB1bmRlZmluZWQgfSA9IHBhcmFtcztcblxuICAgIGxldCBpZF90b2tlbl9oaW50O1xuICAgICh7IGlkX3Rva2VuX2hpbnQsIC4uLnBhcmFtcyB9ID0gcGFyYW1zKTtcbiAgICBpZiAoaWRfdG9rZW5faGludCBpbnN0YW5jZW9mIFRva2VuU2V0KSB7XG4gICAgICBpZiAoIWlkX3Rva2VuX2hpbnQuaWRfdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaWRfdG9rZW4gbm90IHByZXNlbnQgaW4gVG9rZW5TZXQnKTtcbiAgICAgIH1cbiAgICAgIGlkX3Rva2VuX2hpbnQgPSBpZF90b2tlbl9oaW50LmlkX3Rva2VuO1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IHVybC5wYXJzZSh0aGlzLmlzc3Vlci5lbmRfc2Vzc2lvbl9lbmRwb2ludCwgdHJ1ZSk7XG4gICAgdGFyZ2V0LnNlYXJjaCA9IG51bGw7XG4gICAgZGVmYXVsdHMoXG4gICAgICB0YXJnZXQucXVlcnksXG4gICAgICBwYXJhbXMsXG4gICAgICB7XG4gICAgICAgIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSxcbiAgICAgICAgY2xpZW50X2lkOiB0aGlzLmNsaWVudF9pZCxcbiAgICAgIH0sXG4gICAgICB7IGlkX3Rva2VuX2hpbnQgfSxcbiAgICApO1xuXG4gICAgT2JqZWN0LmVudHJpZXModGFyZ2V0LnF1ZXJ5KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGV0ZSB0YXJnZXQucXVlcnlba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB1cmwuZm9ybWF0KHRhcmdldCk7XG4gIH1cblxuICBjYWxsYmFja1BhcmFtcyhpbnB1dCkge1xuICAgIGNvbnN0IGlzSW5jb21pbmdNZXNzYWdlID1cbiAgICAgIGlucHV0IGluc3RhbmNlb2Ygc3RkaHR0cC5JbmNvbWluZ01lc3NhZ2UgfHwgKGlucHV0ICYmIGlucHV0Lm1ldGhvZCAmJiBpbnB1dC51cmwpO1xuICAgIGNvbnN0IGlzU3RyaW5nID0gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJztcblxuICAgIGlmICghaXNTdHJpbmcgJiYgIWlzSW5jb21pbmdNZXNzYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnI2NhbGxiYWNrUGFyYW1zIG9ubHkgYWNjZXB0cyBzdHJpbmcgdXJscywgaHR0cC5JbmNvbWluZ01lc3NhZ2Ugb3IgYSBsb29rYWxpa2UnLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGlzSW5jb21pbmdNZXNzYWdlKSB7XG4gICAgICBzd2l0Y2ggKGlucHV0Lm1ldGhvZCkge1xuICAgICAgICBjYXNlICdHRVQnOlxuICAgICAgICAgIHJldHVybiBwaWNrQ2IodXJsLnBhcnNlKGlucHV0LnVybCwgdHJ1ZSkucXVlcnkpO1xuICAgICAgICBjYXNlICdQT1NUJzpcbiAgICAgICAgICBpZiAoaW5wdXQuYm9keSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAnaW5jb21pbmcgbWVzc2FnZSBib2R5IG1pc3NpbmcsIGluY2x1ZGUgYSBib2R5IHBhcnNlciBwcmlvciB0byB0aGlzIG1ldGhvZCBjYWxsJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGlucHV0LmJvZHkpIHtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGlucHV0LmJvZHkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpY2tDYihxdWVyeXN0cmluZy5wYXJzZShpbnB1dC5ib2R5LnRvU3RyaW5nKCd1dGYtOCcpKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5ib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwaWNrQ2IocXVlcnlzdHJpbmcucGFyc2UoaW5wdXQuYm9keSkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHBpY2tDYihpbnB1dC5ib2R5KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgSW5jb21pbmdNZXNzYWdlIGJvZHkgb2JqZWN0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgSW5jb21pbmdNZXNzYWdlIG1ldGhvZCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGlja0NiKHVybC5wYXJzZShpbnB1dCwgdHJ1ZSkucXVlcnkpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNhbGxiYWNrKFxuICAgIHJlZGlyZWN0VXJpLFxuICAgIHBhcmFtZXRlcnMsXG4gICAgY2hlY2tzID0ge30sXG4gICAgeyBleGNoYW5nZUJvZHksIGNsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1AgfSA9IHt9LFxuICApIHtcbiAgICBsZXQgcGFyYW1zID0gcGlja0NiKHBhcmFtZXRlcnMpO1xuXG4gICAgaWYgKGNoZWNrcy5qYXJtICYmICEoJ3Jlc3BvbnNlJyBpbiBwYXJhbWV0ZXJzKSkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnZXhwZWN0ZWQgYSBKQVJNIHJlc3BvbnNlJyxcbiAgICAgICAgY2hlY2tzLFxuICAgICAgICBwYXJhbXMsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCdyZXNwb25zZScgaW4gcGFyYW1ldGVycykge1xuICAgICAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgdGhpcy5kZWNyeXB0SkFSTShwYXJhbXMucmVzcG9uc2UpO1xuICAgICAgcGFyYW1zID0gYXdhaXQgdGhpcy52YWxpZGF0ZUpBUk0oZGVjcnlwdGVkKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kZWZhdWx0X21heF9hZ2UgJiYgIWNoZWNrcy5tYXhfYWdlKSB7XG4gICAgICBjaGVja3MubWF4X2FnZSA9IHRoaXMuZGVmYXVsdF9tYXhfYWdlO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuc3RhdGUgJiYgIWNoZWNrcy5zdGF0ZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2hlY2tzLnN0YXRlIGFyZ3VtZW50IGlzIG1pc3NpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5zdGF0ZSAmJiBjaGVja3Muc3RhdGUpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogJ3N0YXRlIG1pc3NpbmcgZnJvbSB0aGUgcmVzcG9uc2UnLFxuICAgICAgICBjaGVja3MsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjaGVja3Muc3RhdGUgIT09IHBhcmFtcy5zdGF0ZSkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBwcmludGY6IFsnc3RhdGUgbWlzbWF0Y2gsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJywgY2hlY2tzLnN0YXRlLCBwYXJhbXMuc3RhdGVdLFxuICAgICAgICBjaGVja3MsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICgnaXNzJyBpbiBwYXJhbXMpIHtcbiAgICAgIGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24odGhpcy5pc3N1ZXIsICdpc3N1ZXInKTtcbiAgICAgIGlmIChwYXJhbXMuaXNzICE9PSB0aGlzLmlzc3Vlci5pc3N1ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIHByaW50ZjogWydpc3MgbWlzbWF0Y2gsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJywgdGhpcy5pc3N1ZXIuaXNzdWVyLCBwYXJhbXMuaXNzXSxcbiAgICAgICAgICBwYXJhbXMsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLmlzc3Vlci5hdXRob3JpemF0aW9uX3Jlc3BvbnNlX2lzc19wYXJhbWV0ZXJfc3VwcG9ydGVkICYmXG4gICAgICAhKCdpZF90b2tlbicgaW4gcGFyYW1zKSAmJlxuICAgICAgISgncmVzcG9uc2UnIGluIHBhcmFtZXRlcnMpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6ICdpc3MgbWlzc2luZyBmcm9tIHRoZSByZXNwb25zZScsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBPUEVycm9yKHBhcmFtcyk7XG4gICAgfVxuXG4gICAgY29uc3QgUkVTUE9OU0VfVFlQRV9SRVFVSVJFRF9QQVJBTVMgPSB7XG4gICAgICBjb2RlOiBbJ2NvZGUnXSxcbiAgICAgIGlkX3Rva2VuOiBbJ2lkX3Rva2VuJ10sXG4gICAgICB0b2tlbjogWydhY2Nlc3NfdG9rZW4nLCAndG9rZW5fdHlwZSddLFxuICAgIH07XG5cbiAgICBpZiAoY2hlY2tzLnJlc3BvbnNlX3R5cGUpIHtcbiAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBjaGVja3MucmVzcG9uc2VfdHlwZS5zcGxpdCgnICcpKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnbm9uZScpIHtcbiAgICAgICAgICBpZiAocGFyYW1zLmNvZGUgfHwgcGFyYW1zLmlkX3Rva2VuIHx8IHBhcmFtcy5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ3VuZXhwZWN0ZWQgcGFyYW1zIGVuY291bnRlcmVkIGZvciBcIm5vbmVcIiByZXNwb25zZScsXG4gICAgICAgICAgICAgIGNoZWNrcyxcbiAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgcGFyYW0gb2YgUkVTUE9OU0VfVFlQRV9SRVFVSVJFRF9QQVJBTVNbdHlwZV0pIHtcbiAgICAgICAgICAgIGlmICghcGFyYW1zW3BhcmFtXSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYCR7cGFyYW19IG1pc3NpbmcgZnJvbSByZXNwb25zZWAsXG4gICAgICAgICAgICAgICAgY2hlY2tzLFxuICAgICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5pZF90b2tlbikge1xuICAgICAgY29uc3QgdG9rZW5zZXQgPSBuZXcgVG9rZW5TZXQocGFyYW1zKTtcbiAgICAgIGF3YWl0IHRoaXMuZGVjcnlwdElkVG9rZW4odG9rZW5zZXQpO1xuICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUlkVG9rZW4oXG4gICAgICAgIHRva2Vuc2V0LFxuICAgICAgICBjaGVja3Mubm9uY2UsXG4gICAgICAgICdhdXRob3JpemF0aW9uJyxcbiAgICAgICAgY2hlY2tzLm1heF9hZ2UsXG4gICAgICAgIGNoZWNrcy5zdGF0ZSxcbiAgICAgICk7XG5cbiAgICAgIGlmICghcGFyYW1zLmNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHRva2Vuc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXJhbXMuY29kZSkge1xuICAgICAgY29uc3QgdG9rZW5zZXQgPSBhd2FpdCB0aGlzLmdyYW50KFxuICAgICAgICB7XG4gICAgICAgICAgLi4uZXhjaGFuZ2VCb2R5LFxuICAgICAgICAgIGdyYW50X3R5cGU6ICdhdXRob3JpemF0aW9uX2NvZGUnLFxuICAgICAgICAgIGNvZGU6IHBhcmFtcy5jb2RlLFxuICAgICAgICAgIHJlZGlyZWN0X3VyaTogcmVkaXJlY3RVcmksXG4gICAgICAgICAgY29kZV92ZXJpZmllcjogY2hlY2tzLmNvZGVfdmVyaWZpZXIsXG4gICAgICAgIH0sXG4gICAgICAgIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCwgRFBvUCB9LFxuICAgICAgKTtcblxuICAgICAgYXdhaXQgdGhpcy5kZWNyeXB0SWRUb2tlbih0b2tlbnNldCk7XG4gICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlSWRUb2tlbih0b2tlbnNldCwgY2hlY2tzLm5vbmNlLCAndG9rZW4nLCBjaGVja3MubWF4X2FnZSk7XG5cbiAgICAgIGlmIChwYXJhbXMuc2Vzc2lvbl9zdGF0ZSkge1xuICAgICAgICB0b2tlbnNldC5zZXNzaW9uX3N0YXRlID0gcGFyYW1zLnNlc3Npb25fc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b2tlbnNldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRva2VuU2V0KHBhcmFtcyk7XG4gIH1cblxuICBhc3luYyBvYXV0aENhbGxiYWNrKFxuICAgIHJlZGlyZWN0VXJpLFxuICAgIHBhcmFtZXRlcnMsXG4gICAgY2hlY2tzID0ge30sXG4gICAgeyBleGNoYW5nZUJvZHksIGNsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1AgfSA9IHt9LFxuICApIHtcbiAgICBsZXQgcGFyYW1zID0gcGlja0NiKHBhcmFtZXRlcnMpO1xuXG4gICAgaWYgKGNoZWNrcy5qYXJtICYmICEoJ3Jlc3BvbnNlJyBpbiBwYXJhbWV0ZXJzKSkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnZXhwZWN0ZWQgYSBKQVJNIHJlc3BvbnNlJyxcbiAgICAgICAgY2hlY2tzLFxuICAgICAgICBwYXJhbXMsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCdyZXNwb25zZScgaW4gcGFyYW1ldGVycykge1xuICAgICAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgdGhpcy5kZWNyeXB0SkFSTShwYXJhbXMucmVzcG9uc2UpO1xuICAgICAgcGFyYW1zID0gYXdhaXQgdGhpcy52YWxpZGF0ZUpBUk0oZGVjcnlwdGVkKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLnN0YXRlICYmICFjaGVja3Muc3RhdGUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NoZWNrcy5zdGF0ZSBhcmd1bWVudCBpcyBtaXNzaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMuc3RhdGUgJiYgY2hlY2tzLnN0YXRlKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6ICdzdGF0ZSBtaXNzaW5nIGZyb20gdGhlIHJlc3BvbnNlJyxcbiAgICAgICAgY2hlY2tzLFxuICAgICAgICBwYXJhbXMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLnN0YXRlICE9PSBwYXJhbXMuc3RhdGUpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgcHJpbnRmOiBbJ3N0YXRlIG1pc21hdGNoLCBleHBlY3RlZCAlcywgZ290OiAlcycsIGNoZWNrcy5zdGF0ZSwgcGFyYW1zLnN0YXRlXSxcbiAgICAgICAgY2hlY2tzLFxuICAgICAgICBwYXJhbXMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoJ2lzcycgaW4gcGFyYW1zKSB7XG4gICAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKHRoaXMuaXNzdWVyLCAnaXNzdWVyJyk7XG4gICAgICBpZiAocGFyYW1zLmlzcyAhPT0gdGhpcy5pc3N1ZXIuaXNzdWVyKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBwcmludGY6IFsnaXNzIG1pc21hdGNoLCBleHBlY3RlZCAlcywgZ290OiAlcycsIHRoaXMuaXNzdWVyLmlzc3VlciwgcGFyYW1zLmlzc10sXG4gICAgICAgICAgcGFyYW1zLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdGhpcy5pc3N1ZXIuYXV0aG9yaXphdGlvbl9yZXNwb25zZV9pc3NfcGFyYW1ldGVyX3N1cHBvcnRlZCAmJlxuICAgICAgISgnaWRfdG9rZW4nIGluIHBhcmFtcykgJiZcbiAgICAgICEoJ3Jlc3BvbnNlJyBpbiBwYXJhbWV0ZXJzKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnaXNzIG1pc3NpbmcgZnJvbSB0aGUgcmVzcG9uc2UnLFxuICAgICAgICBwYXJhbXMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgT1BFcnJvcihwYXJhbXMpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGFyYW1zLmlkX3Rva2VuID09PSAnc3RyaW5nJyAmJiBwYXJhbXMuaWRfdG9rZW4ubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgJ2lkX3Rva2VuIGRldGVjdGVkIGluIHRoZSByZXNwb25zZSwgeW91IG11c3QgdXNlIGNsaWVudC5jYWxsYmFjaygpIGluc3RlYWQgb2YgY2xpZW50Lm9hdXRoQ2FsbGJhY2soKScsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBkZWxldGUgcGFyYW1zLmlkX3Rva2VuO1xuXG4gICAgY29uc3QgUkVTUE9OU0VfVFlQRV9SRVFVSVJFRF9QQVJBTVMgPSB7XG4gICAgICBjb2RlOiBbJ2NvZGUnXSxcbiAgICAgIHRva2VuOiBbJ2FjY2Vzc190b2tlbicsICd0b2tlbl90eXBlJ10sXG4gICAgfTtcblxuICAgIGlmIChjaGVja3MucmVzcG9uc2VfdHlwZSkge1xuICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGNoZWNrcy5yZXNwb25zZV90eXBlLnNwbGl0KCcgJykpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdub25lJykge1xuICAgICAgICAgIGlmIChwYXJhbXMuY29kZSB8fCBwYXJhbXMuaWRfdG9rZW4gfHwgcGFyYW1zLmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgICAgICBtZXNzYWdlOiAndW5leHBlY3RlZCBwYXJhbXMgZW5jb3VudGVyZWQgZm9yIFwibm9uZVwiIHJlc3BvbnNlJyxcbiAgICAgICAgICAgICAgY2hlY2tzLFxuICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUkVTUE9OU0VfVFlQRV9SRVFVSVJFRF9QQVJBTVNbdHlwZV0pIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIFJFU1BPTlNFX1RZUEVfUkVRVUlSRURfUEFSQU1TW3R5cGVdKSB7XG4gICAgICAgICAgICBpZiAoIXBhcmFtc1twYXJhbV0pIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAke3BhcmFtfSBtaXNzaW5nIGZyb20gcmVzcG9uc2VgLFxuICAgICAgICAgICAgICAgIGNoZWNrcyxcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXJhbXMuY29kZSkge1xuICAgICAgY29uc3QgdG9rZW5zZXQgPSBhd2FpdCB0aGlzLmdyYW50KFxuICAgICAgICB7XG4gICAgICAgICAgLi4uZXhjaGFuZ2VCb2R5LFxuICAgICAgICAgIGdyYW50X3R5cGU6ICdhdXRob3JpemF0aW9uX2NvZGUnLFxuICAgICAgICAgIGNvZGU6IHBhcmFtcy5jb2RlLFxuICAgICAgICAgIHJlZGlyZWN0X3VyaTogcmVkaXJlY3RVcmksXG4gICAgICAgICAgY29kZV92ZXJpZmllcjogY2hlY2tzLmNvZGVfdmVyaWZpZXIsXG4gICAgICAgIH0sXG4gICAgICAgIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCwgRFBvUCB9LFxuICAgICAgKTtcblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbnNldC5pZF90b2tlbiA9PT0gJ3N0cmluZycgJiYgdG9rZW5zZXQuaWRfdG9rZW4ubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgJ2lkX3Rva2VuIGRldGVjdGVkIGluIHRoZSByZXNwb25zZSwgeW91IG11c3QgdXNlIGNsaWVudC5jYWxsYmFjaygpIGluc3RlYWQgb2YgY2xpZW50Lm9hdXRoQ2FsbGJhY2soKScsXG4gICAgICAgICAgcGFyYW1zLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0b2tlbnNldC5pZF90b2tlbjtcblxuICAgICAgcmV0dXJuIHRva2Vuc2V0O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVG9rZW5TZXQocGFyYW1zKTtcbiAgfVxuXG4gIGFzeW5jIGRlY3J5cHRJZFRva2VuKHRva2VuKSB7XG4gICAgaWYgKCF0aGlzLmlkX3Rva2VuX2VuY3J5cHRlZF9yZXNwb25zZV9hbGcpIHtcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG5cbiAgICBsZXQgaWRUb2tlbiA9IHRva2VuO1xuXG4gICAgaWYgKGlkVG9rZW4gaW5zdGFuY2VvZiBUb2tlblNldCkge1xuICAgICAgaWYgKCFpZFRva2VuLmlkX3Rva2VuKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lkX3Rva2VuIG5vdCBwcmVzZW50IGluIFRva2VuU2V0Jyk7XG4gICAgICB9XG4gICAgICBpZFRva2VuID0gaWRUb2tlbi5pZF90b2tlbjtcbiAgICB9XG5cbiAgICBjb25zdCBleHBlY3RlZEFsZyA9IHRoaXMuaWRfdG9rZW5fZW5jcnlwdGVkX3Jlc3BvbnNlX2FsZztcbiAgICBjb25zdCBleHBlY3RlZEVuYyA9IHRoaXMuaWRfdG9rZW5fZW5jcnlwdGVkX3Jlc3BvbnNlX2VuYztcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZGVjcnlwdEpXRShpZFRva2VuLCBleHBlY3RlZEFsZywgZXhwZWN0ZWRFbmMpO1xuXG4gICAgaWYgKHRva2VuIGluc3RhbmNlb2YgVG9rZW5TZXQpIHtcbiAgICAgIHRva2VuLmlkX3Rva2VuID0gcmVzdWx0O1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZUpXVFVzZXJpbmZvKGJvZHkpIHtcbiAgICBjb25zdCBleHBlY3RlZEFsZyA9IHRoaXMudXNlcmluZm9fc2lnbmVkX3Jlc3BvbnNlX2FsZztcblxuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlSldUKGJvZHksIGV4cGVjdGVkQWxnLCBbXSk7XG4gIH1cblxuICBhc3luYyBkZWNyeXB0SkFSTShyZXNwb25zZSkge1xuICAgIGlmICghdGhpcy5hdXRob3JpemF0aW9uX2VuY3J5cHRlZF9yZXNwb25zZV9hbGcpIHtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICBjb25zdCBleHBlY3RlZEFsZyA9IHRoaXMuYXV0aG9yaXphdGlvbl9lbmNyeXB0ZWRfcmVzcG9uc2VfYWxnO1xuICAgIGNvbnN0IGV4cGVjdGVkRW5jID0gdGhpcy5hdXRob3JpemF0aW9uX2VuY3J5cHRlZF9yZXNwb25zZV9lbmM7XG5cbiAgICByZXR1cm4gdGhpcy5kZWNyeXB0SldFKHJlc3BvbnNlLCBleHBlY3RlZEFsZywgZXhwZWN0ZWRFbmMpO1xuICB9XG5cbiAgYXN5bmMgZGVjcnlwdEpXVFVzZXJpbmZvKGJvZHkpIHtcbiAgICBpZiAoIXRoaXMudXNlcmluZm9fZW5jcnlwdGVkX3Jlc3BvbnNlX2FsZykge1xuICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfVxuXG4gICAgY29uc3QgZXhwZWN0ZWRBbGcgPSB0aGlzLnVzZXJpbmZvX2VuY3J5cHRlZF9yZXNwb25zZV9hbGc7XG4gICAgY29uc3QgZXhwZWN0ZWRFbmMgPSB0aGlzLnVzZXJpbmZvX2VuY3J5cHRlZF9yZXNwb25zZV9lbmM7XG5cbiAgICByZXR1cm4gdGhpcy5kZWNyeXB0SldFKGJvZHksIGV4cGVjdGVkQWxnLCBleHBlY3RlZEVuYyk7XG4gIH1cblxuICBhc3luYyBkZWNyeXB0SldFKGp3ZSwgZXhwZWN0ZWRBbGcsIGV4cGVjdGVkRW5jID0gJ0ExMjhDQkMtSFMyNTYnKSB7XG4gICAgY29uc3QgaGVhZGVyID0gSlNPTi5wYXJzZShiYXNlNjR1cmwuZGVjb2RlKGp3ZS5zcGxpdCgnLicpWzBdKSk7XG5cbiAgICBpZiAoaGVhZGVyLmFsZyAhPT0gZXhwZWN0ZWRBbGcpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgcHJpbnRmOiBbJ3VuZXhwZWN0ZWQgSldFIGFsZyByZWNlaXZlZCwgZXhwZWN0ZWQgJXMsIGdvdDogJXMnLCBleHBlY3RlZEFsZywgaGVhZGVyLmFsZ10sXG4gICAgICAgIGp3dDogandlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGhlYWRlci5lbmMgIT09IGV4cGVjdGVkRW5jKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIHByaW50ZjogWyd1bmV4cGVjdGVkIEpXRSBlbmMgcmVjZWl2ZWQsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJywgZXhwZWN0ZWRFbmMsIGhlYWRlci5lbmNdLFxuICAgICAgICBqd3Q6IGp3ZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGdldFBsYWludGV4dCA9IChyZXN1bHQpID0+IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShyZXN1bHQucGxhaW50ZXh0KTtcbiAgICBsZXQgcGxhaW50ZXh0O1xuICAgIGlmIChleHBlY3RlZEFsZy5tYXRjaCgvXig/OlJTQXxFQ0RIKS8pKSB7XG4gICAgICBjb25zdCBrZXlzdG9yZSA9IGF3YWl0IGtleXN0b3Jlcy5nZXQodGhpcyk7XG5cbiAgICAgIGZvciAoY29uc3QgeyBrZXlPYmplY3Q6IGtleSB9IG9mIGtleXN0b3JlLmFsbCh7XG4gICAgICAgIC4uLmpvc2UuZGVjb2RlUHJvdGVjdGVkSGVhZGVyKGp3ZSksXG4gICAgICAgIHVzZTogJ2VuYycsXG4gICAgICB9KSkge1xuICAgICAgICBwbGFpbnRleHQgPSBhd2FpdCBqb3NlLmNvbXBhY3REZWNyeXB0KGp3ZSwga2V5KS50aGVuKGdldFBsYWludGV4dCwgKCkgPT4ge30pO1xuICAgICAgICBpZiAocGxhaW50ZXh0KSBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGxhaW50ZXh0ID0gYXdhaXQgam9zZVxuICAgICAgICAuY29tcGFjdERlY3J5cHQoandlLCB0aGlzLnNlY3JldEZvckFsZyhleHBlY3RlZEFsZyA9PT0gJ2RpcicgPyBleHBlY3RlZEVuYyA6IGV4cGVjdGVkQWxnKSlcbiAgICAgICAgLnRoZW4oZ2V0UGxhaW50ZXh0LCAoKSA9PiB7fSk7XG4gICAgfVxuXG4gICAgaWYgKCFwbGFpbnRleHQpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogJ2ZhaWxlZCB0byBkZWNyeXB0IEpXRScsXG4gICAgICAgIGp3dDogandlLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwbGFpbnRleHQ7XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZUlkVG9rZW4odG9rZW5TZXQsIG5vbmNlLCByZXR1cm5lZEJ5LCBtYXhBZ2UsIHN0YXRlKSB7XG4gICAgbGV0IGlkVG9rZW4gPSB0b2tlblNldDtcblxuICAgIGNvbnN0IGV4cGVjdGVkQWxnID0gdGhpcy5pZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnO1xuXG4gICAgY29uc3QgaXNUb2tlblNldCA9IGlkVG9rZW4gaW5zdGFuY2VvZiBUb2tlblNldDtcblxuICAgIGlmIChpc1Rva2VuU2V0KSB7XG4gICAgICBpZiAoIWlkVG9rZW4uaWRfdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaWRfdG9rZW4gbm90IHByZXNlbnQgaW4gVG9rZW5TZXQnKTtcbiAgICAgIH1cbiAgICAgIGlkVG9rZW4gPSBpZFRva2VuLmlkX3Rva2VuO1xuICAgIH1cblxuICAgIGlkVG9rZW4gPSBTdHJpbmcoaWRUb2tlbik7XG5cbiAgICBjb25zdCB0aW1lc3RhbXAgPSBub3coKTtcbiAgICBjb25zdCB7IHByb3RlY3RlZDogaGVhZGVyLCBwYXlsb2FkLCBrZXkgfSA9IGF3YWl0IHRoaXMudmFsaWRhdGVKV1QoaWRUb2tlbiwgZXhwZWN0ZWRBbGcpO1xuXG4gICAgaWYgKHR5cGVvZiBtYXhBZ2UgPT09ICdudW1iZXInIHx8IChtYXhBZ2UgIT09IHNraXBNYXhBZ2VDaGVjayAmJiB0aGlzLnJlcXVpcmVfYXV0aF90aW1lKSkge1xuICAgICAgaWYgKCFwYXlsb2FkLmF1dGhfdGltZSkge1xuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogJ21pc3NpbmcgcmVxdWlyZWQgSldUIHByb3BlcnR5IGF1dGhfdGltZScsXG4gICAgICAgICAgand0OiBpZFRva2VuLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGF5bG9hZC5hdXRoX3RpbWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiAnSldUIGF1dGhfdGltZSBjbGFpbSBtdXN0IGJlIGEgSlNPTiBudW1lcmljIHZhbHVlJyxcbiAgICAgICAgICBqd3Q6IGlkVG9rZW4sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBtYXhBZ2UgPT09ICdudW1iZXInICYmXG4gICAgICBwYXlsb2FkLmF1dGhfdGltZSArIG1heEFnZSA8IHRpbWVzdGFtcCAtIHRoaXNbQ0xPQ0tfVE9MRVJBTkNFXVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBwcmludGY6IFtcbiAgICAgICAgICAndG9vIG11Y2ggdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBFbmQtVXNlciBhdXRoZW50aWNhdGlvbiwgbWF4X2FnZSAlaSwgYXV0aF90aW1lOiAlaSwgbm93ICVpJyxcbiAgICAgICAgICBtYXhBZ2UsXG4gICAgICAgICAgcGF5bG9hZC5hdXRoX3RpbWUsXG4gICAgICAgICAgdGltZXN0YW1wIC0gdGhpc1tDTE9DS19UT0xFUkFOQ0VdLFxuICAgICAgICBdLFxuICAgICAgICBub3c6IHRpbWVzdGFtcCxcbiAgICAgICAgdG9sZXJhbmNlOiB0aGlzW0NMT0NLX1RPTEVSQU5DRV0sXG4gICAgICAgIGF1dGhfdGltZTogcGF5bG9hZC5hdXRoX3RpbWUsXG4gICAgICAgIGp3dDogaWRUb2tlbixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG5vbmNlICE9PSBza2lwTm9uY2VDaGVjayAmJlxuICAgICAgKHBheWxvYWQubm9uY2UgfHwgbm9uY2UgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgIHBheWxvYWQubm9uY2UgIT09IG5vbmNlXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIHByaW50ZjogWydub25jZSBtaXNtYXRjaCwgZXhwZWN0ZWQgJXMsIGdvdDogJXMnLCBub25jZSwgcGF5bG9hZC5ub25jZV0sXG4gICAgICAgIGp3dDogaWRUb2tlbixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXR1cm5lZEJ5ID09PSAnYXV0aG9yaXphdGlvbicpIHtcbiAgICAgIGlmICghcGF5bG9hZC5hdF9oYXNoICYmIHRva2VuU2V0LmFjY2Vzc190b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgYXRfaGFzaCcsXG4gICAgICAgICAgand0OiBpZFRva2VuLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXlsb2FkLmNfaGFzaCAmJiB0b2tlblNldC5jb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBjX2hhc2gnLFxuICAgICAgICAgIGp3dDogaWRUb2tlbixcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmZhcGkoKSkge1xuICAgICAgICBpZiAoIXBheWxvYWQuc19oYXNoICYmICh0b2tlblNldC5zdGF0ZSB8fCBzdGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBzX2hhc2gnLFxuICAgICAgICAgICAgand0OiBpZFRva2VuLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXlsb2FkLnNfaGFzaCkge1xuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHZlcmlmeSBzX2hhc2gsIFwiY2hlY2tzLnN0YXRlXCIgcHJvcGVydHkgbm90IHByb3ZpZGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRva2VuSGFzaC52YWxpZGF0ZShcbiAgICAgICAgICAgIHsgY2xhaW06ICdzX2hhc2gnLCBzb3VyY2U6ICdzdGF0ZScgfSxcbiAgICAgICAgICAgIHBheWxvYWQuc19oYXNoLFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBoZWFkZXIuYWxnLFxuICAgICAgICAgICAga2V5Lmp3ayAmJiBrZXkuandrLmNydixcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7IG1lc3NhZ2U6IGVyci5tZXNzYWdlLCBqd3Q6IGlkVG9rZW4gfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5mYXBpKCkgJiYgcGF5bG9hZC5pYXQgPCB0aW1lc3RhbXAgLSAzNjAwKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIHByaW50ZjogWydKV1QgaXNzdWVkIHRvbyBmYXIgaW4gdGhlIHBhc3QsIG5vdyAlaSwgaWF0ICVpJywgdGltZXN0YW1wLCBwYXlsb2FkLmlhdF0sXG4gICAgICAgIG5vdzogdGltZXN0YW1wLFxuICAgICAgICB0b2xlcmFuY2U6IHRoaXNbQ0xPQ0tfVE9MRVJBTkNFXSxcbiAgICAgICAgaWF0OiBwYXlsb2FkLmlhdCxcbiAgICAgICAgand0OiBpZFRva2VuLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRva2VuU2V0LmFjY2Vzc190b2tlbiAmJiBwYXlsb2FkLmF0X2hhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdG9rZW5IYXNoLnZhbGlkYXRlKFxuICAgICAgICAgIHsgY2xhaW06ICdhdF9oYXNoJywgc291cmNlOiAnYWNjZXNzX3Rva2VuJyB9LFxuICAgICAgICAgIHBheWxvYWQuYXRfaGFzaCxcbiAgICAgICAgICB0b2tlblNldC5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgaGVhZGVyLmFsZyxcbiAgICAgICAgICBrZXkuandrICYmIGtleS5qd2suY3J2LFxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHsgbWVzc2FnZTogZXJyLm1lc3NhZ2UsIGp3dDogaWRUb2tlbiB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG9rZW5TZXQuY29kZSAmJiBwYXlsb2FkLmNfaGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0b2tlbkhhc2gudmFsaWRhdGUoXG4gICAgICAgICAgeyBjbGFpbTogJ2NfaGFzaCcsIHNvdXJjZTogJ2NvZGUnIH0sXG4gICAgICAgICAgcGF5bG9hZC5jX2hhc2gsXG4gICAgICAgICAgdG9rZW5TZXQuY29kZSxcbiAgICAgICAgICBoZWFkZXIuYWxnLFxuICAgICAgICAgIGtleS5qd2sgJiYga2V5Lmp3ay5jcnYsXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3IoeyBtZXNzYWdlOiBlcnIubWVzc2FnZSwgand0OiBpZFRva2VuIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b2tlblNldDtcbiAgfVxuXG4gIGFzeW5jIHZhbGlkYXRlSldUKGp3dCwgZXhwZWN0ZWRBbGcsIHJlcXVpcmVkID0gWydpc3MnLCAnc3ViJywgJ2F1ZCcsICdleHAnLCAnaWF0J10pIHtcbiAgICBjb25zdCBpc1NlbGZJc3N1ZWQgPSB0aGlzLmlzc3Vlci5pc3N1ZXIgPT09ICdodHRwczovL3NlbGYtaXNzdWVkLm1lJztcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBub3coKTtcbiAgICBsZXQgaGVhZGVyO1xuICAgIGxldCBwYXlsb2FkO1xuICAgIHRyeSB7XG4gICAgICAoeyBoZWFkZXIsIHBheWxvYWQgfSA9IGRlY29kZUpXVChqd3QsIHsgY29tcGxldGU6IHRydWUgfSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBwcmludGY6IFsnZmFpbGVkIHRvIGRlY29kZSBKV1QgKCVzOiAlcyknLCBlcnIubmFtZSwgZXJyLm1lc3NhZ2VdLFxuICAgICAgICBqd3QsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaGVhZGVyLmFsZyAhPT0gZXhwZWN0ZWRBbGcpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgcHJpbnRmOiBbJ3VuZXhwZWN0ZWQgSldUIGFsZyByZWNlaXZlZCwgZXhwZWN0ZWQgJXMsIGdvdDogJXMnLCBleHBlY3RlZEFsZywgaGVhZGVyLmFsZ10sXG4gICAgICAgIGp3dCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpc1NlbGZJc3N1ZWQpIHtcbiAgICAgIHJlcXVpcmVkID0gWy4uLnJlcXVpcmVkLCAnc3ViX2p3ayddO1xuICAgIH1cblxuICAgIHJlcXVpcmVkLmZvckVhY2godmVyaWZ5UHJlc2VuY2UuYmluZCh1bmRlZmluZWQsIHBheWxvYWQsIGp3dCkpO1xuXG4gICAgaWYgKHBheWxvYWQuaXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBleHBlY3RlZElzcyA9IHRoaXMuaXNzdWVyLmlzc3VlcjtcblxuICAgICAgaWYgKHRoaXMuI2FhZElzc1ZhbGlkYXRpb24pIHtcbiAgICAgICAgZXhwZWN0ZWRJc3MgPSB0aGlzLmlzc3Vlci5pc3N1ZXIucmVwbGFjZSgne3RlbmFudGlkfScsIHBheWxvYWQudGlkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBheWxvYWQuaXNzICE9PSBleHBlY3RlZElzcykge1xuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgcHJpbnRmOiBbJ3VuZXhwZWN0ZWQgaXNzIHZhbHVlLCBleHBlY3RlZCAlcywgZ290OiAlcycsIGV4cGVjdGVkSXNzLCBwYXlsb2FkLmlzc10sXG4gICAgICAgICAgand0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGF5bG9hZC5pYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkLmlhdCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6ICdKV1QgaWF0IGNsYWltIG11c3QgYmUgYSBKU09OIG51bWVyaWMgdmFsdWUnLFxuICAgICAgICAgIGp3dCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBheWxvYWQubmJmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF5bG9hZC5uYmYgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiAnSldUIG5iZiBjbGFpbSBtdXN0IGJlIGEgSlNPTiBudW1lcmljIHZhbHVlJyxcbiAgICAgICAgICBqd3QsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHBheWxvYWQubmJmID4gdGltZXN0YW1wICsgdGhpc1tDTE9DS19UT0xFUkFOQ0VdKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBwcmludGY6IFtcbiAgICAgICAgICAgICdKV1Qgbm90IGFjdGl2ZSB5ZXQsIG5vdyAlaSwgbmJmICVpJyxcbiAgICAgICAgICAgIHRpbWVzdGFtcCArIHRoaXNbQ0xPQ0tfVE9MRVJBTkNFXSxcbiAgICAgICAgICAgIHBheWxvYWQubmJmLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgbm93OiB0aW1lc3RhbXAsXG4gICAgICAgICAgdG9sZXJhbmNlOiB0aGlzW0NMT0NLX1RPTEVSQU5DRV0sXG4gICAgICAgICAgbmJmOiBwYXlsb2FkLm5iZixcbiAgICAgICAgICBqd3QsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXlsb2FkLmV4cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHBheWxvYWQuZXhwICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogJ0pXVCBleHAgY2xhaW0gbXVzdCBiZSBhIEpTT04gbnVtZXJpYyB2YWx1ZScsXG4gICAgICAgICAgand0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aW1lc3RhbXAgLSB0aGlzW0NMT0NLX1RPTEVSQU5DRV0gPj0gcGF5bG9hZC5leHApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIHByaW50ZjogWydKV1QgZXhwaXJlZCwgbm93ICVpLCBleHAgJWknLCB0aW1lc3RhbXAgLSB0aGlzW0NMT0NLX1RPTEVSQU5DRV0sIHBheWxvYWQuZXhwXSxcbiAgICAgICAgICBub3c6IHRpbWVzdGFtcCxcbiAgICAgICAgICB0b2xlcmFuY2U6IHRoaXNbQ0xPQ0tfVE9MRVJBTkNFXSxcbiAgICAgICAgICBleHA6IHBheWxvYWQuZXhwLFxuICAgICAgICAgIGp3dCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBheWxvYWQuYXVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQuYXVkKSkge1xuICAgICAgICBpZiAocGF5bG9hZC5hdWQubGVuZ3RoID4gMSAmJiAhcGF5bG9hZC5henApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiAnbWlzc2luZyByZXF1aXJlZCBKV1QgcHJvcGVydHkgYXpwJyxcbiAgICAgICAgICAgIGp3dCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGF5bG9hZC5hdWQuaW5jbHVkZXModGhpcy5jbGllbnRfaWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgICAgcHJpbnRmOiBbXG4gICAgICAgICAgICAgICdhdWQgaXMgbWlzc2luZyB0aGUgY2xpZW50X2lkLCBleHBlY3RlZCAlcyB0byBiZSBpbmNsdWRlZCBpbiAlaicsXG4gICAgICAgICAgICAgIHRoaXMuY2xpZW50X2lkLFxuICAgICAgICAgICAgICBwYXlsb2FkLmF1ZCxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBqd3QsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGF5bG9hZC5hdWQgIT09IHRoaXMuY2xpZW50X2lkKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBwcmludGY6IFsnYXVkIG1pc21hdGNoLCBleHBlY3RlZCAlcywgZ290OiAlcycsIHRoaXMuY2xpZW50X2lkLCBwYXlsb2FkLmF1ZF0sXG4gICAgICAgICAgand0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGF5bG9hZC5henAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IGFkZGl0aW9uYWxBdXRob3JpemVkUGFydGllcyA9IHRoaXMuI2FkZGl0aW9uYWxBdXRob3JpemVkUGFydGllcztcblxuICAgICAgaWYgKHR5cGVvZiBhZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFkZGl0aW9uYWxBdXRob3JpemVkUGFydGllcyA9IFt0aGlzLmNsaWVudF9pZCwgYWRkaXRpb25hbEF1dGhvcml6ZWRQYXJ0aWVzXTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXMpKSB7XG4gICAgICAgIGFkZGl0aW9uYWxBdXRob3JpemVkUGFydGllcyA9IFt0aGlzLmNsaWVudF9pZCwgLi4uYWRkaXRpb25hbEF1dGhvcml6ZWRQYXJ0aWVzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZGl0aW9uYWxBdXRob3JpemVkUGFydGllcyA9IFt0aGlzLmNsaWVudF9pZF07XG4gICAgICB9XG5cbiAgICAgIGlmICghYWRkaXRpb25hbEF1dGhvcml6ZWRQYXJ0aWVzLmluY2x1ZGVzKHBheWxvYWQuYXpwKSkge1xuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgcHJpbnRmOiBbJ2F6cCBtaXNtYXRjaCwgZ290OiAlcycsIHBheWxvYWQuYXpwXSxcbiAgICAgICAgICBqd3QsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBrZXlzO1xuXG4gICAgaWYgKGlzU2VsZklzc3VlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KGlzUGxhaW5PYmplY3QocGF5bG9hZC5zdWJfandrKSk7XG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IGpvc2UuaW1wb3J0SldLKHBheWxvYWQuc3ViX2p3aywgaGVhZGVyLmFsZyk7XG4gICAgICAgIGFzc2VydC5lcXVhbChrZXkudHlwZSwgJ3B1YmxpYycpO1xuICAgICAgICBrZXlzID0gW3sga2V5T2JqZWN0OiBrZXkgfV07XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6ICdmYWlsZWQgdG8gdXNlIHN1Yl9qd2sgY2xhaW0gYXMgYW4gYXN5bW1ldHJpYyBKU09OIFdlYiBLZXknLFxuICAgICAgICAgIGp3dCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoKGF3YWl0IGpvc2UuY2FsY3VsYXRlSndrVGh1bWJwcmludChwYXlsb2FkLnN1Yl9qd2spKSAhPT0gcGF5bG9hZC5zdWIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6ICdmYWlsZWQgdG8gbWF0Y2ggdGhlIHN1YmplY3Qgd2l0aCBzdWJfandrJyxcbiAgICAgICAgICBqd3QsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGVhZGVyLmFsZy5zdGFydHNXaXRoKCdIUycpKSB7XG4gICAgICBrZXlzID0gW3RoaXMuc2VjcmV0Rm9yQWxnKGhlYWRlci5hbGcpXTtcbiAgICB9IGVsc2UgaWYgKGhlYWRlci5hbGcgIT09ICdub25lJykge1xuICAgICAga2V5cyA9IGF3YWl0IHF1ZXJ5S2V5U3RvcmUuY2FsbCh0aGlzLmlzc3VlciwgeyAuLi5oZWFkZXIsIHVzZTogJ3NpZycgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFrZXlzICYmIGhlYWRlci5hbGcgPT09ICdub25lJykge1xuICAgICAgcmV0dXJuIHsgcHJvdGVjdGVkOiBoZWFkZXIsIHBheWxvYWQgfTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBjb25zdCB2ZXJpZmllZCA9IGF3YWl0IGpvc2VcbiAgICAgICAgLmNvbXBhY3RWZXJpZnkoand0LCBrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8ga2V5IDoga2V5LmtleU9iamVjdClcbiAgICAgICAgLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgIGlmICh2ZXJpZmllZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgcHJvdGVjdGVkOiB2ZXJpZmllZC5wcm90ZWN0ZWRIZWFkZXIsXG4gICAgICAgICAga2V5LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgIG1lc3NhZ2U6ICdmYWlsZWQgdG8gdmFsaWRhdGUgSldUIHNpZ25hdHVyZScsXG4gICAgICBqd3QsXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyByZWZyZXNoKHJlZnJlc2hUb2tlbiwgeyBleGNoYW5nZUJvZHksIGNsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1AgfSA9IHt9KSB7XG4gICAgbGV0IHRva2VuID0gcmVmcmVzaFRva2VuO1xuXG4gICAgaWYgKHRva2VuIGluc3RhbmNlb2YgVG9rZW5TZXQpIHtcbiAgICAgIGlmICghdG9rZW4ucmVmcmVzaF90b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWZyZXNoX3Rva2VuIG5vdCBwcmVzZW50IGluIFRva2VuU2V0Jyk7XG4gICAgICB9XG4gICAgICB0b2tlbiA9IHRva2VuLnJlZnJlc2hfdG9rZW47XG4gICAgfVxuXG4gICAgY29uc3QgdG9rZW5zZXQgPSBhd2FpdCB0aGlzLmdyYW50KFxuICAgICAge1xuICAgICAgICAuLi5leGNoYW5nZUJvZHksXG4gICAgICAgIGdyYW50X3R5cGU6ICdyZWZyZXNoX3Rva2VuJyxcbiAgICAgICAgcmVmcmVzaF90b2tlbjogU3RyaW5nKHRva2VuKSxcbiAgICAgIH0sXG4gICAgICB7IGNsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1AgfSxcbiAgICApO1xuXG4gICAgaWYgKHRva2Vuc2V0LmlkX3Rva2VuKSB7XG4gICAgICBhd2FpdCB0aGlzLmRlY3J5cHRJZFRva2VuKHRva2Vuc2V0KTtcbiAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGVJZFRva2VuKHRva2Vuc2V0LCBza2lwTm9uY2VDaGVjaywgJ3Rva2VuJywgc2tpcE1heEFnZUNoZWNrKTtcblxuICAgICAgaWYgKHJlZnJlc2hUb2tlbiBpbnN0YW5jZW9mIFRva2VuU2V0ICYmIHJlZnJlc2hUb2tlbi5pZF90b2tlbikge1xuICAgICAgICBjb25zdCBleHBlY3RlZFN1YiA9IHJlZnJlc2hUb2tlbi5jbGFpbXMoKS5zdWI7XG4gICAgICAgIGNvbnN0IGFjdHVhbFN1YiA9IHRva2Vuc2V0LmNsYWltcygpLnN1YjtcbiAgICAgICAgaWYgKGFjdHVhbFN1YiAhPT0gZXhwZWN0ZWRTdWIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgICBwcmludGY6IFsnc3ViIG1pc21hdGNoLCBleHBlY3RlZCAlcywgZ290OiAlcycsIGV4cGVjdGVkU3ViLCBhY3R1YWxTdWJdLFxuICAgICAgICAgICAgand0OiB0b2tlbnNldC5pZF90b2tlbixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b2tlbnNldDtcbiAgfVxuXG4gIGFzeW5jIHJlcXVlc3RSZXNvdXJjZShcbiAgICByZXNvdXJjZVVybCxcbiAgICBhY2Nlc3NUb2tlbixcbiAgICB7XG4gICAgICBtZXRob2QsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keSxcbiAgICAgIERQb1AsXG4gICAgICB0b2tlblR5cGUgPSBEUG9QXG4gICAgICAgID8gJ0RQb1AnXG4gICAgICAgIDogYWNjZXNzVG9rZW4gaW5zdGFuY2VvZiBUb2tlblNldFxuICAgICAgICA/IGFjY2Vzc1Rva2VuLnRva2VuX3R5cGVcbiAgICAgICAgOiAnQmVhcmVyJyxcbiAgICB9ID0ge30sXG4gICAgcmV0cnksXG4gICkge1xuICAgIGlmIChhY2Nlc3NUb2tlbiBpbnN0YW5jZW9mIFRva2VuU2V0KSB7XG4gICAgICBpZiAoIWFjY2Vzc1Rva2VuLmFjY2Vzc190b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhY2Nlc3NfdG9rZW4gbm90IHByZXNlbnQgaW4gVG9rZW5TZXQnKTtcbiAgICAgIH1cbiAgICAgIGFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuO1xuICAgIH1cblxuICAgIGlmICghYWNjZXNzVG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vIGFjY2VzcyB0b2tlbiBwcm92aWRlZCcpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFjY2Vzc1Rva2VuICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhY2Nlc3MgdG9rZW4gcHJvdmlkZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0T3B0cyA9IHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYXV0aG9yaXphdGlvbkhlYWRlclZhbHVlKGFjY2Vzc1Rva2VuLCB0b2tlblR5cGUpLFxuICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgfSxcbiAgICAgIGJvZHksXG4gICAgfTtcblxuICAgIGNvbnN0IG1UTFMgPSAhIXRoaXMudGxzX2NsaWVudF9jZXJ0aWZpY2F0ZV9ib3VuZF9hY2Nlc3NfdG9rZW5zO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAge1xuICAgICAgICAuLi5yZXF1ZXN0T3B0cyxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnYnVmZmVyJyxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICB1cmw6IHJlc291cmNlVXJsLFxuICAgICAgfSxcbiAgICAgIHsgYWNjZXNzVG9rZW4sIG1UTFMsIERQb1AgfSxcbiAgICApO1xuXG4gICAgY29uc3Qgd3d3QXV0aGVudGljYXRlID0gcmVzcG9uc2UuaGVhZGVyc1snd3d3LWF1dGhlbnRpY2F0ZSddO1xuICAgIGlmIChcbiAgICAgIHJldHJ5ICE9PSByZXRyeUF0dGVtcHQgJiZcbiAgICAgIHd3d0F1dGhlbnRpY2F0ZSAmJlxuICAgICAgd3d3QXV0aGVudGljYXRlLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnZHBvcCAnKSAmJlxuICAgICAgcGFyc2VXd3dBdXRoZW50aWNhdGUod3d3QXV0aGVudGljYXRlKS5lcnJvciA9PT0gJ3VzZV9kcG9wX25vbmNlJ1xuICAgICkge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFJlc291cmNlKHJlc291cmNlVXJsLCBhY2Nlc3NUb2tlbiwge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHksXG4gICAgICAgIERQb1AsXG4gICAgICAgIHRva2VuVHlwZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG4gIGFzeW5jIHVzZXJpbmZvKGFjY2Vzc1Rva2VuLCB7IG1ldGhvZCA9ICdHRVQnLCB2aWEgPSAnaGVhZGVyJywgdG9rZW5UeXBlLCBwYXJhbXMsIERQb1AgfSA9IHt9KSB7XG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLmlzc3VlciwgJ3VzZXJpbmZvX2VuZHBvaW50Jyk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHRva2VuVHlwZSxcbiAgICAgIG1ldGhvZDogU3RyaW5nKG1ldGhvZCkudG9VcHBlckNhc2UoKSxcbiAgICAgIERQb1AsXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLm1ldGhvZCAhPT0gJ0dFVCcgJiYgb3B0aW9ucy5tZXRob2QgIT09ICdQT1NUJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignI3VzZXJpbmZvKCkgbWV0aG9kIGNhbiBvbmx5IGJlIFBPU1Qgb3IgYSBHRVQnKTtcbiAgICB9XG5cbiAgICBpZiAodmlhID09PSAnYm9keScgJiYgb3B0aW9ucy5tZXRob2QgIT09ICdQT1NUJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FuIG9ubHkgc2VuZCBib2R5IG9uIFBPU1QnKTtcbiAgICB9XG5cbiAgICBjb25zdCBqd3QgPSAhISh0aGlzLnVzZXJpbmZvX3NpZ25lZF9yZXNwb25zZV9hbGcgfHwgdGhpcy51c2VyaW5mb19lbmNyeXB0ZWRfcmVzcG9uc2VfYWxnKTtcblxuICAgIGlmIChqd3QpIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVycyA9IHsgQWNjZXB0OiAnYXBwbGljYXRpb24vand0JyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmhlYWRlcnMgPSB7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nIH07XG4gICAgfVxuICAgIGNvbnN0IG1UTFMgPSAhIXRoaXMudGxzX2NsaWVudF9jZXJ0aWZpY2F0ZV9ib3VuZF9hY2Nlc3NfdG9rZW5zO1xuXG4gICAgbGV0IHRhcmdldFVybDtcbiAgICBpZiAobVRMUyAmJiB0aGlzLmlzc3Vlci5tdGxzX2VuZHBvaW50X2FsaWFzZXMpIHtcbiAgICAgIHRhcmdldFVybCA9IHRoaXMuaXNzdWVyLm10bHNfZW5kcG9pbnRfYWxpYXNlcy51c2VyaW5mb19lbmRwb2ludDtcbiAgICB9XG5cbiAgICB0YXJnZXRVcmwgPSBuZXcgdXJsLlVSTCh0YXJnZXRVcmwgfHwgdGhpcy5pc3N1ZXIudXNlcmluZm9fZW5kcG9pbnQpO1xuXG4gICAgaWYgKHZpYSA9PT0gJ2JvZHknKSB7XG4gICAgICBvcHRpb25zLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIG9wdGlvbnMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgICAgIG9wdGlvbnMuYm9keSA9IG5ldyB1cmwuVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICBvcHRpb25zLmJvZHkuYXBwZW5kKFxuICAgICAgICAnYWNjZXNzX3Rva2VuJyxcbiAgICAgICAgYWNjZXNzVG9rZW4gaW5zdGFuY2VvZiBUb2tlblNldCA/IGFjY2Vzc1Rva2VuLmFjY2Vzc190b2tlbiA6IGFjY2Vzc1Rva2VuLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgYWRkaXRpb25hbCBwYXJhbWV0ZXJzLCBHRVQgdmlhIHF1ZXJ5c3RyaW5nLCBQT1NUIHZpYSB1cmxlbmNvZGVkIGJvZHlcbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICBpZiAob3B0aW9ucy5tZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHBhcmFtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgdGFyZ2V0VXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICAgICAgLy8gUE9TVCAmJiB2aWEgYm9keVxuICAgICAgICBPYmplY3QuZW50cmllcyhwYXJhbXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgIG9wdGlvbnMuYm9keS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUE9TVCAmJiB2aWEgaGVhZGVyXG4gICAgICAgIG9wdGlvbnMuYm9keSA9IG5ldyB1cmwuVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIG9wdGlvbnMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICBvcHRpb25zLmJvZHkuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgICBvcHRpb25zLmJvZHkgPSBvcHRpb25zLmJvZHkudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdFJlc291cmNlKHRhcmdldFVybCwgYWNjZXNzVG9rZW4sIG9wdGlvbnMpO1xuXG4gICAgbGV0IHBhcnNlZCA9IHByb2Nlc3NSZXNwb25zZShyZXNwb25zZSwgeyBiZWFyZXI6IHRydWUgfSk7XG5cbiAgICBpZiAoand0KSB7XG4gICAgICBpZiAoIS9eYXBwbGljYXRpb25cXC9qd3QvLnRlc3QocmVzcG9uc2UuaGVhZGVyc1snY29udGVudC10eXBlJ10pKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiAnZXhwZWN0ZWQgYXBwbGljYXRpb24vand0IHJlc3BvbnNlIGZyb20gdGhlIHVzZXJpbmZvX2VuZHBvaW50JyxcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJvZHkgPSByZXNwb25zZS5ib2R5LnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCB1c2VyaW5mbyA9IGF3YWl0IHRoaXMuZGVjcnlwdEpXVFVzZXJpbmZvKGJvZHkpO1xuICAgICAgaWYgKCF0aGlzLnVzZXJpbmZvX3NpZ25lZF9yZXNwb25zZV9hbGcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKHVzZXJpbmZvKTtcbiAgICAgICAgICBhc3NlcnQoaXNQbGFpbk9iamVjdChwYXJzZWQpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ2ZhaWxlZCB0byBwYXJzZSB1c2VyaW5mbyBKV0UgcGF5bG9hZCBhcyBKU09OJyxcbiAgICAgICAgICAgIGp3dDogdXNlcmluZm8sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICh7IHBheWxvYWQ6IHBhcnNlZCB9ID0gYXdhaXQgdGhpcy52YWxpZGF0ZUpXVFVzZXJpbmZvKHVzZXJpbmZvKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2UocmVzcG9uc2UuYm9keSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ3Jlc3BvbnNlJywgeyB2YWx1ZTogcmVzcG9uc2UgfSk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWNjZXNzVG9rZW4gaW5zdGFuY2VvZiBUb2tlblNldCAmJiBhY2Nlc3NUb2tlbi5pZF90b2tlbikge1xuICAgICAgY29uc3QgZXhwZWN0ZWRTdWIgPSBhY2Nlc3NUb2tlbi5jbGFpbXMoKS5zdWI7XG4gICAgICBpZiAocGFyc2VkLnN1YiAhPT0gZXhwZWN0ZWRTdWIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIHByaW50ZjogWyd1c2VyaW5mbyBzdWIgbWlzbWF0Y2gsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJywgZXhwZWN0ZWRTdWIsIHBhcnNlZC5zdWJdLFxuICAgICAgICAgIGJvZHk6IHBhcnNlZCxcbiAgICAgICAgICBqd3Q6IGFjY2Vzc1Rva2VuLmlkX3Rva2VuLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgZW5jcnlwdGlvblNlY3JldChsZW4pIHtcbiAgICBjb25zdCBoYXNoID0gbGVuIDw9IDI1NiA/ICdzaGEyNTYnIDogbGVuIDw9IDM4NCA/ICdzaGEzODQnIDogbGVuIDw9IDUxMiA/ICdzaGE1MTInIDogZmFsc2U7XG4gICAgaWYgKCFoYXNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHN5bW1ldHJpYyBlbmNyeXB0aW9uIGtleSBkZXJpdmF0aW9uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyeXB0b1xuICAgICAgLmNyZWF0ZUhhc2goaGFzaClcbiAgICAgIC51cGRhdGUodGhpcy5jbGllbnRfc2VjcmV0KVxuICAgICAgLmRpZ2VzdCgpXG4gICAgICAuc2xpY2UoMCwgbGVuIC8gOCk7XG4gIH1cblxuICBzZWNyZXRGb3JBbGcoYWxnKSB7XG4gICAgaWYgKCF0aGlzLmNsaWVudF9zZWNyZXQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NsaWVudF9zZWNyZXQgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoL15BKFxcZHszfSkoPzpHQ00pP0tXJC8udGVzdChhbGcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uU2VjcmV0KHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApKTtcbiAgICB9XG5cbiAgICBpZiAoL15BKFxcZHszfSkoPzpHQ018Q0JDLUhTKFxcZHszfSkpJC8udGVzdChhbGcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uU2VjcmV0KHBhcnNlSW50KFJlZ0V4cC4kMiB8fCBSZWdFeHAuJDEsIDEwKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0aGlzLmNsaWVudF9zZWNyZXQpO1xuICB9XG5cbiAgYXN5bmMgZ3JhbnQoYm9keSwgeyBjbGllbnRBc3NlcnRpb25QYXlsb2FkLCBEUG9QIH0gPSB7fSwgcmV0cnkpIHtcbiAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKHRoaXMuaXNzdWVyLCAndG9rZW5fZW5kcG9pbnQnKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF1dGhlbnRpY2F0ZWRQb3N0LmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3Rva2VuJyxcbiAgICAgIHtcbiAgICAgICAgZm9ybTogYm9keSxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICB9LFxuICAgICAgeyBjbGllbnRBc3NlcnRpb25QYXlsb2FkLCBEUG9QIH0sXG4gICAgKTtcbiAgICBsZXQgcmVzcG9uc2VCb2R5O1xuICAgIHRyeSB7XG4gICAgICByZXNwb25zZUJvZHkgPSBwcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHJldHJ5ICE9PSByZXRyeUF0dGVtcHQgJiYgZXJyIGluc3RhbmNlb2YgT1BFcnJvciAmJiBlcnIuZXJyb3IgPT09ICd1c2VfZHBvcF9ub25jZScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JhbnQoYm9keSwgeyBjbGllbnRBc3NlcnRpb25QYXlsb2FkLCBEUG9QIH0sIHJldHJ5QXR0ZW1wdCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUb2tlblNldChyZXNwb25zZUJvZHkpO1xuICB9XG5cbiAgYXN5bmMgZGV2aWNlQXV0aG9yaXphdGlvbihwYXJhbXMgPSB7fSwgeyBleGNoYW5nZUJvZHksIGNsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1AgfSA9IHt9KSB7XG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLmlzc3VlciwgJ2RldmljZV9hdXRob3JpemF0aW9uX2VuZHBvaW50Jyk7XG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLmlzc3VlciwgJ3Rva2VuX2VuZHBvaW50Jyk7XG5cbiAgICBjb25zdCBib2R5ID0gYXV0aG9yaXphdGlvblBhcmFtcy5jYWxsKHRoaXMsIHtcbiAgICAgIGNsaWVudF9pZDogdGhpcy5jbGllbnRfaWQsXG4gICAgICByZWRpcmVjdF91cmk6IG51bGwsXG4gICAgICByZXNwb25zZV90eXBlOiBudWxsLFxuICAgICAgLi4ucGFyYW1zLFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhdXRoZW50aWNhdGVkUG9zdC5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdkZXZpY2VfYXV0aG9yaXphdGlvbicsXG4gICAgICB7XG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICBmb3JtOiBib2R5LFxuICAgICAgfSxcbiAgICAgIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCwgZW5kcG9pbnRBdXRoTWV0aG9kOiAndG9rZW4nIH0sXG4gICAgKTtcbiAgICBjb25zdCByZXNwb25zZUJvZHkgPSBwcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpO1xuXG4gICAgcmV0dXJuIG5ldyBEZXZpY2VGbG93SGFuZGxlKHtcbiAgICAgIGNsaWVudDogdGhpcyxcbiAgICAgIGV4Y2hhbmdlQm9keSxcbiAgICAgIGNsaWVudEFzc2VydGlvblBheWxvYWQsXG4gICAgICByZXNwb25zZTogcmVzcG9uc2VCb2R5LFxuICAgICAgbWF4QWdlOiBwYXJhbXMubWF4X2FnZSxcbiAgICAgIERQb1AsXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyByZXZva2UodG9rZW4sIGhpbnQsIHsgcmV2b2tlQm9keSwgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCB9ID0ge30pIHtcbiAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKHRoaXMuaXNzdWVyLCAncmV2b2NhdGlvbl9lbmRwb2ludCcpO1xuICAgIGlmIChoaW50ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGhpbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoaW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtID0geyAuLi5yZXZva2VCb2R5LCB0b2tlbiB9O1xuXG4gICAgaWYgKGhpbnQpIHtcbiAgICAgIGZvcm0udG9rZW5fdHlwZV9oaW50ID0gaGludDtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF1dGhlbnRpY2F0ZWRQb3N0LmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3Jldm9jYXRpb24nLFxuICAgICAge1xuICAgICAgICBmb3JtLFxuICAgICAgfSxcbiAgICAgIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCB9LFxuICAgICk7XG4gICAgcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlLCB7IGJvZHk6IGZhbHNlIH0pO1xuICB9XG5cbiAgYXN5bmMgaW50cm9zcGVjdCh0b2tlbiwgaGludCwgeyBpbnRyb3NwZWN0Qm9keSwgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCB9ID0ge30pIHtcbiAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKHRoaXMuaXNzdWVyLCAnaW50cm9zcGVjdGlvbl9lbmRwb2ludCcpO1xuICAgIGlmIChoaW50ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGhpbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoaW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtID0geyAuLi5pbnRyb3NwZWN0Qm9keSwgdG9rZW4gfTtcbiAgICBpZiAoaGludCkge1xuICAgICAgZm9ybS50b2tlbl90eXBlX2hpbnQgPSBoaW50O1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXV0aGVudGljYXRlZFBvc3QuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnaW50cm9zcGVjdGlvbicsXG4gICAgICB7IGZvcm0sIHJlc3BvbnNlVHlwZTogJ2pzb24nIH0sXG4gICAgICB7IGNsaWVudEFzc2VydGlvblBheWxvYWQgfSxcbiAgICApO1xuXG4gICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlKTtcblxuICAgIHJldHVybiByZXNwb25zZUJvZHk7XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgcmVnaXN0ZXIobWV0YWRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgaW5pdGlhbEFjY2Vzc1Rva2VuLCBqd2tzLCAuLi5jbGllbnRPcHRpb25zIH0gPSBvcHRpb25zO1xuXG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLmlzc3VlciwgJ3JlZ2lzdHJhdGlvbl9lbmRwb2ludCcpO1xuXG4gICAgaWYgKGp3a3MgIT09IHVuZGVmaW5lZCAmJiAhKG1ldGFkYXRhLmp3a3MgfHwgbWV0YWRhdGEuandrc191cmkpKSB7XG4gICAgICBjb25zdCBrZXlzdG9yZSA9IGF3YWl0IGdldEtleXN0b3JlLmNhbGwodGhpcywgandrcyk7XG4gICAgICBtZXRhZGF0YS5qd2tzID0ga2V5c3RvcmUudG9KV0tTKCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LmNhbGwodGhpcywge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgLi4uKGluaXRpYWxBY2Nlc3NUb2tlblxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBhdXRob3JpemF0aW9uSGVhZGVyVmFsdWUoaW5pdGlhbEFjY2Vzc1Rva2VuKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IHVuZGVmaW5lZCksXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICBqc29uOiBtZXRhZGF0YSxcbiAgICAgIHVybDogdGhpcy5pc3N1ZXIucmVnaXN0cmF0aW9uX2VuZHBvaW50LFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlLCB7IHN0YXR1c0NvZGU6IDIwMSwgYmVhcmVyOiB0cnVlIH0pO1xuXG4gICAgcmV0dXJuIG5ldyB0aGlzKHJlc3BvbnNlQm9keSwgandrcywgY2xpZW50T3B0aW9ucyk7XG4gIH1cblxuICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIGNsb25lKE9iamVjdC5mcm9tRW50cmllcyh0aGlzLiNtZXRhZGF0YS5lbnRyaWVzKCkpKTtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBmcm9tVXJpKHJlZ2lzdHJhdGlvbkNsaWVudFVyaSwgcmVnaXN0cmF0aW9uQWNjZXNzVG9rZW4sIGp3a3MsIGNsaWVudE9wdGlvbnMpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QuY2FsbCh0aGlzLCB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsOiByZWdpc3RyYXRpb25DbGllbnRVcmksXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYXV0aG9yaXphdGlvbkhlYWRlclZhbHVlKHJlZ2lzdHJhdGlvbkFjY2Vzc1Rva2VuKSxcbiAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IHByb2Nlc3NSZXNwb25zZShyZXNwb25zZSwgeyBiZWFyZXI6IHRydWUgfSk7XG5cbiAgICByZXR1cm4gbmV3IHRoaXMocmVzcG9uc2VCb2R5LCBqd2tzLCBjbGllbnRPcHRpb25zKTtcbiAgfVxuXG4gIGFzeW5jIHJlcXVlc3RPYmplY3QoXG4gICAgcmVxdWVzdE9iamVjdCA9IHt9LFxuICAgIHtcbiAgICAgIHNpZ246IHNpZ25pbmdBbGdvcml0aG0gPSB0aGlzLnJlcXVlc3Rfb2JqZWN0X3NpZ25pbmdfYWxnIHx8ICdub25lJyxcbiAgICAgIGVuY3J5cHQ6IHtcbiAgICAgICAgYWxnOiBlS2V5TWFuYWdlbWVudCA9IHRoaXMucmVxdWVzdF9vYmplY3RfZW5jcnlwdGlvbl9hbGcsXG4gICAgICAgIGVuYzogZUNvbnRlbnRFbmNyeXB0aW9uID0gdGhpcy5yZXF1ZXN0X29iamVjdF9lbmNyeXB0aW9uX2VuYyB8fCAnQTEyOENCQy1IUzI1NicsXG4gICAgICB9ID0ge30sXG4gICAgfSA9IHt9LFxuICApIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QocmVxdWVzdE9iamVjdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlcXVlc3RPYmplY3QgbXVzdCBiZSBhIHBsYWluIG9iamVjdCcpO1xuICAgIH1cblxuICAgIGxldCBzaWduZWQ7XG4gICAgbGV0IGtleTtcbiAgICBjb25zdCB1bml4ID0gbm93KCk7XG4gICAgY29uc3QgaGVhZGVyID0geyBhbGc6IHNpZ25pbmdBbGdvcml0aG0sIHR5cDogJ29hdXRoLWF1dGh6LXJlcStqd3QnIH07XG4gICAgY29uc3QgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KFxuICAgICAgZGVmYXVsdHMoe30sIHJlcXVlc3RPYmplY3QsIHtcbiAgICAgICAgaXNzOiB0aGlzLmNsaWVudF9pZCxcbiAgICAgICAgYXVkOiB0aGlzLmlzc3Vlci5pc3N1ZXIsXG4gICAgICAgIGNsaWVudF9pZDogdGhpcy5jbGllbnRfaWQsXG4gICAgICAgIGp0aTogcmFuZG9tKCksXG4gICAgICAgIGlhdDogdW5peCxcbiAgICAgICAgZXhwOiB1bml4ICsgMzAwLFxuICAgICAgICAuLi4odGhpcy5mYXBpKCkgPyB7IG5iZjogdW5peCB9IDogdW5kZWZpbmVkKSxcbiAgICAgIH0pLFxuICAgICk7XG4gICAgaWYgKHNpZ25pbmdBbGdvcml0aG0gPT09ICdub25lJykge1xuICAgICAgc2lnbmVkID0gW2Jhc2U2NHVybC5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSksIGJhc2U2NHVybC5lbmNvZGUocGF5bG9hZCksICcnXS5qb2luKCcuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN5bW1ldHJpYyA9IHNpZ25pbmdBbGdvcml0aG0uc3RhcnRzV2l0aCgnSFMnKTtcbiAgICAgIGlmIChzeW1tZXRyaWMpIHtcbiAgICAgICAga2V5ID0gdGhpcy5zZWNyZXRGb3JBbGcoc2lnbmluZ0FsZ29yaXRobSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBrZXlzdG9yZSA9IGF3YWl0IGtleXN0b3Jlcy5nZXQodGhpcyk7XG5cbiAgICAgICAgaWYgKCFrZXlzdG9yZSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgbm8ga2V5c3RvcmUgcHJlc2VudCBmb3IgY2xpZW50LCBjYW5ub3Qgc2lnbiB1c2luZyBhbGcgJHtzaWduaW5nQWxnb3JpdGhtfWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBrZXkgPSBrZXlzdG9yZS5nZXQoeyBhbGc6IHNpZ25pbmdBbGdvcml0aG0sIHVzZTogJ3NpZycgfSk7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgbm8ga2V5IHRvIHNpZ24gd2l0aCBmb3VuZCBmb3IgYWxnICR7c2lnbmluZ0FsZ29yaXRobX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzaWduZWQgPSBhd2FpdCBuZXcgam9zZS5Db21wYWN0U2lnbihuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocGF5bG9hZCkpXG4gICAgICAgIC5zZXRQcm90ZWN0ZWRIZWFkZXIoe1xuICAgICAgICAgIC4uLmhlYWRlcixcbiAgICAgICAgICBraWQ6IHN5bW1ldHJpYyA/IHVuZGVmaW5lZCA6IGtleS5qd2sua2lkLFxuICAgICAgICB9KVxuICAgICAgICAuc2lnbihzeW1tZXRyaWMgPyBrZXkgOiBrZXkua2V5T2JqZWN0KTtcbiAgICB9XG5cbiAgICBpZiAoIWVLZXlNYW5hZ2VtZW50KSB7XG4gICAgICByZXR1cm4gc2lnbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IGZpZWxkcyA9IHsgYWxnOiBlS2V5TWFuYWdlbWVudCwgZW5jOiBlQ29udGVudEVuY3J5cHRpb24sIGN0eTogJ29hdXRoLWF1dGh6LXJlcStqd3QnIH07XG5cbiAgICBpZiAoZmllbGRzLmFsZy5tYXRjaCgvXihSU0F8RUNESCkvKSkge1xuICAgICAgW2tleV0gPSBhd2FpdCBxdWVyeUtleVN0b3JlLmNhbGwoXG4gICAgICAgIHRoaXMuaXNzdWVyLFxuICAgICAgICB7IGFsZzogZmllbGRzLmFsZywgdXNlOiAnZW5jJyB9LFxuICAgICAgICB7IGFsbG93TXVsdGk6IHRydWUgfSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IHRoaXMuc2VjcmV0Rm9yQWxnKGZpZWxkcy5hbGcgPT09ICdkaXInID8gZmllbGRzLmVuYyA6IGZpZWxkcy5hbGcpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgam9zZS5Db21wYWN0RW5jcnlwdChuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc2lnbmVkKSlcbiAgICAgIC5zZXRQcm90ZWN0ZWRIZWFkZXIoe1xuICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgIGtpZDoga2V5IGluc3RhbmNlb2YgVWludDhBcnJheSA/IHVuZGVmaW5lZCA6IGtleS5qd2sua2lkLFxuICAgICAgfSlcbiAgICAgIC5lbmNyeXB0KGtleSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBrZXkgOiBrZXkua2V5T2JqZWN0KTtcbiAgfVxuXG4gIGFzeW5jIHB1c2hlZEF1dGhvcml6YXRpb25SZXF1ZXN0KHBhcmFtcyA9IHt9LCB7IGNsaWVudEFzc2VydGlvblBheWxvYWQgfSA9IHt9KSB7XG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLmlzc3VlciwgJ3B1c2hlZF9hdXRob3JpemF0aW9uX3JlcXVlc3RfZW5kcG9pbnQnKTtcblxuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAuLi4oJ3JlcXVlc3QnIGluIHBhcmFtcyA/IHBhcmFtcyA6IGF1dGhvcml6YXRpb25QYXJhbXMuY2FsbCh0aGlzLCBwYXJhbXMpKSxcbiAgICAgIGNsaWVudF9pZDogdGhpcy5jbGllbnRfaWQsXG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXV0aGVudGljYXRlZFBvc3QuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncHVzaGVkX2F1dGhvcml6YXRpb25fcmVxdWVzdCcsXG4gICAgICB7XG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICBmb3JtOiBib2R5LFxuICAgICAgfSxcbiAgICAgIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCwgZW5kcG9pbnRBdXRoTWV0aG9kOiAndG9rZW4nIH0sXG4gICAgKTtcbiAgICBjb25zdCByZXNwb25zZUJvZHkgPSBwcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UsIHsgc3RhdHVzQ29kZTogMjAxIH0pO1xuXG4gICAgaWYgKCEoJ2V4cGlyZXNfaW4nIGluIHJlc3BvbnNlQm9keSkpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogJ2V4cGVjdGVkIGV4cGlyZXNfaW4gaW4gUHVzaGVkIEF1dGhvcml6YXRpb24gU3VjY2Vzc2Z1bCBSZXNwb25zZScsXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzcG9uc2VCb2R5LmV4cGlyZXNfaW4gIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6ICdpbnZhbGlkIGV4cGlyZXNfaW4gdmFsdWUgaW4gUHVzaGVkIEF1dGhvcml6YXRpb24gU3VjY2Vzc2Z1bCBSZXNwb25zZScsXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghKCdyZXF1ZXN0X3VyaScgaW4gcmVzcG9uc2VCb2R5KSkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnZXhwZWN0ZWQgcmVxdWVzdF91cmkgaW4gUHVzaGVkIEF1dGhvcml6YXRpb24gU3VjY2Vzc2Z1bCBSZXNwb25zZScsXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzcG9uc2VCb2R5LnJlcXVlc3RfdXJpICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnaW52YWxpZCByZXF1ZXN0X3VyaSB2YWx1ZSBpbiBQdXNoZWQgQXV0aG9yaXphdGlvbiBTdWNjZXNzZnVsIFJlc3BvbnNlJyxcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2VCb2R5O1xuICB9XG5cbiAgZ2V0IGlzc3VlcigpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNzdWVyO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgW2luc3BlY3QuY3VzdG9tXSgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSAke2luc3BlY3QodGhpcy5tZXRhZGF0YSwge1xuICAgICAgZGVwdGg6IEluZmluaXR5LFxuICAgICAgY29sb3JzOiBwcm9jZXNzLnN0ZG91dC5pc1RUWSxcbiAgICAgIGNvbXBhY3Q6IGZhbHNlLFxuICAgICAgc29ydGVkOiB0cnVlLFxuICAgIH0pfWA7XG4gIH1cblxuICBmYXBpKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdGQVBJMUNsaWVudCc7XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZUpBUk0ocmVzcG9uc2UpIHtcbiAgICBjb25zdCBleHBlY3RlZEFsZyA9IHRoaXMuYXV0aG9yaXphdGlvbl9zaWduZWRfcmVzcG9uc2VfYWxnO1xuICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gYXdhaXQgdGhpcy52YWxpZGF0ZUpXVChyZXNwb25zZSwgZXhwZWN0ZWRBbGcsIFsnaXNzJywgJ2V4cCcsICdhdWQnXSk7XG4gICAgcmV0dXJuIHBpY2tDYihwYXlsb2FkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBkcG9wUHJvb2ZcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhc3luYyBkcG9wUHJvb2YocGF5bG9hZCwgcHJpdmF0ZUtleUlucHV0LCBhY2Nlc3NUb2tlbikge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChwYXlsb2FkKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF5bG9hZCBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgbGV0IHByaXZhdGVLZXk7XG4gICAgaWYgKGlzS2V5T2JqZWN0KHByaXZhdGVLZXlJbnB1dCkpIHtcbiAgICAgIHByaXZhdGVLZXkgPSBwcml2YXRlS2V5SW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByaXZhdGVLZXkgPSBjcnlwdG8uY3JlYXRlUHJpdmF0ZUtleShwcml2YXRlS2V5SW5wdXQpO1xuICAgIH1cblxuICAgIGlmIChwcml2YXRlS2V5LnR5cGUgIT09ICdwcml2YXRlJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJEUG9QXCIgb3B0aW9uIG11c3QgYmUgYSBwcml2YXRlIGtleScpO1xuICAgIH1cbiAgICBsZXQgYWxnO1xuICAgIHN3aXRjaCAocHJpdmF0ZUtleS5hc3ltbWV0cmljS2V5VHlwZSkge1xuICAgICAgY2FzZSAnZWQyNTUxOSc6XG4gICAgICBjYXNlICdlZDQ0OCc6XG4gICAgICAgIGFsZyA9ICdFZERTQSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZWMnOlxuICAgICAgICBhbGcgPSBkZXRlcm1pbmVFY0FsZ29yaXRobShwcml2YXRlS2V5LCBwcml2YXRlS2V5SW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JzYSc6XG4gICAgICBjYXNlIHJzYVBzc1BhcmFtcyAmJiAncnNhLXBzcyc6XG4gICAgICAgIGFsZyA9IGRldGVybWluZVJzYUFsZ29yaXRobShcbiAgICAgICAgICBwcml2YXRlS2V5LFxuICAgICAgICAgIHByaXZhdGVLZXlJbnB1dCxcbiAgICAgICAgICB0aGlzLmlzc3Vlci5kcG9wX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQsXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5zdXBwb3J0ZWQgRFBvUCBwcml2YXRlIGtleSBhc3ltbWV0cmljIGtleSB0eXBlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFhbGcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvdWxkIG5vdCBkZXRlcm1pbmUgRFBvUCBKV1MgQWxnb3JpdGhtJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBqb3NlLlNpZ25KV1Qoe1xuICAgICAgYXRoOiBhY2Nlc3NUb2tlblxuICAgICAgICA/IGJhc2U2NHVybC5lbmNvZGUoY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShhY2Nlc3NUb2tlbikuZGlnZXN0KCkpXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgLi4ucGF5bG9hZCxcbiAgICB9KVxuICAgICAgLnNldFByb3RlY3RlZEhlYWRlcih7XG4gICAgICAgIGFsZyxcbiAgICAgICAgdHlwOiAnZHBvcCtqd3QnLFxuICAgICAgICBqd2s6IGF3YWl0IGdldEp3ayhwcml2YXRlS2V5LCBwcml2YXRlS2V5SW5wdXQpLFxuICAgICAgfSlcbiAgICAgIC5zZXRJc3N1ZWRBdCgpXG4gICAgICAuc2V0SnRpKHJhbmRvbSgpKVxuICAgICAgLnNpZ24ocHJpdmF0ZUtleSk7XG4gIH1cbn1cblxuY29uc3QgUlNQUyA9IC9eKD86UlN8UFMpKD86MjU2fDM4NHw1MTIpJC87XG5mdW5jdGlvbiBkZXRlcm1pbmVSc2FBbGdvcml0aG0ocHJpdmF0ZUtleSwgcHJpdmF0ZUtleUlucHV0LCB2YWx1ZXNTdXBwb3J0ZWQpIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBwcml2YXRlS2V5SW5wdXQgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHByaXZhdGVLZXlJbnB1dC5rZXkgPT09ICdvYmplY3QnICYmXG4gICAgcHJpdmF0ZUtleUlucHV0LmtleS5hbGdcbiAgKSB7XG4gICAgcmV0dXJuIHByaXZhdGVLZXlJbnB1dC5rZXkuYWxnO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzU3VwcG9ydGVkKSkge1xuICAgIGxldCBjYW5kaWRhdGVzID0gdmFsdWVzU3VwcG9ydGVkLmZpbHRlcihSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZChSU1BTKSk7XG4gICAgaWYgKHByaXZhdGVLZXkuYXN5bW1ldHJpY0tleVR5cGUgPT09ICdyc2EtcHNzJykge1xuICAgICAgY2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUuc3RhcnRzV2l0aCgnUFMnKSk7XG4gICAgfVxuICAgIHJldHVybiBbJ1BTMjU2JywgJ1BTMzg0JywgJ1BTNTEyJywgJ1JTMjU2JywgJ1JTMzg0JywgJ1JTMzg0J10uZmluZCgocHJlZmVycmVkKSA9PlxuICAgICAgY2FuZGlkYXRlcy5pbmNsdWRlcyhwcmVmZXJyZWQpLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gJ1BTMjU2Jztcbn1cblxuY29uc3QgcDI1NiA9IEJ1ZmZlci5mcm9tKFs0MiwgMTM0LCA3MiwgMjA2LCA2MSwgMywgMSwgN10pO1xuY29uc3QgcDM4NCA9IEJ1ZmZlci5mcm9tKFs0MywgMTI5LCA0LCAwLCAzNF0pO1xuY29uc3QgcDUyMSA9IEJ1ZmZlci5mcm9tKFs0MywgMTI5LCA0LCAwLCAzNV0pO1xuY29uc3Qgc2VjcDI1NmsxID0gQnVmZmVyLmZyb20oWzQzLCAxMjksIDQsIDAsIDEwXSk7XG5cbmZ1bmN0aW9uIGRldGVybWluZUVjQWxnb3JpdGhtKHByaXZhdGVLZXksIHByaXZhdGVLZXlJbnB1dCkge1xuICAvLyBJZiBpbnB1dCB3YXMgYSBKV0tcbiAgc3dpdGNoIChcbiAgICB0eXBlb2YgcHJpdmF0ZUtleUlucHV0ID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBwcml2YXRlS2V5SW5wdXQua2V5ID09PSAnb2JqZWN0JyAmJlxuICAgIHByaXZhdGVLZXlJbnB1dC5rZXkuY3J2XG4gICkge1xuICAgIGNhc2UgJ1AtMjU2JzpcbiAgICAgIHJldHVybiAnRVMyNTYnO1xuICAgIGNhc2UgJ3NlY3AyNTZrMSc6XG4gICAgICByZXR1cm4gJ0VTMjU2Syc7XG4gICAgY2FzZSAnUC0zODQnOlxuICAgICAgcmV0dXJuICdFUzM4NCc7XG4gICAgY2FzZSAnUC01MTInOlxuICAgICAgcmV0dXJuICdFUzUxMic7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgY29uc3QgYnVmID0gcHJpdmF0ZUtleS5leHBvcnQoeyBmb3JtYXQ6ICdkZXInLCB0eXBlOiAncGtjczgnIH0pO1xuICBjb25zdCBpID0gYnVmWzFdIDwgMTI4ID8gMTcgOiAxODtcbiAgY29uc3QgbGVuID0gYnVmW2ldO1xuICBjb25zdCBjdXJ2ZU9pZCA9IGJ1Zi5zbGljZShpICsgMSwgaSArIDEgKyBsZW4pO1xuICBpZiAoY3VydmVPaWQuZXF1YWxzKHAyNTYpKSB7XG4gICAgcmV0dXJuICdFUzI1Nic7XG4gIH1cblxuICBpZiAoY3VydmVPaWQuZXF1YWxzKHAzODQpKSB7XG4gICAgcmV0dXJuICdFUzM4NCc7XG4gIH1cbiAgaWYgKGN1cnZlT2lkLmVxdWFscyhwNTIxKSkge1xuICAgIHJldHVybiAnRVM1MTInO1xuICB9XG5cbiAgaWYgKGN1cnZlT2lkLmVxdWFscyhzZWNwMjU2azEpKSB7XG4gICAgcmV0dXJuICdFUzI1NksnO1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5zdXBwb3J0ZWQgRFBvUCBwcml2YXRlIGtleSBjdXJ2ZScpO1xufVxuXG5jb25zdCBqd2tDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5hc3luYyBmdW5jdGlvbiBnZXRKd2socHJpdmF0ZUtleSwgcHJpdmF0ZUtleUlucHV0KSB7XG4gIGlmIChcbiAgICB0eXBlb2YgcHJpdmF0ZUtleUlucHV0ID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBwcml2YXRlS2V5SW5wdXQua2V5ID09PSAnb2JqZWN0JyAmJlxuICAgIHByaXZhdGVLZXlJbnB1dC5rZXkuY3J2XG4gICkge1xuICAgIHJldHVybiBwaWNrKHByaXZhdGVLZXlJbnB1dC5rZXksICdrdHknLCAnY3J2JywgJ3gnLCAneScsICdlJywgJ24nKTtcbiAgfVxuXG4gIGlmIChqd2tDYWNoZS5oYXMocHJpdmF0ZUtleUlucHV0KSkge1xuICAgIHJldHVybiBqd2tDYWNoZS5nZXQocHJpdmF0ZUtleUlucHV0KTtcbiAgfVxuXG4gIGNvbnN0IGp3ayA9IHBpY2soYXdhaXQgam9zZS5leHBvcnRKV0socHJpdmF0ZUtleSksICdrdHknLCAnY3J2JywgJ3gnLCAneScsICdlJywgJ24nKTtcblxuICBpZiAoaXNLZXlPYmplY3QocHJpdmF0ZUtleUlucHV0KSkge1xuICAgIGp3a0NhY2hlLnNldChwcml2YXRlS2V5SW5wdXQsIGp3ayk7XG4gIH1cblxuICByZXR1cm4gandrO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChpc3N1ZXIsIGFhZElzc1ZhbGlkYXRpb24gPSBmYWxzZSkgPT5cbiAgY2xhc3MgQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgc3VwZXIoaXNzdWVyLCBhYWRJc3NWYWxpZGF0aW9uLCAuLi5hcmdzKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IGlzc3VlcigpIHtcbiAgICAgIHJldHVybiBpc3N1ZXI7XG4gICAgfVxuICB9O1xubW9kdWxlLmV4cG9ydHMuQmFzZUNsaWVudCA9IEJhc2VDbGllbnQ7XG4iXSwibmFtZXMiOlsiaW5zcGVjdCIsInJlcXVpcmUiLCJzdGRodHRwIiwiY3J5cHRvIiwic3RyaWN0IiwiYXNzZXJ0IiwicXVlcnlzdHJpbmciLCJ1cmwiLCJqb3NlIiwidG9rZW5IYXNoIiwiaXNLZXlPYmplY3QiLCJkZWNvZGVKV1QiLCJiYXNlNjR1cmwiLCJkZWZhdWx0cyIsInBhcnNlV3d3QXV0aGVudGljYXRlIiwiYXNzZXJ0U2lnbmluZ0FsZ1ZhbHVlc1N1cHBvcnQiLCJhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uIiwicGljayIsImlzUGxhaW5PYmplY3QiLCJwcm9jZXNzUmVzcG9uc2UiLCJUb2tlblNldCIsIk9QRXJyb3IiLCJSUEVycm9yIiwibm93IiwicmFuZG9tIiwicmVxdWVzdCIsIkNMT0NLX1RPTEVSQU5DRSIsImtleXN0b3JlcyIsIktleVN0b3JlIiwiY2xvbmUiLCJhdXRoZW50aWNhdGVkUG9zdCIsInJlc29sdmVSZXNwb25zZVR5cGUiLCJyZXNvbHZlUmVkaXJlY3RVcmkiLCJxdWVyeUtleVN0b3JlIiwiRGV2aWNlRmxvd0hhbmRsZSIsIm1ham9yIiwibWlub3IiLCJwcm9jZXNzIiwidmVyc2lvbiIsInNsaWNlIiwic3BsaXQiLCJtYXAiLCJzdHIiLCJwYXJzZUludCIsInJzYVBzc1BhcmFtcyIsInJldHJ5QXR0ZW1wdCIsIlN5bWJvbCIsInNraXBOb25jZUNoZWNrIiwic2tpcE1heEFnZUNoZWNrIiwicGlja0NiIiwiaW5wdXQiLCJhdXRob3JpemF0aW9uSGVhZGVyVmFsdWUiLCJ0b2tlbiIsInRva2VuVHlwZSIsInZlcmlmeVByZXNlbmNlIiwicGF5bG9hZCIsImp3dCIsInByb3AiLCJ1bmRlZmluZWQiLCJtZXNzYWdlIiwiYXV0aG9yaXphdGlvblBhcmFtcyIsInBhcmFtcyIsImF1dGhQYXJhbXMiLCJjbGllbnRfaWQiLCJzY29wZSIsInJlc3BvbnNlX3R5cGUiLCJjYWxsIiwicmVkaXJlY3RfdXJpIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJBcnJheSIsImlzQXJyYXkiLCJTdHJpbmciLCJnZXRLZXlzdG9yZSIsImp3a3MiLCJrZXlzIiwic29tZSIsImsiLCJUeXBlRXJyb3IiLCJmcm9tSldLUyIsIm9ubHlQcml2YXRlIiwiY2hlY2tCYXNpY1N1cHBvcnQiLCJjbGllbnQiLCJwcm9wZXJ0aWVzIiwic3VwcG9ydGVkIiwiaXNzdWVyIiwidG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2RzX3N1cHBvcnRlZCIsImluY2x1ZGVzIiwidG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QiLCJlcnIiLCJoYW5kbGVDb21tb25NaXN0YWtlcyIsIm1ldGFkYXRhIiwicmVkaXJlY3RfdXJpcyIsInJlc3BvbnNlX3R5cGVzIiwiZ2V0RGVmYXVsdHNGb3JFbmRwb2ludCIsImVuZHBvaW50IiwidG9rZW5FbmRwb2ludEF1dGhNZXRob2QiLCJ0b2tlbkVuZHBvaW50QXV0aFNpZ25pbmdBbGciLCJ0b2tlbl9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnIiwiZWFtIiwiZWFzYSIsIkJhc2VDbGllbnQiLCJhYWRJc3NWYWxpZGF0aW9uIiwiYWRkaXRpb25hbEF1dGhvcml6ZWRQYXJ0aWVzIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiTWFwIiwiZ3JhbnRfdHlwZXMiLCJpZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnIiwiYXV0aG9yaXphdGlvbl9zaWduZWRfcmVzcG9uc2VfYWxnIiwiZmFwaSIsInRsc19jbGllbnRfY2VydGlmaWNhdGVfYm91bmRfYWNjZXNzX3Rva2VucyIsInNldCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiZW51bWVyYWJsZSIsImtleXN0b3JlIiwiYXV0aG9yaXphdGlvblVybCIsInRhcmdldCIsInBhcnNlIiwiYXV0aG9yaXphdGlvbl9lbmRwb2ludCIsInNlYXJjaCIsInF1ZXJ5IiwiZm9ybWF0IiwiYXV0aG9yaXphdGlvblBvc3QiLCJpbnB1dHMiLCJmb3JtSW5wdXRzIiwibmFtZSIsImpvaW4iLCJlbmRTZXNzaW9uVXJsIiwicG9zdExvZ291dCIsImxlbmd0aCIsInBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaXMiLCJwb3N0X2xvZ291dF9yZWRpcmVjdF91cmkiLCJpZF90b2tlbl9oaW50IiwiaWRfdG9rZW4iLCJlbmRfc2Vzc2lvbl9lbmRwb2ludCIsImNhbGxiYWNrUGFyYW1zIiwiaXNJbmNvbWluZ01lc3NhZ2UiLCJJbmNvbWluZ01lc3NhZ2UiLCJtZXRob2QiLCJpc1N0cmluZyIsImJvZHkiLCJCdWZmZXIiLCJpc0J1ZmZlciIsInRvU3RyaW5nIiwiY2FsbGJhY2siLCJyZWRpcmVjdFVyaSIsInBhcmFtZXRlcnMiLCJjaGVja3MiLCJleGNoYW5nZUJvZHkiLCJjbGllbnRBc3NlcnRpb25QYXlsb2FkIiwiRFBvUCIsImphcm0iLCJkZWNyeXB0ZWQiLCJkZWNyeXB0SkFSTSIsInJlc3BvbnNlIiwidmFsaWRhdGVKQVJNIiwiZGVmYXVsdF9tYXhfYWdlIiwibWF4X2FnZSIsInN0YXRlIiwicHJpbnRmIiwiaXNzIiwiYXV0aG9yaXphdGlvbl9yZXNwb25zZV9pc3NfcGFyYW1ldGVyX3N1cHBvcnRlZCIsImVycm9yIiwiUkVTUE9OU0VfVFlQRV9SRVFVSVJFRF9QQVJBTVMiLCJjb2RlIiwidHlwZSIsImFjY2Vzc190b2tlbiIsInBhcmFtIiwidG9rZW5zZXQiLCJkZWNyeXB0SWRUb2tlbiIsInZhbGlkYXRlSWRUb2tlbiIsIm5vbmNlIiwiZ3JhbnQiLCJncmFudF90eXBlIiwiY29kZV92ZXJpZmllciIsInNlc3Npb25fc3RhdGUiLCJvYXV0aENhbGxiYWNrIiwiaWRfdG9rZW5fZW5jcnlwdGVkX3Jlc3BvbnNlX2FsZyIsImlkVG9rZW4iLCJleHBlY3RlZEFsZyIsImV4cGVjdGVkRW5jIiwiaWRfdG9rZW5fZW5jcnlwdGVkX3Jlc3BvbnNlX2VuYyIsInJlc3VsdCIsImRlY3J5cHRKV0UiLCJ2YWxpZGF0ZUpXVFVzZXJpbmZvIiwidXNlcmluZm9fc2lnbmVkX3Jlc3BvbnNlX2FsZyIsInZhbGlkYXRlSldUIiwiYXV0aG9yaXphdGlvbl9lbmNyeXB0ZWRfcmVzcG9uc2VfYWxnIiwiYXV0aG9yaXphdGlvbl9lbmNyeXB0ZWRfcmVzcG9uc2VfZW5jIiwiZGVjcnlwdEpXVFVzZXJpbmZvIiwidXNlcmluZm9fZW5jcnlwdGVkX3Jlc3BvbnNlX2FsZyIsInVzZXJpbmZvX2VuY3J5cHRlZF9yZXNwb25zZV9lbmMiLCJqd2UiLCJoZWFkZXIiLCJkZWNvZGUiLCJhbGciLCJlbmMiLCJnZXRQbGFpbnRleHQiLCJUZXh0RGVjb2RlciIsInBsYWludGV4dCIsIm1hdGNoIiwia2V5T2JqZWN0IiwiYWxsIiwiZGVjb2RlUHJvdGVjdGVkSGVhZGVyIiwidXNlIiwiY29tcGFjdERlY3J5cHQiLCJ0aGVuIiwic2VjcmV0Rm9yQWxnIiwidG9rZW5TZXQiLCJyZXR1cm5lZEJ5IiwibWF4QWdlIiwiaXNUb2tlblNldCIsInRpbWVzdGFtcCIsInByb3RlY3RlZCIsInJlcXVpcmVfYXV0aF90aW1lIiwiYXV0aF90aW1lIiwidG9sZXJhbmNlIiwiYXRfaGFzaCIsImNfaGFzaCIsInNfaGFzaCIsInZhbGlkYXRlIiwiY2xhaW0iLCJzb3VyY2UiLCJqd2siLCJjcnYiLCJpYXQiLCJyZXF1aXJlZCIsImlzU2VsZklzc3VlZCIsImNvbXBsZXRlIiwiYmluZCIsImV4cGVjdGVkSXNzIiwicmVwbGFjZSIsInRpZCIsIm5iZiIsImV4cCIsImF1ZCIsImF6cCIsInN1Yl9qd2siLCJpbXBvcnRKV0siLCJlcXVhbCIsImNhbGN1bGF0ZUp3a1RodW1icHJpbnQiLCJzdWIiLCJzdGFydHNXaXRoIiwidmVyaWZpZWQiLCJjb21wYWN0VmVyaWZ5IiwiVWludDhBcnJheSIsImNhdGNoIiwicHJvdGVjdGVkSGVhZGVyIiwicmVmcmVzaCIsInJlZnJlc2hUb2tlbiIsInJlZnJlc2hfdG9rZW4iLCJleHBlY3RlZFN1YiIsImNsYWltcyIsImFjdHVhbFN1YiIsInJlcXVlc3RSZXNvdXJjZSIsInJlc291cmNlVXJsIiwiYWNjZXNzVG9rZW4iLCJoZWFkZXJzIiwidG9rZW5fdHlwZSIsInJldHJ5IiwicmVxdWVzdE9wdHMiLCJBdXRob3JpemF0aW9uIiwibVRMUyIsInJlc3BvbnNlVHlwZSIsInd3d0F1dGhlbnRpY2F0ZSIsInRvTG93ZXJDYXNlIiwidXNlcmluZm8iLCJ2aWEiLCJ0b1VwcGVyQ2FzZSIsIkFjY2VwdCIsInRhcmdldFVybCIsIm10bHNfZW5kcG9pbnRfYWxpYXNlcyIsInVzZXJpbmZvX2VuZHBvaW50IiwiVVJMIiwiVVJMU2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwic2VhcmNoUGFyYW1zIiwicGFyc2VkIiwiYmVhcmVyIiwidGVzdCIsImVuY3J5cHRpb25TZWNyZXQiLCJsZW4iLCJoYXNoIiwiRXJyb3IiLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiY2xpZW50X3NlY3JldCIsImRpZ2VzdCIsIlJlZ0V4cCIsIiQxIiwiJDIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImZvcm0iLCJyZXNwb25zZUJvZHkiLCJkZXZpY2VBdXRob3JpemF0aW9uIiwiZW5kcG9pbnRBdXRoTWV0aG9kIiwicmV2b2tlIiwiaGludCIsInJldm9rZUJvZHkiLCJ0b2tlbl90eXBlX2hpbnQiLCJpbnRyb3NwZWN0IiwiaW50cm9zcGVjdEJvZHkiLCJyZWdpc3RlciIsImluaXRpYWxBY2Nlc3NUb2tlbiIsImNsaWVudE9wdGlvbnMiLCJqd2tzX3VyaSIsInRvSldLUyIsImpzb24iLCJyZWdpc3RyYXRpb25fZW5kcG9pbnQiLCJzdGF0dXNDb2RlIiwiZnJvbUVudHJpZXMiLCJmcm9tVXJpIiwicmVnaXN0cmF0aW9uQ2xpZW50VXJpIiwicmVnaXN0cmF0aW9uQWNjZXNzVG9rZW4iLCJyZXF1ZXN0T2JqZWN0Iiwic2lnbiIsInNpZ25pbmdBbGdvcml0aG0iLCJyZXF1ZXN0X29iamVjdF9zaWduaW5nX2FsZyIsImVuY3J5cHQiLCJlS2V5TWFuYWdlbWVudCIsInJlcXVlc3Rfb2JqZWN0X2VuY3J5cHRpb25fYWxnIiwiZUNvbnRlbnRFbmNyeXB0aW9uIiwicmVxdWVzdF9vYmplY3RfZW5jcnlwdGlvbl9lbmMiLCJzaWduZWQiLCJ1bml4IiwidHlwIiwianRpIiwic3ltbWV0cmljIiwiQ29tcGFjdFNpZ24iLCJzZXRQcm90ZWN0ZWRIZWFkZXIiLCJraWQiLCJmaWVsZHMiLCJjdHkiLCJhbGxvd011bHRpIiwiQ29tcGFjdEVuY3J5cHQiLCJwdXNoZWRBdXRob3JpemF0aW9uUmVxdWVzdCIsImV4cGlyZXNfaW4iLCJyZXF1ZXN0X3VyaSIsImN1c3RvbSIsImRlcHRoIiwiSW5maW5pdHkiLCJjb2xvcnMiLCJzdGRvdXQiLCJpc1RUWSIsImNvbXBhY3QiLCJzb3J0ZWQiLCJkcG9wUHJvb2YiLCJwcml2YXRlS2V5SW5wdXQiLCJwcml2YXRlS2V5IiwiY3JlYXRlUHJpdmF0ZUtleSIsImFzeW1tZXRyaWNLZXlUeXBlIiwiZGV0ZXJtaW5lRWNBbGdvcml0aG0iLCJkZXRlcm1pbmVSc2FBbGdvcml0aG0iLCJkcG9wX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQiLCJTaWduSldUIiwiYXRoIiwiZ2V0SndrIiwic2V0SXNzdWVkQXQiLCJzZXRKdGkiLCJSU1BTIiwidmFsdWVzU3VwcG9ydGVkIiwiY2FuZGlkYXRlcyIsImZpbHRlciIsInByb3RvdHlwZSIsImZpbmQiLCJwcmVmZXJyZWQiLCJwMjU2IiwiZnJvbSIsInAzODQiLCJwNTIxIiwic2VjcDI1NmsxIiwiYnVmIiwiZXhwb3J0IiwiaSIsImN1cnZlT2lkIiwiZXF1YWxzIiwiandrQ2FjaGUiLCJXZWFrTWFwIiwiaGFzIiwiZXhwb3J0SldLIiwibW9kdWxlIiwiZXhwb3J0cyIsIkNsaWVudCIsImFyZ3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/device_flow_handle.js":
/*!**************************************************************!*\
  !*** ./node_modules/openid-client/lib/device_flow_handle.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { inspect } = __webpack_require__(/*! util */ \"util\");\nconst { RPError, OPError } = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/openid-client/lib/errors.js\");\nconst now = __webpack_require__(/*! ./helpers/unix_timestamp */ \"(rsc)/./node_modules/openid-client/lib/helpers/unix_timestamp.js\");\nclass DeviceFlowHandle {\n    #aborted;\n    #client;\n    #clientAssertionPayload;\n    #DPoP;\n    #exchangeBody;\n    #expires_at;\n    #interval;\n    #maxAge;\n    #response;\n    constructor({ client, exchangeBody, clientAssertionPayload, response, maxAge, DPoP }){\n        [\n            \"verification_uri\",\n            \"user_code\",\n            \"device_code\"\n        ].forEach((prop)=>{\n            if (typeof response[prop] !== \"string\" || !response[prop]) {\n                throw new RPError(`expected ${prop} string to be returned by Device Authorization Response, got %j`, response[prop]);\n            }\n        });\n        if (!Number.isSafeInteger(response.expires_in)) {\n            throw new RPError(\"expected expires_in number to be returned by Device Authorization Response, got %j\", response.expires_in);\n        }\n        this.#expires_at = now() + response.expires_in;\n        this.#client = client;\n        this.#DPoP = DPoP;\n        this.#maxAge = maxAge;\n        this.#exchangeBody = exchangeBody;\n        this.#clientAssertionPayload = clientAssertionPayload;\n        this.#response = response;\n        this.#interval = response.interval * 1000 || 5000;\n    }\n    abort() {\n        this.#aborted = true;\n    }\n    async poll({ signal } = {}) {\n        if (signal && signal.aborted || this.#aborted) {\n            throw new RPError(\"polling aborted\");\n        }\n        if (this.expired()) {\n            throw new RPError(\"the device code %j has expired and the device authorization session has concluded\", this.device_code);\n        }\n        await new Promise((resolve)=>setTimeout(resolve, this.#interval));\n        let tokenset;\n        try {\n            tokenset = await this.#client.grant({\n                ...this.#exchangeBody,\n                grant_type: \"urn:ietf:params:oauth:grant-type:device_code\",\n                device_code: this.device_code\n            }, {\n                clientAssertionPayload: this.#clientAssertionPayload,\n                DPoP: this.#DPoP\n            });\n        } catch (err) {\n            switch(err instanceof OPError && err.error){\n                case \"slow_down\":\n                    this.#interval += 5000;\n                case \"authorization_pending\":\n                    return this.poll({\n                        signal\n                    });\n                default:\n                    throw err;\n            }\n        }\n        if (\"id_token\" in tokenset) {\n            await this.#client.decryptIdToken(tokenset);\n            await this.#client.validateIdToken(tokenset, undefined, \"token\", this.#maxAge);\n        }\n        return tokenset;\n    }\n    get device_code() {\n        return this.#response.device_code;\n    }\n    get user_code() {\n        return this.#response.user_code;\n    }\n    get verification_uri() {\n        return this.#response.verification_uri;\n    }\n    get verification_uri_complete() {\n        return this.#response.verification_uri_complete;\n    }\n    get expires_in() {\n        return Math.max.apply(null, [\n            this.#expires_at - now(),\n            0\n        ]);\n    }\n    expired() {\n        return this.expires_in === 0;\n    }\n    /* istanbul ignore next */ [inspect.custom]() {\n        return `${this.constructor.name} ${inspect(this.#response, {\n            depth: Infinity,\n            colors: process.stdout.isTTY,\n            compact: false,\n            sorted: true\n        })}`;\n    }\n}\nmodule.exports = DeviceFlowHandle;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvZGV2aWNlX2Zsb3dfaGFuZGxlLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBRUEsT0FBTyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRTVCLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDckMsTUFBTUcsTUFBTUgsbUJBQU9BLENBQUM7QUFFcEIsTUFBTUk7SUFDSixDQUFDQyxPQUFPLENBQUM7SUFDVCxDQUFDQyxNQUFNLENBQUM7SUFDUixDQUFDQyxzQkFBc0IsQ0FBQztJQUN4QixDQUFDQyxJQUFJLENBQUM7SUFDTixDQUFDQyxZQUFZLENBQUM7SUFDZCxDQUFDQyxVQUFVLENBQUM7SUFDWixDQUFDQyxRQUFRLENBQUM7SUFDVixDQUFDQyxNQUFNLENBQUM7SUFDUixDQUFDQyxRQUFRLENBQUM7SUFDVkMsWUFBWSxFQUFFUixNQUFNLEVBQUVHLFlBQVksRUFBRUYsc0JBQXNCLEVBQUVNLFFBQVEsRUFBRUQsTUFBTSxFQUFFSixJQUFJLEVBQUUsQ0FBRTtRQUNwRjtZQUFDO1lBQW9CO1lBQWE7U0FBYyxDQUFDTyxPQUFPLENBQUMsQ0FBQ0M7WUFDeEQsSUFBSSxPQUFPSCxRQUFRLENBQUNHLEtBQUssS0FBSyxZQUFZLENBQUNILFFBQVEsQ0FBQ0csS0FBSyxFQUFFO2dCQUN6RCxNQUFNLElBQUlmLFFBQ1IsQ0FBQyxTQUFTLEVBQUVlLEtBQUssK0RBQStELENBQUMsRUFDakZILFFBQVEsQ0FBQ0csS0FBSztZQUVsQjtRQUNGO1FBRUEsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNMLFNBQVNNLFVBQVUsR0FBRztZQUM5QyxNQUFNLElBQUlsQixRQUNSLHNGQUNBWSxTQUFTTSxVQUFVO1FBRXZCO1FBRUEsSUFBSSxDQUFDLENBQUNULFVBQVUsR0FBR1AsUUFBUVUsU0FBU00sVUFBVTtRQUM5QyxJQUFJLENBQUMsQ0FBQ2IsTUFBTSxHQUFHQTtRQUNmLElBQUksQ0FBQyxDQUFDRSxJQUFJLEdBQUdBO1FBQ2IsSUFBSSxDQUFDLENBQUNJLE1BQU0sR0FBR0E7UUFDZixJQUFJLENBQUMsQ0FBQ0gsWUFBWSxHQUFHQTtRQUNyQixJQUFJLENBQUMsQ0FBQ0Ysc0JBQXNCLEdBQUdBO1FBQy9CLElBQUksQ0FBQyxDQUFDTSxRQUFRLEdBQUdBO1FBQ2pCLElBQUksQ0FBQyxDQUFDRixRQUFRLEdBQUdFLFNBQVNGLFFBQVEsR0FBRyxRQUFRO0lBQy9DO0lBRUFTLFFBQVE7UUFDTixJQUFJLENBQUMsQ0FBQ2YsT0FBTyxHQUFHO0lBQ2xCO0lBRUEsTUFBTWdCLEtBQUssRUFBRUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDMUIsSUFBSSxVQUFXQSxPQUFPakIsT0FBTyxJQUFLLElBQUksQ0FBQyxDQUFDQSxPQUFPLEVBQUU7WUFDL0MsTUFBTSxJQUFJSixRQUFRO1FBQ3BCO1FBRUEsSUFBSSxJQUFJLENBQUNzQixPQUFPLElBQUk7WUFDbEIsTUFBTSxJQUFJdEIsUUFDUixxRkFDQSxJQUFJLENBQUN1QixXQUFXO1FBRXBCO1FBRUEsTUFBTSxJQUFJQyxRQUFRLENBQUNDLFVBQVlDLFdBQVdELFNBQVMsSUFBSSxDQUFDLENBQUNmLFFBQVE7UUFFakUsSUFBSWlCO1FBQ0osSUFBSTtZQUNGQSxXQUFXLE1BQU0sSUFBSSxDQUFDLENBQUN0QixNQUFNLENBQUN1QixLQUFLLENBQ2pDO2dCQUNFLEdBQUcsSUFBSSxDQUFDLENBQUNwQixZQUFZO2dCQUNyQnFCLFlBQVk7Z0JBQ1pOLGFBQWEsSUFBSSxDQUFDQSxXQUFXO1lBQy9CLEdBQ0E7Z0JBQUVqQix3QkFBd0IsSUFBSSxDQUFDLENBQUNBLHNCQUFzQjtnQkFBRUMsTUFBTSxJQUFJLENBQUMsQ0FBQ0EsSUFBSTtZQUFDO1FBRTdFLEVBQUUsT0FBT3VCLEtBQUs7WUFDWixPQUFRQSxlQUFlN0IsV0FBVzZCLElBQUlDLEtBQUs7Z0JBQ3pDLEtBQUs7b0JBQ0gsSUFBSSxDQUFDLENBQUNyQixRQUFRLElBQUk7Z0JBQ3BCLEtBQUs7b0JBQ0gsT0FBTyxJQUFJLENBQUNVLElBQUksQ0FBQzt3QkFBRUM7b0JBQU87Z0JBQzVCO29CQUNFLE1BQU1TO1lBQ1Y7UUFDRjtRQUVBLElBQUksY0FBY0gsVUFBVTtZQUMxQixNQUFNLElBQUksQ0FBQyxDQUFDdEIsTUFBTSxDQUFDMkIsY0FBYyxDQUFDTDtZQUNsQyxNQUFNLElBQUksQ0FBQyxDQUFDdEIsTUFBTSxDQUFDNEIsZUFBZSxDQUFDTixVQUFVTyxXQUFXLFNBQVMsSUFBSSxDQUFDLENBQUN2QixNQUFNO1FBQy9FO1FBRUEsT0FBT2dCO0lBQ1Q7SUFFQSxJQUFJSixjQUFjO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLENBQUNYLFFBQVEsQ0FBQ1csV0FBVztJQUNuQztJQUVBLElBQUlZLFlBQVk7UUFDZCxPQUFPLElBQUksQ0FBQyxDQUFDdkIsUUFBUSxDQUFDdUIsU0FBUztJQUNqQztJQUVBLElBQUlDLG1CQUFtQjtRQUNyQixPQUFPLElBQUksQ0FBQyxDQUFDeEIsUUFBUSxDQUFDd0IsZ0JBQWdCO0lBQ3hDO0lBRUEsSUFBSUMsNEJBQTRCO1FBQzlCLE9BQU8sSUFBSSxDQUFDLENBQUN6QixRQUFRLENBQUN5Qix5QkFBeUI7SUFDakQ7SUFFQSxJQUFJbkIsYUFBYTtRQUNmLE9BQU9vQixLQUFLQyxHQUFHLENBQUNDLEtBQUssQ0FBQyxNQUFNO1lBQUMsSUFBSSxDQUFDLENBQUMvQixVQUFVLEdBQUdQO1lBQU87U0FBRTtJQUMzRDtJQUVBb0IsVUFBVTtRQUNSLE9BQU8sSUFBSSxDQUFDSixVQUFVLEtBQUs7SUFDN0I7SUFFQSx3QkFBd0IsR0FDeEIsQ0FBQ3BCLFFBQVEyQyxNQUFNLENBQUMsR0FBRztRQUNqQixPQUFPLENBQUMsRUFBRSxJQUFJLENBQUM1QixXQUFXLENBQUM2QixJQUFJLENBQUMsQ0FBQyxFQUFFNUMsUUFBUSxJQUFJLENBQUMsQ0FBQ2MsUUFBUSxFQUFFO1lBQ3pEK0IsT0FBT0M7WUFDUEMsUUFBUUMsUUFBUUMsTUFBTSxDQUFDQyxLQUFLO1lBQzVCQyxTQUFTO1lBQ1RDLFFBQVE7UUFDVixHQUFHLENBQUM7SUFDTjtBQUNGO0FBRUFDLE9BQU9DLE9BQU8sR0FBR2pEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hdXRoLXJlZ2lzdGVyLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2RldmljZV9mbG93X2hhbmRsZS5qcz83Mzc2Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgaW5zcGVjdCB9ID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jb25zdCB7IFJQRXJyb3IsIE9QRXJyb3IgfSA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBub3cgPSByZXF1aXJlKCcuL2hlbHBlcnMvdW5peF90aW1lc3RhbXAnKTtcblxuY2xhc3MgRGV2aWNlRmxvd0hhbmRsZSB7XG4gICNhYm9ydGVkO1xuICAjY2xpZW50O1xuICAjY2xpZW50QXNzZXJ0aW9uUGF5bG9hZDtcbiAgI0RQb1A7XG4gICNleGNoYW5nZUJvZHk7XG4gICNleHBpcmVzX2F0O1xuICAjaW50ZXJ2YWw7XG4gICNtYXhBZ2U7XG4gICNyZXNwb25zZTtcbiAgY29uc3RydWN0b3IoeyBjbGllbnQsIGV4Y2hhbmdlQm9keSwgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCwgcmVzcG9uc2UsIG1heEFnZSwgRFBvUCB9KSB7XG4gICAgWyd2ZXJpZmljYXRpb25fdXJpJywgJ3VzZXJfY29kZScsICdkZXZpY2VfY29kZSddLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2VbcHJvcF0gIT09ICdzdHJpbmcnIHx8ICFyZXNwb25zZVtwcm9wXSkge1xuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcihcbiAgICAgICAgICBgZXhwZWN0ZWQgJHtwcm9wfSBzdHJpbmcgdG8gYmUgcmV0dXJuZWQgYnkgRGV2aWNlIEF1dGhvcml6YXRpb24gUmVzcG9uc2UsIGdvdCAlamAsXG4gICAgICAgICAgcmVzcG9uc2VbcHJvcF0sXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHJlc3BvbnNlLmV4cGlyZXNfaW4pKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcihcbiAgICAgICAgJ2V4cGVjdGVkIGV4cGlyZXNfaW4gbnVtYmVyIHRvIGJlIHJldHVybmVkIGJ5IERldmljZSBBdXRob3JpemF0aW9uIFJlc3BvbnNlLCBnb3QgJWonLFxuICAgICAgICByZXNwb25zZS5leHBpcmVzX2luLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLiNleHBpcmVzX2F0ID0gbm93KCkgKyByZXNwb25zZS5leHBpcmVzX2luO1xuICAgIHRoaXMuI2NsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLiNEUG9QID0gRFBvUDtcbiAgICB0aGlzLiNtYXhBZ2UgPSBtYXhBZ2U7XG4gICAgdGhpcy4jZXhjaGFuZ2VCb2R5ID0gZXhjaGFuZ2VCb2R5O1xuICAgIHRoaXMuI2NsaWVudEFzc2VydGlvblBheWxvYWQgPSBjbGllbnRBc3NlcnRpb25QYXlsb2FkO1xuICAgIHRoaXMuI3Jlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgdGhpcy4jaW50ZXJ2YWwgPSByZXNwb25zZS5pbnRlcnZhbCAqIDEwMDAgfHwgNTAwMDtcbiAgfVxuXG4gIGFib3J0KCkge1xuICAgIHRoaXMuI2Fib3J0ZWQgPSB0cnVlO1xuICB9XG5cbiAgYXN5bmMgcG9sbCh7IHNpZ25hbCB9ID0ge30pIHtcbiAgICBpZiAoKHNpZ25hbCAmJiBzaWduYWwuYWJvcnRlZCkgfHwgdGhpcy4jYWJvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3IoJ3BvbGxpbmcgYWJvcnRlZCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmV4cGlyZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3IoXG4gICAgICAgICd0aGUgZGV2aWNlIGNvZGUgJWogaGFzIGV4cGlyZWQgYW5kIHRoZSBkZXZpY2UgYXV0aG9yaXphdGlvbiBzZXNzaW9uIGhhcyBjb25jbHVkZWQnLFxuICAgICAgICB0aGlzLmRldmljZV9jb2RlLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aGlzLiNpbnRlcnZhbCkpO1xuXG4gICAgbGV0IHRva2Vuc2V0O1xuICAgIHRyeSB7XG4gICAgICB0b2tlbnNldCA9IGF3YWl0IHRoaXMuI2NsaWVudC5ncmFudChcbiAgICAgICAge1xuICAgICAgICAgIC4uLnRoaXMuI2V4Y2hhbmdlQm9keSxcbiAgICAgICAgICBncmFudF90eXBlOiAndXJuOmlldGY6cGFyYW1zOm9hdXRoOmdyYW50LXR5cGU6ZGV2aWNlX2NvZGUnLFxuICAgICAgICAgIGRldmljZV9jb2RlOiB0aGlzLmRldmljZV9jb2RlLFxuICAgICAgICB9LFxuICAgICAgICB7IGNsaWVudEFzc2VydGlvblBheWxvYWQ6IHRoaXMuI2NsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1A6IHRoaXMuI0RQb1AgfSxcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzd2l0Y2ggKGVyciBpbnN0YW5jZW9mIE9QRXJyb3IgJiYgZXJyLmVycm9yKSB7XG4gICAgICAgIGNhc2UgJ3Nsb3dfZG93bic6XG4gICAgICAgICAgdGhpcy4jaW50ZXJ2YWwgKz0gNTAwMDtcbiAgICAgICAgY2FzZSAnYXV0aG9yaXphdGlvbl9wZW5kaW5nJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wb2xsKHsgc2lnbmFsIH0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJ2lkX3Rva2VuJyBpbiB0b2tlbnNldCkge1xuICAgICAgYXdhaXQgdGhpcy4jY2xpZW50LmRlY3J5cHRJZFRva2VuKHRva2Vuc2V0KTtcbiAgICAgIGF3YWl0IHRoaXMuI2NsaWVudC52YWxpZGF0ZUlkVG9rZW4odG9rZW5zZXQsIHVuZGVmaW5lZCwgJ3Rva2VuJywgdGhpcy4jbWF4QWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9rZW5zZXQ7XG4gIH1cblxuICBnZXQgZGV2aWNlX2NvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Jlc3BvbnNlLmRldmljZV9jb2RlO1xuICB9XG5cbiAgZ2V0IHVzZXJfY29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVzcG9uc2UudXNlcl9jb2RlO1xuICB9XG5cbiAgZ2V0IHZlcmlmaWNhdGlvbl91cmkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Jlc3BvbnNlLnZlcmlmaWNhdGlvbl91cmk7XG4gIH1cblxuICBnZXQgdmVyaWZpY2F0aW9uX3VyaV9jb21wbGV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVzcG9uc2UudmVyaWZpY2F0aW9uX3VyaV9jb21wbGV0ZTtcbiAgfVxuXG4gIGdldCBleHBpcmVzX2luKCkge1xuICAgIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBbdGhpcy4jZXhwaXJlc19hdCAtIG5vdygpLCAwXSk7XG4gIH1cblxuICBleHBpcmVkKCkge1xuICAgIHJldHVybiB0aGlzLmV4cGlyZXNfaW4gPT09IDA7XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBbaW5zcGVjdC5jdXN0b21dKCkge1xuICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9ICR7aW5zcGVjdCh0aGlzLiNyZXNwb25zZSwge1xuICAgICAgZGVwdGg6IEluZmluaXR5LFxuICAgICAgY29sb3JzOiBwcm9jZXNzLnN0ZG91dC5pc1RUWSxcbiAgICAgIGNvbXBhY3Q6IGZhbHNlLFxuICAgICAgc29ydGVkOiB0cnVlLFxuICAgIH0pfWA7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEZXZpY2VGbG93SGFuZGxlO1xuIl0sIm5hbWVzIjpbImluc3BlY3QiLCJyZXF1aXJlIiwiUlBFcnJvciIsIk9QRXJyb3IiLCJub3ciLCJEZXZpY2VGbG93SGFuZGxlIiwiYWJvcnRlZCIsImNsaWVudCIsImNsaWVudEFzc2VydGlvblBheWxvYWQiLCJEUG9QIiwiZXhjaGFuZ2VCb2R5IiwiZXhwaXJlc19hdCIsImludGVydmFsIiwibWF4QWdlIiwicmVzcG9uc2UiLCJjb25zdHJ1Y3RvciIsImZvckVhY2giLCJwcm9wIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsImV4cGlyZXNfaW4iLCJhYm9ydCIsInBvbGwiLCJzaWduYWwiLCJleHBpcmVkIiwiZGV2aWNlX2NvZGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJ0b2tlbnNldCIsImdyYW50IiwiZ3JhbnRfdHlwZSIsImVyciIsImVycm9yIiwiZGVjcnlwdElkVG9rZW4iLCJ2YWxpZGF0ZUlkVG9rZW4iLCJ1bmRlZmluZWQiLCJ1c2VyX2NvZGUiLCJ2ZXJpZmljYXRpb25fdXJpIiwidmVyaWZpY2F0aW9uX3VyaV9jb21wbGV0ZSIsIk1hdGgiLCJtYXgiLCJhcHBseSIsImN1c3RvbSIsIm5hbWUiLCJkZXB0aCIsIkluZmluaXR5IiwiY29sb3JzIiwicHJvY2VzcyIsInN0ZG91dCIsImlzVFRZIiwiY29tcGFjdCIsInNvcnRlZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/device_flow_handle.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/errors.js":
/*!**************************************************!*\
  !*** ./node_modules/openid-client/lib/errors.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { format } = __webpack_require__(/*! util */ \"util\");\nclass OPError extends Error {\n    constructor({ error_description, error, error_uri, session_state, state, scope }, response){\n        super(!error_description ? error : `${error} (${error_description})`);\n        Object.assign(this, {\n            error\n        }, error_description && {\n            error_description\n        }, error_uri && {\n            error_uri\n        }, state && {\n            state\n        }, scope && {\n            scope\n        }, session_state && {\n            session_state\n        });\n        if (response) {\n            Object.defineProperty(this, \"response\", {\n                value: response\n            });\n        }\n        this.name = this.constructor.name;\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\nclass RPError extends Error {\n    constructor(...args){\n        if (typeof args[0] === \"string\") {\n            super(format(...args));\n        } else {\n            const { message, printf, response, ...rest } = args[0];\n            if (printf) {\n                super(format(...printf));\n            } else {\n                super(message);\n            }\n            Object.assign(this, rest);\n            if (response) {\n                Object.defineProperty(this, \"response\", {\n                    value: response\n                });\n            }\n        }\n        this.name = this.constructor.name;\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\nmodule.exports = {\n    OPError,\n    RPError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBRUEsTUFBTSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRTNCLE1BQU1DLGdCQUFnQkM7SUFDcEJDLFlBQVksRUFBRUMsaUJBQWlCLEVBQUVDLEtBQUssRUFBRUMsU0FBUyxFQUFFQyxhQUFhLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFLEVBQUVDLFFBQVEsQ0FBRTtRQUMxRixLQUFLLENBQUMsQ0FBQ04sb0JBQW9CQyxRQUFRLENBQUMsRUFBRUEsTUFBTSxFQUFFLEVBQUVELGtCQUFrQixDQUFDLENBQUM7UUFFcEVPLE9BQU9DLE1BQU0sQ0FDWCxJQUFJLEVBQ0o7WUFBRVA7UUFBTSxHQUNSRCxxQkFBcUI7WUFBRUE7UUFBa0IsR0FDekNFLGFBQWE7WUFBRUE7UUFBVSxHQUN6QkUsU0FBUztZQUFFQTtRQUFNLEdBQ2pCQyxTQUFTO1lBQUVBO1FBQU0sR0FDakJGLGlCQUFpQjtZQUFFQTtRQUFjO1FBR25DLElBQUlHLFVBQVU7WUFDWkMsT0FBT0UsY0FBYyxDQUFDLElBQUksRUFBRSxZQUFZO2dCQUN0Q0MsT0FBT0o7WUFDVDtRQUNGO1FBRUEsSUFBSSxDQUFDSyxJQUFJLEdBQUcsSUFBSSxDQUFDWixXQUFXLENBQUNZLElBQUk7UUFDakNiLE1BQU1jLGlCQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUNiLFdBQVc7SUFDaEQ7QUFDRjtBQUVBLE1BQU1jLGdCQUFnQmY7SUFDcEJDLFlBQVksR0FBR2UsSUFBSSxDQUFFO1FBQ25CLElBQUksT0FBT0EsSUFBSSxDQUFDLEVBQUUsS0FBSyxVQUFVO1lBQy9CLEtBQUssQ0FBQ25CLFVBQVVtQjtRQUNsQixPQUFPO1lBQ0wsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRVYsUUFBUSxFQUFFLEdBQUdXLE1BQU0sR0FBR0gsSUFBSSxDQUFDLEVBQUU7WUFDdEQsSUFBSUUsUUFBUTtnQkFDVixLQUFLLENBQUNyQixVQUFVcUI7WUFDbEIsT0FBTztnQkFDTCxLQUFLLENBQUNEO1lBQ1I7WUFDQVIsT0FBT0MsTUFBTSxDQUFDLElBQUksRUFBRVM7WUFDcEIsSUFBSVgsVUFBVTtnQkFDWkMsT0FBT0UsY0FBYyxDQUFDLElBQUksRUFBRSxZQUFZO29CQUN0Q0MsT0FBT0o7Z0JBQ1Q7WUFDRjtRQUNGO1FBRUEsSUFBSSxDQUFDSyxJQUFJLEdBQUcsSUFBSSxDQUFDWixXQUFXLENBQUNZLElBQUk7UUFDakNiLE1BQU1jLGlCQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUNiLFdBQVc7SUFDaEQ7QUFDRjtBQUVBbUIsT0FBT0MsT0FBTyxHQUFHO0lBQ2Z0QjtJQUNBZ0I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXV0aC1yZWdpc3Rlci8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9lcnJvcnMuanM/YTc0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGZvcm1hdCB9ID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jbGFzcyBPUEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IGVycm9yX2Rlc2NyaXB0aW9uLCBlcnJvciwgZXJyb3JfdXJpLCBzZXNzaW9uX3N0YXRlLCBzdGF0ZSwgc2NvcGUgfSwgcmVzcG9uc2UpIHtcbiAgICBzdXBlcighZXJyb3JfZGVzY3JpcHRpb24gPyBlcnJvciA6IGAke2Vycm9yfSAoJHtlcnJvcl9kZXNjcmlwdGlvbn0pYCk7XG5cbiAgICBPYmplY3QuYXNzaWduKFxuICAgICAgdGhpcyxcbiAgICAgIHsgZXJyb3IgfSxcbiAgICAgIGVycm9yX2Rlc2NyaXB0aW9uICYmIHsgZXJyb3JfZGVzY3JpcHRpb24gfSxcbiAgICAgIGVycm9yX3VyaSAmJiB7IGVycm9yX3VyaSB9LFxuICAgICAgc3RhdGUgJiYgeyBzdGF0ZSB9LFxuICAgICAgc2NvcGUgJiYgeyBzY29wZSB9LFxuICAgICAgc2Vzc2lvbl9zdGF0ZSAmJiB7IHNlc3Npb25fc3RhdGUgfSxcbiAgICApO1xuXG4gICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Jlc3BvbnNlJywge1xuICAgICAgICB2YWx1ZTogcmVzcG9uc2UsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH1cbn1cblxuY2xhc3MgUlBFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHN1cGVyKGZvcm1hdCguLi5hcmdzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZSwgcHJpbnRmLCByZXNwb25zZSwgLi4ucmVzdCB9ID0gYXJnc1swXTtcbiAgICAgIGlmIChwcmludGYpIHtcbiAgICAgICAgc3VwZXIoZm9ybWF0KC4uLnByaW50ZikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHJlc3QpO1xuICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVzcG9uc2UnLCB7XG4gICAgICAgICAgdmFsdWU6IHJlc3BvbnNlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE9QRXJyb3IsXG4gIFJQRXJyb3IsXG59O1xuIl0sIm5hbWVzIjpbImZvcm1hdCIsInJlcXVpcmUiLCJPUEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImVycm9yX2Rlc2NyaXB0aW9uIiwiZXJyb3IiLCJlcnJvcl91cmkiLCJzZXNzaW9uX3N0YXRlIiwic3RhdGUiLCJzY29wZSIsInJlc3BvbnNlIiwiT2JqZWN0IiwiYXNzaWduIiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsIm5hbWUiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIlJQRXJyb3IiLCJhcmdzIiwibWVzc2FnZSIsInByaW50ZiIsInJlc3QiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/assert.js":
/*!**********************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/assert.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("function assertSigningAlgValuesSupport(endpoint, issuer, properties) {\n    if (!issuer[`${endpoint}_endpoint`]) return;\n    const eam = `${endpoint}_endpoint_auth_method`;\n    const easa = `${endpoint}_endpoint_auth_signing_alg`;\n    const easavs = `${endpoint}_endpoint_auth_signing_alg_values_supported`;\n    if (properties[eam] && properties[eam].endsWith(\"_jwt\") && !properties[easa] && !issuer[easavs]) {\n        throw new TypeError(`${easavs} must be configured on the issuer if ${easa} is not defined on a client`);\n    }\n}\nfunction assertIssuerConfiguration(issuer, endpoint) {\n    if (!issuer[endpoint]) {\n        throw new TypeError(`${endpoint} must be configured on the issuer`);\n    }\n}\nmodule.exports = {\n    assertSigningAlgValuesSupport,\n    assertIssuerConfiguration\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWF1dGgtcmVnaXN0ZXIvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9hc3NlcnQuanM/YWQyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBhc3NlcnRTaWduaW5nQWxnVmFsdWVzU3VwcG9ydChlbmRwb2ludCwgaXNzdWVyLCBwcm9wZXJ0aWVzKSB7XG4gIGlmICghaXNzdWVyW2Ake2VuZHBvaW50fV9lbmRwb2ludGBdKSByZXR1cm47XG5cbiAgY29uc3QgZWFtID0gYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfbWV0aG9kYDtcbiAgY29uc3QgZWFzYSA9IGAke2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnYDtcbiAgY29uc3QgZWFzYXZzID0gYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZGA7XG5cbiAgaWYgKHByb3BlcnRpZXNbZWFtXSAmJiBwcm9wZXJ0aWVzW2VhbV0uZW5kc1dpdGgoJ19qd3QnKSAmJiAhcHJvcGVydGllc1tlYXNhXSAmJiAhaXNzdWVyW2Vhc2F2c10pIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgYCR7ZWFzYXZzfSBtdXN0IGJlIGNvbmZpZ3VyZWQgb24gdGhlIGlzc3VlciBpZiAke2Vhc2F9IGlzIG5vdCBkZWZpbmVkIG9uIGEgY2xpZW50YCxcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24oaXNzdWVyLCBlbmRwb2ludCkge1xuICBpZiAoIWlzc3VlcltlbmRwb2ludF0pIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2VuZHBvaW50fSBtdXN0IGJlIGNvbmZpZ3VyZWQgb24gdGhlIGlzc3VlcmApO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhc3NlcnRTaWduaW5nQWxnVmFsdWVzU3VwcG9ydCxcbiAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbixcbn07XG4iXSwibmFtZXMiOlsiYXNzZXJ0U2lnbmluZ0FsZ1ZhbHVlc1N1cHBvcnQiLCJlbmRwb2ludCIsImlzc3VlciIsInByb3BlcnRpZXMiLCJlYW0iLCJlYXNhIiwiZWFzYXZzIiwiZW5kc1dpdGgiLCJUeXBlRXJyb3IiLCJhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0EsOEJBQThCQyxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsVUFBVTtJQUNqRSxJQUFJLENBQUNELE1BQU0sQ0FBQyxDQUFDLEVBQUVELFNBQVMsU0FBUyxDQUFDLENBQUMsRUFBRTtJQUVyQyxNQUFNRyxNQUFNLENBQUMsRUFBRUgsU0FBUyxxQkFBcUIsQ0FBQztJQUM5QyxNQUFNSSxPQUFPLENBQUMsRUFBRUosU0FBUywwQkFBMEIsQ0FBQztJQUNwRCxNQUFNSyxTQUFTLENBQUMsRUFBRUwsU0FBUywyQ0FBMkMsQ0FBQztJQUV2RSxJQUFJRSxVQUFVLENBQUNDLElBQUksSUFBSUQsVUFBVSxDQUFDQyxJQUFJLENBQUNHLFFBQVEsQ0FBQyxXQUFXLENBQUNKLFVBQVUsQ0FBQ0UsS0FBSyxJQUFJLENBQUNILE1BQU0sQ0FBQ0ksT0FBTyxFQUFFO1FBQy9GLE1BQU0sSUFBSUUsVUFDUixDQUFDLEVBQUVGLE9BQU8scUNBQXFDLEVBQUVELEtBQUssMkJBQTJCLENBQUM7SUFFdEY7QUFDRjtBQUVBLFNBQVNJLDBCQUEwQlAsTUFBTSxFQUFFRCxRQUFRO0lBQ2pELElBQUksQ0FBQ0MsTUFBTSxDQUFDRCxTQUFTLEVBQUU7UUFDckIsTUFBTSxJQUFJTyxVQUFVLENBQUMsRUFBRVAsU0FBUyxpQ0FBaUMsQ0FBQztJQUNwRTtBQUNGO0FBRUFTLE9BQU9DLE9BQU8sR0FBRztJQUNmWDtJQUNBUztBQUNGIiwiZmlsZSI6Iihyc2MpLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvYXNzZXJ0LmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/assert.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/base64url.js":
/*!*************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/base64url.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("let encode;\nif (Buffer.isEncoding(\"base64url\")) {\n    encode = (input, encoding = \"utf8\")=>Buffer.from(input, encoding).toString(\"base64url\");\n} else {\n    const fromBase64 = (base64)=>base64.replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n    encode = (input, encoding = \"utf8\")=>fromBase64(Buffer.from(input, encoding).toString(\"base64\"));\n}\nconst decode = (input)=>Buffer.from(input, \"base64\");\nmodule.exports.decode = decode;\nmodule.exports.encode = encode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9iYXNlNjR1cmwuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUE7QUFDSixJQUFJQyxPQUFPQyxVQUFVLENBQUMsY0FBYztJQUNsQ0YsU0FBUyxDQUFDRyxPQUFPQyxXQUFXLE1BQU0sR0FBS0gsT0FBT0ksSUFBSSxDQUFDRixPQUFPQyxVQUFVRSxRQUFRLENBQUM7QUFDL0UsT0FBTztJQUNMLE1BQU1DLGFBQWEsQ0FBQ0MsU0FBV0EsT0FBT0MsT0FBTyxDQUFDLE1BQU0sSUFBSUEsT0FBTyxDQUFDLE9BQU8sS0FBS0EsT0FBTyxDQUFDLE9BQU87SUFDM0ZULFNBQVMsQ0FBQ0csT0FBT0MsV0FBVyxNQUFNLEdBQ2hDRyxXQUFXTixPQUFPSSxJQUFJLENBQUNGLE9BQU9DLFVBQVVFLFFBQVEsQ0FBQztBQUNyRDtBQUVBLE1BQU1JLFNBQVMsQ0FBQ1AsUUFBVUYsT0FBT0ksSUFBSSxDQUFDRixPQUFPO0FBRTdDUSxxQkFBcUIsR0FBR0Q7QUFDeEJDLHFCQUFxQixHQUFHWCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXV0aC1yZWdpc3Rlci8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL2Jhc2U2NHVybC5qcz8zYjVlIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBlbmNvZGU7XG5pZiAoQnVmZmVyLmlzRW5jb2RpbmcoJ2Jhc2U2NHVybCcpKSB7XG4gIGVuY29kZSA9IChpbnB1dCwgZW5jb2RpbmcgPSAndXRmOCcpID0+IEJ1ZmZlci5mcm9tKGlucHV0LCBlbmNvZGluZykudG9TdHJpbmcoJ2Jhc2U2NHVybCcpO1xufSBlbHNlIHtcbiAgY29uc3QgZnJvbUJhc2U2NCA9IChiYXNlNjQpID0+IGJhc2U2NC5yZXBsYWNlKC89L2csICcnKS5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKTtcbiAgZW5jb2RlID0gKGlucHV0LCBlbmNvZGluZyA9ICd1dGY4JykgPT5cbiAgICBmcm9tQmFzZTY0KEJ1ZmZlci5mcm9tKGlucHV0LCBlbmNvZGluZykudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbn1cblxuY29uc3QgZGVjb2RlID0gKGlucHV0KSA9PiBCdWZmZXIuZnJvbShpbnB1dCwgJ2Jhc2U2NCcpO1xuXG5tb2R1bGUuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5tb2R1bGUuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4iXSwibmFtZXMiOlsiZW5jb2RlIiwiQnVmZmVyIiwiaXNFbmNvZGluZyIsImlucHV0IiwiZW5jb2RpbmciLCJmcm9tIiwidG9TdHJpbmciLCJmcm9tQmFzZTY0IiwiYmFzZTY0IiwicmVwbGFjZSIsImRlY29kZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/base64url.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/client.js":
/*!**********************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/client.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const jose = __webpack_require__(/*! jose */ \"(rsc)/./node_modules/jose/dist/node/cjs/index.js\");\nconst { RPError } = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/openid-client/lib/errors.js\");\nconst { assertIssuerConfiguration } = __webpack_require__(/*! ./assert */ \"(rsc)/./node_modules/openid-client/lib/helpers/assert.js\");\nconst { random } = __webpack_require__(/*! ./generators */ \"(rsc)/./node_modules/openid-client/lib/helpers/generators.js\");\nconst now = __webpack_require__(/*! ./unix_timestamp */ \"(rsc)/./node_modules/openid-client/lib/helpers/unix_timestamp.js\");\nconst request = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/openid-client/lib/helpers/request.js\");\nconst { keystores } = __webpack_require__(/*! ./weak_cache */ \"(rsc)/./node_modules/openid-client/lib/helpers/weak_cache.js\");\nconst merge = __webpack_require__(/*! ./merge */ \"(rsc)/./node_modules/openid-client/lib/helpers/merge.js\");\nconst formUrlEncode = (value)=>encodeURIComponent(value).replace(/%20/g, \"+\");\nasync function clientAssertion(endpoint, payload) {\n    let alg = this[`${endpoint}_endpoint_auth_signing_alg`];\n    if (!alg) {\n        assertIssuerConfiguration(this.issuer, `${endpoint}_endpoint_auth_signing_alg_values_supported`);\n    }\n    if (this[`${endpoint}_endpoint_auth_method`] === \"client_secret_jwt\") {\n        if (!alg) {\n            const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n            alg = Array.isArray(supported) && supported.find((signAlg)=>/^HS(?:256|384|512)/.test(signAlg));\n        }\n        if (!alg) {\n            throw new RPError(`failed to determine a JWS Algorithm to use for ${this[`${endpoint}_endpoint_auth_method`]} Client Assertion`);\n        }\n        return new jose.CompactSign(Buffer.from(JSON.stringify(payload))).setProtectedHeader({\n            alg\n        }).sign(this.secretForAlg(alg));\n    }\n    const keystore = await keystores.get(this);\n    if (!keystore) {\n        throw new TypeError(\"no client jwks provided for signing a client assertion with\");\n    }\n    if (!alg) {\n        const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n        alg = Array.isArray(supported) && supported.find((signAlg)=>keystore.get({\n                alg: signAlg,\n                use: \"sig\"\n            }));\n    }\n    if (!alg) {\n        throw new RPError(`failed to determine a JWS Algorithm to use for ${this[`${endpoint}_endpoint_auth_method`]} Client Assertion`);\n    }\n    const key = keystore.get({\n        alg,\n        use: \"sig\"\n    });\n    if (!key) {\n        throw new RPError(`no key found in client jwks to sign a client assertion with using alg ${alg}`);\n    }\n    return new jose.CompactSign(Buffer.from(JSON.stringify(payload))).setProtectedHeader({\n        alg,\n        kid: key.jwk && key.jwk.kid\n    }).sign(key.keyObject);\n}\nasync function authFor(endpoint, { clientAssertionPayload } = {}) {\n    const authMethod = this[`${endpoint}_endpoint_auth_method`];\n    switch(authMethod){\n        case \"self_signed_tls_client_auth\":\n        case \"tls_client_auth\":\n        case \"none\":\n            return {\n                form: {\n                    client_id: this.client_id\n                }\n            };\n        case \"client_secret_post\":\n            if (typeof this.client_secret !== \"string\") {\n                throw new TypeError(\"client_secret_post client authentication method requires a client_secret\");\n            }\n            return {\n                form: {\n                    client_id: this.client_id,\n                    client_secret: this.client_secret\n                }\n            };\n        case \"private_key_jwt\":\n        case \"client_secret_jwt\":\n            {\n                const timestamp = now();\n                const audience = [\n                    ...new Set([\n                        this.issuer.issuer,\n                        this.issuer.token_endpoint\n                    ].filter(Boolean))\n                ];\n                const assertion = await clientAssertion.call(this, endpoint, {\n                    iat: timestamp,\n                    exp: timestamp + 60,\n                    jti: random(),\n                    iss: this.client_id,\n                    sub: this.client_id,\n                    aud: audience,\n                    ...clientAssertionPayload\n                });\n                return {\n                    form: {\n                        client_id: this.client_id,\n                        client_assertion: assertion,\n                        client_assertion_type: \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"\n                    }\n                };\n            }\n        case \"client_secret_basic\":\n            {\n                // This is correct behaviour, see https://tools.ietf.org/html/rfc6749#section-2.3.1 and the\n                // related appendix. (also https://github.com/panva/node-openid-client/pull/91)\n                // > The client identifier is encoded using the\n                // > \"application/x-www-form-urlencoded\" encoding algorithm per\n                // > Appendix B, and the encoded value is used as the username; the client\n                // > password is encoded using the same algorithm and used as the\n                // > password.\n                if (typeof this.client_secret !== \"string\") {\n                    throw new TypeError(\"client_secret_basic client authentication method requires a client_secret\");\n                }\n                const encoded = `${formUrlEncode(this.client_id)}:${formUrlEncode(this.client_secret)}`;\n                const value = Buffer.from(encoded).toString(\"base64\");\n                return {\n                    headers: {\n                        Authorization: `Basic ${value}`\n                    }\n                };\n            }\n        default:\n            {\n                throw new TypeError(`missing, or unsupported, ${endpoint}_endpoint_auth_method`);\n            }\n    }\n}\nfunction resolveResponseType() {\n    const { length, 0: value } = this.response_types;\n    if (length === 1) {\n        return value;\n    }\n    return undefined;\n}\nfunction resolveRedirectUri() {\n    const { length, 0: value } = this.redirect_uris || [];\n    if (length === 1) {\n        return value;\n    }\n    return undefined;\n}\nasync function authenticatedPost(endpoint, opts, { clientAssertionPayload, endpointAuthMethod = endpoint, DPoP } = {}) {\n    const auth = await authFor.call(this, endpointAuthMethod, {\n        clientAssertionPayload\n    });\n    const requestOpts = merge(opts, auth);\n    const mTLS = this[`${endpointAuthMethod}_endpoint_auth_method`].includes(\"tls_client_auth\") || endpoint === \"token\" && this.tls_client_certificate_bound_access_tokens;\n    let targetUrl;\n    if (mTLS && this.issuer.mtls_endpoint_aliases) {\n        targetUrl = this.issuer.mtls_endpoint_aliases[`${endpoint}_endpoint`];\n    }\n    targetUrl = targetUrl || this.issuer[`${endpoint}_endpoint`];\n    if (\"form\" in requestOpts) {\n        for (const [key, value] of Object.entries(requestOpts.form)){\n            if (typeof value === \"undefined\") {\n                delete requestOpts.form[key];\n            }\n        }\n    }\n    return request.call(this, {\n        ...requestOpts,\n        method: \"POST\",\n        url: targetUrl,\n        headers: {\n            ...endpoint !== \"revocation\" ? {\n                Accept: \"application/json\"\n            } : undefined,\n            ...requestOpts.headers\n        }\n    }, {\n        mTLS,\n        DPoP\n    });\n}\nmodule.exports = {\n    resolveResponseType,\n    resolveRedirectUri,\n    authFor,\n    authenticatedPost\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUEsT0FBT0MsbUJBQU9BLENBQUM7QUFFckIsTUFBTSxFQUFFQyxPQUFPLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFFNUIsTUFBTSxFQUFFRSx5QkFBeUIsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUM5QyxNQUFNLEVBQUVHLE1BQU0sRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNSSxNQUFNSixtQkFBT0EsQ0FBQztBQUNwQixNQUFNSyxVQUFVTCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNLEVBQUVNLFNBQVMsRUFBRSxHQUFHTixtQkFBT0EsQ0FBQztBQUM5QixNQUFNTyxRQUFRUCxtQkFBT0EsQ0FBQztBQUV0QixNQUFNUSxnQkFBZ0IsQ0FBQ0MsUUFBVUMsbUJBQW1CRCxPQUFPRSxPQUFPLENBQUMsUUFBUTtBQUUzRSxlQUFlQyxnQkFBZ0JDLFFBQVEsRUFBRUMsT0FBTztJQUM5QyxJQUFJQyxNQUFNLElBQUksQ0FBQyxDQUFDLEVBQUVGLFNBQVMsMEJBQTBCLENBQUMsQ0FBQztJQUN2RCxJQUFJLENBQUNFLEtBQUs7UUFDUmIsMEJBQ0UsSUFBSSxDQUFDYyxNQUFNLEVBQ1gsQ0FBQyxFQUFFSCxTQUFTLDJDQUEyQyxDQUFDO0lBRTVEO0lBRUEsSUFBSSxJQUFJLENBQUMsQ0FBQyxFQUFFQSxTQUFTLHFCQUFxQixDQUFDLENBQUMsS0FBSyxxQkFBcUI7UUFDcEUsSUFBSSxDQUFDRSxLQUFLO1lBQ1IsTUFBTUUsWUFBWSxJQUFJLENBQUNELE1BQU0sQ0FBQyxDQUFDLEVBQUVILFNBQVMsMkNBQTJDLENBQUMsQ0FBQztZQUN2RkUsTUFDRUcsTUFBTUMsT0FBTyxDQUFDRixjQUFjQSxVQUFVRyxJQUFJLENBQUMsQ0FBQ0MsVUFBWSxxQkFBcUJDLElBQUksQ0FBQ0Q7UUFDdEY7UUFFQSxJQUFJLENBQUNOLEtB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O0FBRWpCO0FBRUFhLE9BQU9DLE9BQU8sR0FBRztJQUNmdkI7SUFDQUk7SUFDQTlCO0lBQ0FnQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hdXRoLXJlZ2lzdGVyLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvY2xpZW50LmpzPzIzNzkiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgam9zZSA9IHJlcXVpcmUoJ2pvc2UnKTtcblxuY29uc3QgeyBSUEVycm9yIH0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcblxuY29uc3QgeyBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uIH0gPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xuY29uc3QgeyByYW5kb20gfSA9IHJlcXVpcmUoJy4vZ2VuZXJhdG9ycycpO1xuY29uc3Qgbm93ID0gcmVxdWlyZSgnLi91bml4X3RpbWVzdGFtcCcpO1xuY29uc3QgcmVxdWVzdCA9IHJlcXVpcmUoJy4vcmVxdWVzdCcpO1xuY29uc3QgeyBrZXlzdG9yZXMgfSA9IHJlcXVpcmUoJy4vd2Vha19jYWNoZScpO1xuY29uc3QgbWVyZ2UgPSByZXF1aXJlKCcuL21lcmdlJyk7XG5cbmNvbnN0IGZvcm1VcmxFbmNvZGUgPSAodmFsdWUpID0+IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkucmVwbGFjZSgvJTIwL2csICcrJyk7XG5cbmFzeW5jIGZ1bmN0aW9uIGNsaWVudEFzc2VydGlvbihlbmRwb2ludCwgcGF5bG9hZCkge1xuICBsZXQgYWxnID0gdGhpc1tgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9zaWduaW5nX2FsZ2BdO1xuICBpZiAoIWFsZykge1xuICAgIGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24oXG4gICAgICB0aGlzLmlzc3VlcixcbiAgICAgIGAke2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWRgLFxuICAgICk7XG4gIH1cblxuICBpZiAodGhpc1tgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9tZXRob2RgXSA9PT0gJ2NsaWVudF9zZWNyZXRfand0Jykge1xuICAgIGlmICghYWxnKSB7XG4gICAgICBjb25zdCBzdXBwb3J0ZWQgPSB0aGlzLmlzc3VlcltgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkYF07XG4gICAgICBhbGcgPVxuICAgICAgICBBcnJheS5pc0FycmF5KHN1cHBvcnRlZCkgJiYgc3VwcG9ydGVkLmZpbmQoKHNpZ25BbGcpID0+IC9eSFMoPzoyNTZ8Mzg0fDUxMikvLnRlc3Qoc2lnbkFsZykpO1xuICAgIH1cblxuICAgIGlmICghYWxnKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcihcbiAgICAgICAgYGZhaWxlZCB0byBkZXRlcm1pbmUgYSBKV1MgQWxnb3JpdGhtIHRvIHVzZSBmb3IgJHtcbiAgICAgICAgICB0aGlzW2Ake2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX21ldGhvZGBdXG4gICAgICAgIH0gQ2xpZW50IEFzc2VydGlvbmAsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgam9zZS5Db21wYWN0U2lnbihCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShwYXlsb2FkKSkpXG4gICAgICAuc2V0UHJvdGVjdGVkSGVhZGVyKHsgYWxnIH0pXG4gICAgICAuc2lnbih0aGlzLnNlY3JldEZvckFsZyhhbGcpKTtcbiAgfVxuXG4gIGNvbnN0IGtleXN0b3JlID0gYXdhaXQga2V5c3RvcmVzLmdldCh0aGlzKTtcblxuICBpZiAoIWtleXN0b3JlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gY2xpZW50IGp3a3MgcHJvdmlkZWQgZm9yIHNpZ25pbmcgYSBjbGllbnQgYXNzZXJ0aW9uIHdpdGgnKTtcbiAgfVxuXG4gIGlmICghYWxnKSB7XG4gICAgY29uc3Qgc3VwcG9ydGVkID0gdGhpcy5pc3N1ZXJbYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZGBdO1xuICAgIGFsZyA9XG4gICAgICBBcnJheS5pc0FycmF5KHN1cHBvcnRlZCkgJiZcbiAgICAgIHN1cHBvcnRlZC5maW5kKChzaWduQWxnKSA9PiBrZXlzdG9yZS5nZXQoeyBhbGc6IHNpZ25BbGcsIHVzZTogJ3NpZycgfSkpO1xuICB9XG5cbiAgaWYgKCFhbGcpIHtcbiAgICB0aHJvdyBuZXcgUlBFcnJvcihcbiAgICAgIGBmYWlsZWQgdG8gZGV0ZXJtaW5lIGEgSldTIEFsZ29yaXRobSB0byB1c2UgZm9yICR7XG4gICAgICAgIHRoaXNbYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfbWV0aG9kYF1cbiAgICAgIH0gQ2xpZW50IEFzc2VydGlvbmAsXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGtleSA9IGtleXN0b3JlLmdldCh7IGFsZywgdXNlOiAnc2lnJyB9KTtcbiAgaWYgKCFrZXkpIHtcbiAgICB0aHJvdyBuZXcgUlBFcnJvcihcbiAgICAgIGBubyBrZXkgZm91bmQgaW4gY2xpZW50IGp3a3MgdG8gc2lnbiBhIGNsaWVudCBhc3NlcnRpb24gd2l0aCB1c2luZyBhbGcgJHthbGd9YCxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBqb3NlLkNvbXBhY3RTaWduKEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKSlcbiAgICAuc2V0UHJvdGVjdGVkSGVhZGVyKHsgYWxnLCBraWQ6IGtleS5qd2sgJiYga2V5Lmp3ay5raWQgfSlcbiAgICAuc2lnbihrZXkua2V5T2JqZWN0KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXV0aEZvcihlbmRwb2ludCwgeyBjbGllbnRBc3NlcnRpb25QYXlsb2FkIH0gPSB7fSkge1xuICBjb25zdCBhdXRoTWV0aG9kID0gdGhpc1tgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9tZXRob2RgXTtcbiAgc3dpdGNoIChhdXRoTWV0aG9kKSB7XG4gICAgY2FzZSAnc2VsZl9zaWduZWRfdGxzX2NsaWVudF9hdXRoJzpcbiAgICBjYXNlICd0bHNfY2xpZW50X2F1dGgnOlxuICAgIGNhc2UgJ25vbmUnOlxuICAgICAgcmV0dXJuIHsgZm9ybTogeyBjbGllbnRfaWQ6IHRoaXMuY2xpZW50X2lkIH0gfTtcbiAgICBjYXNlICdjbGllbnRfc2VjcmV0X3Bvc3QnOlxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmNsaWVudF9zZWNyZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ2NsaWVudF9zZWNyZXRfcG9zdCBjbGllbnQgYXV0aGVudGljYXRpb24gbWV0aG9kIHJlcXVpcmVzIGEgY2xpZW50X3NlY3JldCcsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBmb3JtOiB7IGNsaWVudF9pZDogdGhpcy5jbGllbnRfaWQsIGNsaWVudF9zZWNyZXQ6IHRoaXMuY2xpZW50X3NlY3JldCB9IH07XG4gICAgY2FzZSAncHJpdmF0ZV9rZXlfand0JzpcbiAgICBjYXNlICdjbGllbnRfc2VjcmV0X2p3dCc6IHtcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5vdygpO1xuICAgICAgY29uc3QgYXVkaWVuY2UgPSBbXG4gICAgICAgIC4uLm5ldyBTZXQoW3RoaXMuaXNzdWVyLmlzc3VlciwgdGhpcy5pc3N1ZXIudG9rZW5fZW5kcG9pbnRdLmZpbHRlcihCb29sZWFuKSksXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBhc3NlcnRpb24gPSBhd2FpdCBjbGllbnRBc3NlcnRpb24uY2FsbCh0aGlzLCBlbmRwb2ludCwge1xuICAgICAgICBpYXQ6IHRpbWVzdGFtcCxcbiAgICAgICAgZXhwOiB0aW1lc3RhbXAgKyA2MCxcbiAgICAgICAganRpOiByYW5kb20oKSxcbiAgICAgICAgaXNzOiB0aGlzLmNsaWVudF9pZCxcbiAgICAgICAgc3ViOiB0aGlzLmNsaWVudF9pZCxcbiAgICAgICAgYXVkOiBhdWRpZW5jZSxcbiAgICAgICAgLi4uY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBmb3JtOiB7XG4gICAgICAgICAgY2xpZW50X2lkOiB0aGlzLmNsaWVudF9pZCxcbiAgICAgICAgICBjbGllbnRfYXNzZXJ0aW9uOiBhc3NlcnRpb24sXG4gICAgICAgICAgY2xpZW50X2Fzc2VydGlvbl90eXBlOiAndXJuOmlldGY6cGFyYW1zOm9hdXRoOmNsaWVudC1hc3NlcnRpb24tdHlwZTpqd3QtYmVhcmVyJyxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgJ2NsaWVudF9zZWNyZXRfYmFzaWMnOiB7XG4gICAgICAvLyBUaGlzIGlzIGNvcnJlY3QgYmVoYXZpb3VyLCBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY3NDkjc2VjdGlvbi0yLjMuMSBhbmQgdGhlXG4gICAgICAvLyByZWxhdGVkIGFwcGVuZGl4LiAoYWxzbyBodHRwczovL2dpdGh1Yi5jb20vcGFudmEvbm9kZS1vcGVuaWQtY2xpZW50L3B1bGwvOTEpXG4gICAgICAvLyA+IFRoZSBjbGllbnQgaWRlbnRpZmllciBpcyBlbmNvZGVkIHVzaW5nIHRoZVxuICAgICAgLy8gPiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiIGVuY29kaW5nIGFsZ29yaXRobSBwZXJcbiAgICAgIC8vID4gQXBwZW5kaXggQiwgYW5kIHRoZSBlbmNvZGVkIHZhbHVlIGlzIHVzZWQgYXMgdGhlIHVzZXJuYW1lOyB0aGUgY2xpZW50XG4gICAgICAvLyA+IHBhc3N3b3JkIGlzIGVuY29kZWQgdXNpbmcgdGhlIHNhbWUgYWxnb3JpdGhtIGFuZCB1c2VkIGFzIHRoZVxuICAgICAgLy8gPiBwYXNzd29yZC5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5jbGllbnRfc2VjcmV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdjbGllbnRfc2VjcmV0X2Jhc2ljIGNsaWVudCBhdXRoZW50aWNhdGlvbiBtZXRob2QgcmVxdWlyZXMgYSBjbGllbnRfc2VjcmV0JyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVuY29kZWQgPSBgJHtmb3JtVXJsRW5jb2RlKHRoaXMuY2xpZW50X2lkKX06JHtmb3JtVXJsRW5jb2RlKHRoaXMuY2xpZW50X3NlY3JldCl9YDtcbiAgICAgIGNvbnN0IHZhbHVlID0gQnVmZmVyLmZyb20oZW5jb2RlZCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgcmV0dXJuIHsgaGVhZGVyczogeyBBdXRob3JpemF0aW9uOiBgQmFzaWMgJHt2YWx1ZX1gIH0gfTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgbWlzc2luZywgb3IgdW5zdXBwb3J0ZWQsICR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfbWV0aG9kYCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVSZXNwb25zZVR5cGUoKSB7XG4gIGNvbnN0IHsgbGVuZ3RoLCAwOiB2YWx1ZSB9ID0gdGhpcy5yZXNwb25zZV90eXBlcztcblxuICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJlZGlyZWN0VXJpKCkge1xuICBjb25zdCB7IGxlbmd0aCwgMDogdmFsdWUgfSA9IHRoaXMucmVkaXJlY3RfdXJpcyB8fCBbXTtcblxuICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXV0aGVudGljYXRlZFBvc3QoXG4gIGVuZHBvaW50LFxuICBvcHRzLFxuICB7IGNsaWVudEFzc2VydGlvblBheWxvYWQsIGVuZHBvaW50QXV0aE1ldGhvZCA9IGVuZHBvaW50LCBEUG9QIH0gPSB7fSxcbikge1xuICBjb25zdCBhdXRoID0gYXdhaXQgYXV0aEZvci5jYWxsKHRoaXMsIGVuZHBvaW50QXV0aE1ldGhvZCwgeyBjbGllbnRBc3NlcnRpb25QYXlsb2FkIH0pO1xuICBjb25zdCByZXF1ZXN0T3B0cyA9IG1lcmdlKG9wdHMsIGF1dGgpO1xuXG4gIGNvbnN0IG1UTFMgPVxuICAgIHRoaXNbYCR7ZW5kcG9pbnRBdXRoTWV0aG9kfV9lbmRwb2ludF9hdXRoX21ldGhvZGBdLmluY2x1ZGVzKCd0bHNfY2xpZW50X2F1dGgnKSB8fFxuICAgIChlbmRwb2ludCA9PT0gJ3Rva2VuJyAmJiB0aGlzLnRsc19jbGllbnRfY2VydGlmaWNhdGVfYm91bmRfYWNjZXNzX3Rva2Vucyk7XG5cbiAgbGV0IHRhcmdldFVybDtcbiAgaWYgKG1UTFMgJiYgdGhpcy5pc3N1ZXIubXRsc19lbmRwb2ludF9hbGlhc2VzKSB7XG4gICAgdGFyZ2V0VXJsID0gdGhpcy5pc3N1ZXIubXRsc19lbmRwb2ludF9hbGlhc2VzW2Ake2VuZHBvaW50fV9lbmRwb2ludGBdO1xuICB9XG5cbiAgdGFyZ2V0VXJsID0gdGFyZ2V0VXJsIHx8IHRoaXMuaXNzdWVyW2Ake2VuZHBvaW50fV9lbmRwb2ludGBdO1xuXG4gIGlmICgnZm9ybScgaW4gcmVxdWVzdE9wdHMpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyZXF1ZXN0T3B0cy5mb3JtKSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZGVsZXRlIHJlcXVlc3RPcHRzLmZvcm1ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVxdWVzdC5jYWxsKFxuICAgIHRoaXMsXG4gICAge1xuICAgICAgLi4ucmVxdWVzdE9wdHMsXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIHVybDogdGFyZ2V0VXJsLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi4oZW5kcG9pbnQgIT09ICdyZXZvY2F0aW9uJ1xuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IHVuZGVmaW5lZCksXG4gICAgICAgIC4uLnJlcXVlc3RPcHRzLmhlYWRlcnMsXG4gICAgICB9LFxuICAgIH0sXG4gICAgeyBtVExTLCBEUG9QIH0sXG4gICk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZXNvbHZlUmVzcG9uc2VUeXBlLFxuICByZXNvbHZlUmVkaXJlY3RVcmksXG4gIGF1dGhGb3IsXG4gIGF1dGhlbnRpY2F0ZWRQb3N0LFxufTtcbiJdLCJuYW1lcyI6WyJqb3NlIiwicmVxdWlyZSIsIlJQRXJyb3IiLCJhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uIiwicmFuZG9tIiwibm93IiwicmVxdWVzdCIsImtleXN0b3JlcyIsIm1lcmdlIiwiZm9ybVVybEVuY29kZSIsInZhbHVlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVwbGFjZSIsImNsaWVudEFzc2VydGlvbiIsImVuZHBvaW50IiwicGF5bG9hZCIsImFsZyIsImlzc3VlciIsInN1cHBvcnRlZCIsIkFycmF5IiwiaXNBcnJheSIsImZpbmQiLCJzaWduQWxnIiwidGVzdCIsIkNvbXBhY3RTaWduIiwiQnVmZmVyIiwiZnJvbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzZXRQcm90ZWN0ZWRIZWFkZXIiLCJzaWduIiwic2VjcmV0Rm9yQWxnIiwia2V5c3RvcmUiLCJnZXQiLCJUeXBlRXJyb3IiLCJ1c2UiLCJrZXkiLCJraWQiLCJqd2siLCJrZXlPYmplY3QiLCJhdXRoRm9yIiwiY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCIsImF1dGhNZXRob2QiLCJmb3JtIiwiY2xpZW50X2lkIiwiY2xpZW50X3NlY3JldCIsInRpbWVzdGFtcCIsImF1ZGllbmNlIiwiU2V0IiwidG9rZW5fZW5kcG9pbnQiLCJmaWx0ZXIiLCJCb29sZWFuIiwiYXNzZXJ0aW9uIiwiY2FsbCIsImlhdCIsImV4cCIsImp0aSIsImlzcyIsInN1YiIsImF1ZCIsImNsaWVudF9hc3NlcnRpb24iLCJjbGllbnRfYXNzZXJ0aW9uX3R5cGUiLCJlbmNvZGVkIiwidG9TdHJpbmciLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsInJlc29sdmVSZXNwb25zZVR5cGUiLCJsZW5ndGgiLCJyZXNwb25zZV90eXBlcyIsInVuZGVmaW5lZCIsInJlc29sdmVSZWRpcmVjdFVyaSIsInJlZGlyZWN0X3VyaXMiLCJhdXRoZW50aWNhdGVkUG9zdCIsIm9wdHMiLCJlbmRwb2ludEF1dGhNZXRob2QiLCJEUG9QIiwiYXV0aCIsInJlcXVlc3RPcHRzIiwibVRMUyIsImluY2x1ZGVzIiwidGxzX2NsaWVudF9jZXJ0aWZpY2F0ZV9ib3VuZF9hY2Nlc3NfdG9rZW5zIiwidGFyZ2V0VXJsIiwibXRsc19lbmRwb2ludF9hbGlhc2VzIiwiT2JqZWN0IiwiZW50cmllcyIsIm1ldGhvZCIsInVybCIsIkFjY2VwdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/consts.js":
/*!**********************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/consts.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("const HTTP_OPTIONS = Symbol();\nconst CLOCK_TOLERANCE = Symbol();\nmodule.exports = {\n    CLOCK_TOLERANCE,\n    HTTP_OPTIONS\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWF1dGgtcmVnaXN0ZXIvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9jb25zdHMuanM/ZTA1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBIVFRQX09QVElPTlMgPSBTeW1ib2woKTtcbmNvbnN0IENMT0NLX1RPTEVSQU5DRSA9IFN5bWJvbCgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ0xPQ0tfVE9MRVJBTkNFLFxuICBIVFRQX09QVElPTlMsXG59O1xuIl0sIm5hbWVzIjpbIkhUVFBfT1BUSU9OUyIsIlN5bWJvbCIsIkNMT0NLX1RPTEVSQU5DRSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLGVBQWVDO0FBQ3JCLE1BQU1DLGtCQUFrQkQ7QUFFeEJFLE9BQU9DLE9BQU8sR0FBRztJQUNmRjtJQUNBRjtBQUNGIiwiZmlsZSI6Iihyc2MpLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvY29uc3RzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/consts.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/decode_jwt.js":
/*!**************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/decode_jwt.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const base64url = __webpack_require__(/*! ./base64url */ \"(rsc)/./node_modules/openid-client/lib/helpers/base64url.js\");\nmodule.exports = (token)=>{\n    if (typeof token !== \"string\" || !token) {\n        throw new TypeError(\"JWT must be a string\");\n    }\n    const { 0: header, 1: payload, 2: signature, length } = token.split(\".\");\n    if (length === 5) {\n        throw new TypeError(\"encrypted JWTs cannot be decoded\");\n    }\n    if (length !== 3) {\n        throw new Error(\"JWTs must have three components\");\n    }\n    try {\n        return {\n            header: JSON.parse(base64url.decode(header)),\n            payload: JSON.parse(base64url.decode(payload)),\n            signature\n        };\n    } catch (err) {\n        throw new Error(\"JWT is malformed\");\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9kZWNvZGVfand0LmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLFlBQVlDLG1CQUFPQSxDQUFDO0FBRTFCQyxPQUFPQyxPQUFPLEdBQUcsQ0FBQ0M7SUFDaEIsSUFBSSxPQUFPQSxVQUFVLFlBQVksQ0FBQ0EsT0FBTztRQUN2QyxNQUFNLElBQUlDLFVBQVU7SUFDdEI7SUFFQSxNQUFNLEVBQUUsR0FBR0MsTUFBTSxFQUFFLEdBQUdDLE9BQU8sRUFBRSxHQUFHQyxTQUFTLEVBQUVDLE1BQU0sRUFBRSxHQUFHTCxNQUFNTSxLQUFLLENBQUM7SUFFcEUsSUFBSUQsV0FBVyxHQUFHO1FBQ2hCLE1BQU0sSUFBSUosVUFBVTtJQUN0QjtJQUVBLElBQUlJLFdBQVcsR0FBRztRQUNoQixNQUFNLElBQUlFLE1BQU07SUFDbEI7SUFFQSxJQUFJO1FBQ0YsT0FBTztZQUNMTCxRQUFRTSxLQUFLQyxLQUFLLENBQUNiLFVBQVVjLE1BQU0sQ0FBQ1I7WUFDcENDLFNBQVNLLEtBQUtDLEtBQUssQ0FBQ2IsVUFBVWMsTUFBTSxDQUFDUDtZQUNyQ0M7UUFDRjtJQUNGLEVBQUUsT0FBT08sS0FBSztRQUNaLE1BQU0sSUFBSUosTUFBTTtJQUNsQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hdXRoLXJlZ2lzdGVyLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvZGVjb2RlX2p3dC5qcz81NjAzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGJhc2U2NHVybCA9IHJlcXVpcmUoJy4vYmFzZTY0dXJsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKHRva2VuKSA9PiB7XG4gIGlmICh0eXBlb2YgdG9rZW4gIT09ICdzdHJpbmcnIHx8ICF0b2tlbikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0pXVCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBjb25zdCB7IDA6IGhlYWRlciwgMTogcGF5bG9hZCwgMjogc2lnbmF0dXJlLCBsZW5ndGggfSA9IHRva2VuLnNwbGl0KCcuJyk7XG5cbiAgaWYgKGxlbmd0aCA9PT0gNSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY3J5cHRlZCBKV1RzIGNhbm5vdCBiZSBkZWNvZGVkJyk7XG4gIH1cblxuICBpZiAobGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdKV1RzIG11c3QgaGF2ZSB0aHJlZSBjb21wb25lbnRzJyk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiB7XG4gICAgICBoZWFkZXI6IEpTT04ucGFyc2UoYmFzZTY0dXJsLmRlY29kZShoZWFkZXIpKSxcbiAgICAgIHBheWxvYWQ6IEpTT04ucGFyc2UoYmFzZTY0dXJsLmRlY29kZShwYXlsb2FkKSksXG4gICAgICBzaWduYXR1cmUsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdKV1QgaXMgbWFsZm9ybWVkJyk7XG4gIH1cbn07XG4iXSwibmFtZXMiOlsiYmFzZTY0dXJsIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0b2tlbiIsIlR5cGVFcnJvciIsImhlYWRlciIsInBheWxvYWQiLCJzaWduYXR1cmUiLCJsZW5ndGgiLCJzcGxpdCIsIkVycm9yIiwiSlNPTiIsInBhcnNlIiwiZGVjb2RlIiwiZXJyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/decode_jwt.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/deep_clone.js":
/*!**************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/deep_clone.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("module.exports = globalThis.structuredClone || ((obj)=>JSON.parse(JSON.stringify(obj)));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWF1dGgtcmVnaXN0ZXIvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9kZWVwX2Nsb25lLmpzPzhlNGIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBnbG9iYWxUaGlzLnN0cnVjdHVyZWRDbG9uZSB8fCAoKG9iaikgPT4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKSk7XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImdsb2JhbFRoaXMiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJvYmoiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiXSwibWFwcGluZ3MiOiJBQUFBQSxPQUFPQyxPQUFPLEdBQUdDLFdBQVdDLGVBQWUsSUFBSyxDQUFBLENBQUNDLE1BQVFDLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsU0FBUyxDQUFDSCxLQUFJIiwiZmlsZSI6Iihyc2MpLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvZGVlcF9jbG9uZS5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/deep_clone.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/defaults.js":
/*!************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/defaults.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const isPlainObject = __webpack_require__(/*! ./is_plain_object */ \"(rsc)/./node_modules/openid-client/lib/helpers/is_plain_object.js\");\nfunction defaults(deep, target, ...sources) {\n    for (const source of sources){\n        if (!isPlainObject(source)) {\n            continue;\n        }\n        for (const [key, value] of Object.entries(source)){\n            /* istanbul ignore if */ if (key === \"__proto__\" || key === \"constructor\") {\n                continue;\n            }\n            if (typeof target[key] === \"undefined\" && typeof value !== \"undefined\") {\n                target[key] = value;\n            }\n            if (deep && isPlainObject(target[key]) && isPlainObject(value)) {\n                defaults(true, target[key], value);\n            }\n        }\n    }\n    return target;\n}\nmodule.exports = defaults.bind(undefined, false);\nmodule.exports.deep = defaults.bind(undefined, true);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9kZWZhdWx0cy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxnQkFBZ0JDLG1CQUFPQSxDQUFDO0FBRTlCLFNBQVNDLFNBQVNDLElBQUksRUFBRUMsTUFBTSxFQUFFLEdBQUdDLE9BQU87SUFDeEMsS0FBSyxNQUFNQyxVQUFVRCxRQUFTO1FBQzVCLElBQUksQ0FBQ0wsY0FBY00sU0FBUztZQUMxQjtRQUNGO1FBQ0EsS0FBSyxNQUFNLENBQUNDLEtBQUtDLE1BQU0sSUFBSUMsT0FBT0MsT0FBTyxDQUFDSixRQUFTO1lBQ2pELHNCQUFzQixHQUN0QixJQUFJQyxRQUFRLGVBQWVBLFFBQVEsZUFBZTtnQkFDaEQ7WUFDRjtZQUNBLElBQUksT0FBT0gsTUFBTSxDQUFDRyxJQUFJLEtBQUssZUFBZSxPQUFPQyxVQUFVLGFBQWE7Z0JBQ3RFSixNQUFNLENBQUNHLElBQUksR0FBR0M7WUFDaEI7WUFFQSxJQUFJTCxRQUFRSCxjQUFjSSxNQUFNLENBQUNHLElBQUksS0FBS1AsY0FBY1EsUUFBUTtnQkFDOUROLFNBQVMsTUFBTUUsTUFBTSxDQUFDRyxJQUFJLEVBQUVDO1lBQzlCO1FBQ0Y7SUFDRjtJQUVBLE9BQU9KO0FBQ1Q7QUFFQU8sT0FBT0MsT0FBTyxHQUFHVixTQUFTVyxJQUFJLENBQUNDLFdBQVc7QUFDMUNILG1CQUFtQixHQUFHVCxTQUFTVyxJQUFJLENBQUNDLFdBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWF1dGgtcmVnaXN0ZXIvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9kZWZhdWx0cy5qcz8wY2IxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzX3BsYWluX29iamVjdCcpO1xuXG5mdW5jdGlvbiBkZWZhdWx0cyhkZWVwLCB0YXJnZXQsIC4uLnNvdXJjZXMpIHtcbiAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc291cmNlKSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRhcmdldFtrZXldID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWVwICYmIGlzUGxhaW5PYmplY3QodGFyZ2V0W2tleV0pICYmIGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGRlZmF1bHRzKHRydWUsIHRhcmdldFtrZXldLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cy5iaW5kKHVuZGVmaW5lZCwgZmFsc2UpO1xubW9kdWxlLmV4cG9ydHMuZGVlcCA9IGRlZmF1bHRzLmJpbmQodW5kZWZpbmVkLCB0cnVlKTtcbiJdLCJuYW1lcyI6WyJpc1BsYWluT2JqZWN0IiwicmVxdWlyZSIsImRlZmF1bHRzIiwiZGVlcCIsInRhcmdldCIsInNvdXJjZXMiLCJzb3VyY2UiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJtb2R1bGUiLCJleHBvcnRzIiwiYmluZCIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/defaults.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/generators.js":
/*!**************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/generators.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { createHash, randomBytes } = __webpack_require__(/*! crypto */ \"crypto\");\nconst base64url = __webpack_require__(/*! ./base64url */ \"(rsc)/./node_modules/openid-client/lib/helpers/base64url.js\");\nconst random = (bytes = 32)=>base64url.encode(randomBytes(bytes));\nmodule.exports = {\n    random,\n    state: random,\n    nonce: random,\n    codeVerifier: random,\n    codeChallenge: (codeVerifier)=>base64url.encode(createHash(\"sha256\").update(codeVerifier).digest())\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9nZW5lcmF0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBRUEsVUFBVSxFQUFFQyxXQUFXLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFNUMsTUFBTUMsWUFBWUQsbUJBQU9BLENBQUM7QUFFMUIsTUFBTUUsU0FBUyxDQUFDQyxRQUFRLEVBQUUsR0FBS0YsVUFBVUcsTUFBTSxDQUFDTCxZQUFZSTtBQUU1REUsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZKO0lBQ0FLLE9BQU9MO0lBQ1BNLE9BQU9OO0lBQ1BPLGNBQWNQO0lBQ2RRLGVBQWUsQ0FBQ0QsZUFDZFIsVUFBVUcsTUFBTSxDQUFDTixXQUFXLFVBQVVhLE1BQU0sQ0FBQ0YsY0FBY0csTUFBTTtBQUNyRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXV0aC1yZWdpc3Rlci8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL2dlbmVyYXRvcnMuanM/ODJmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGNyZWF0ZUhhc2gsIHJhbmRvbUJ5dGVzIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgYmFzZTY0dXJsID0gcmVxdWlyZSgnLi9iYXNlNjR1cmwnKTtcblxuY29uc3QgcmFuZG9tID0gKGJ5dGVzID0gMzIpID0+IGJhc2U2NHVybC5lbmNvZGUocmFuZG9tQnl0ZXMoYnl0ZXMpKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJhbmRvbSxcbiAgc3RhdGU6IHJhbmRvbSxcbiAgbm9uY2U6IHJhbmRvbSxcbiAgY29kZVZlcmlmaWVyOiByYW5kb20sXG4gIGNvZGVDaGFsbGVuZ2U6IChjb2RlVmVyaWZpZXIpID0+XG4gICAgYmFzZTY0dXJsLmVuY29kZShjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoY29kZVZlcmlmaWVyKS5kaWdlc3QoKSksXG59O1xuIl0sIm5hbWVzIjpbImNyZWF0ZUhhc2giLCJyYW5kb21CeXRlcyIsInJlcXVpcmUiLCJiYXNlNjR1cmwiLCJyYW5kb20iLCJieXRlcyIsImVuY29kZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJzdGF0ZSIsIm5vbmNlIiwiY29kZVZlcmlmaWVyIiwiY29kZUNoYWxsZW5nZSIsInVwZGF0ZSIsImRpZ2VzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/generators.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/is_key_object.js":
/*!*****************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/is_key_object.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const util = __webpack_require__(/*! util */ \"util\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nmodule.exports = util.types.isKeyObject || ((obj)=>obj && obj instanceof crypto.KeyObject);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9pc19rZXlfb2JqZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLE9BQU9DLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDO0FBRXZCRSxPQUFPQyxPQUFPLEdBQUdKLEtBQUtLLEtBQUssQ0FBQ0MsV0FBVyxJQUFLLEVBQUNDLE1BQVFBLE9BQU9BLGVBQWVMLE9BQU9NLFNBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWF1dGgtcmVnaXN0ZXIvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9pc19rZXlfb2JqZWN0LmpzP2EwMGIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWwudHlwZXMuaXNLZXlPYmplY3QgfHwgKChvYmopID0+IG9iaiAmJiBvYmogaW5zdGFuY2VvZiBjcnlwdG8uS2V5T2JqZWN0KTtcbiJdLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsImNyeXB0byIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0eXBlcyIsImlzS2V5T2JqZWN0Iiwib2JqIiwiS2V5T2JqZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/is_key_object.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/is_plain_object.js":
/*!*******************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/is_plain_object.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("module.exports = (a)=>!!a && a.constructor === Object;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWF1dGgtcmVnaXN0ZXIvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9pc19wbGFpbl9vYmplY3QuanM/ZTNlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IChhKSA9PiAhIWEgJiYgYS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJhIiwiY29uc3RydWN0b3IiLCJPYmplY3QiXSwibWFwcGluZ3MiOiJBQUFBQSxPQUFPQyxPQUFPLEdBQUcsQ0FBQ0MsSUFBTSxDQUFDLENBQUNBLEtBQUtBLEVBQUVDLFdBQVcsS0FBS0MiLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9pc19wbGFpbl9vYmplY3QuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/is_plain_object.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/issuer.js":
/*!**********************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/issuer.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const objectHash = __webpack_require__(/*! object-hash */ \"(rsc)/./node_modules/openid-client/node_modules/object-hash/index.js\");\nconst LRU = __webpack_require__(/*! lru-cache */ \"(rsc)/./node_modules/lru-cache/index.js\");\nconst { RPError } = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/openid-client/lib/errors.js\");\nconst { assertIssuerConfiguration } = __webpack_require__(/*! ./assert */ \"(rsc)/./node_modules/openid-client/lib/helpers/assert.js\");\nconst KeyStore = __webpack_require__(/*! ./keystore */ \"(rsc)/./node_modules/openid-client/lib/helpers/keystore.js\");\nconst { keystores } = __webpack_require__(/*! ./weak_cache */ \"(rsc)/./node_modules/openid-client/lib/helpers/weak_cache.js\");\nconst processResponse = __webpack_require__(/*! ./process_response */ \"(rsc)/./node_modules/openid-client/lib/helpers/process_response.js\");\nconst request = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/openid-client/lib/helpers/request.js\");\nconst inFlight = new WeakMap();\nconst caches = new WeakMap();\nconst lrus = (ctx)=>{\n    if (!caches.has(ctx)) {\n        caches.set(ctx, new LRU({\n            max: 100\n        }));\n    }\n    return caches.get(ctx);\n};\nasync function getKeyStore(reload = false) {\n    assertIssuerConfiguration(this, \"jwks_uri\");\n    const keystore = keystores.get(this);\n    const cache = lrus(this);\n    if (reload || !keystore) {\n        if (inFlight.has(this)) {\n            return inFlight.get(this);\n        }\n        cache.reset();\n        inFlight.set(this, (async ()=>{\n            const response = await request.call(this, {\n                method: \"GET\",\n                responseType: \"json\",\n                url: this.jwks_uri,\n                headers: {\n                    Accept: \"application/json, application/jwk-set+json\"\n                }\n            }).finally(()=>{\n                inFlight.delete(this);\n            });\n            const jwks = processResponse(response);\n            const joseKeyStore = KeyStore.fromJWKS(jwks, {\n                onlyPublic: true\n            });\n            cache.set(\"throttle\", true, 60 * 1000);\n            keystores.set(this, joseKeyStore);\n            return joseKeyStore;\n        })());\n        return inFlight.get(this);\n    }\n    return keystore;\n}\nasync function queryKeyStore({ kid, kty, alg, use }, { allowMulti = false } = {}) {\n    const cache = lrus(this);\n    const def = {\n        kid,\n        kty,\n        alg,\n        use\n    };\n    const defHash = objectHash(def, {\n        algorithm: \"sha256\",\n        ignoreUnknown: true,\n        unorderedArrays: true,\n        unorderedSets: true\n    });\n    // refresh keystore on every unknown key but also only upto once every minute\n    const freshJwksUri = cache.get(defHash) || cache.get(\"throttle\");\n    const keystore = await getKeyStore.call(this, !freshJwksUri);\n    const keys = keystore.all(def);\n    delete def.use;\n    if (keys.length === 0) {\n        throw new RPError({\n            printf: [\n                \"no valid key found in issuer's jwks_uri for key parameters %j\",\n                def\n            ],\n            jwks: keystore\n        });\n    }\n    if (!allowMulti && keys.length > 1 && !kid) {\n        throw new RPError({\n            printf: [\n                \"multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case\",\n                def\n            ],\n            jwks: keystore\n        });\n    }\n    cache.set(defHash, true);\n    return keys;\n}\nmodule.exports.queryKeyStore = queryKeyStore;\nmodule.exports.keystore = getKeyStore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9pc3N1ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUEsYUFBYUMsbUJBQU9BLENBQUM7QUFDM0IsTUFBTUMsTUFBTUQsbUJBQU9BLENBQUM7QUFFcEIsTUFBTSxFQUFFRSxPQUFPLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFFNUIsTUFBTSxFQUFFRyx5QkFBeUIsRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUM5QyxNQUFNSSxXQUFXSixtQkFBT0EsQ0FBQztBQUN6QixNQUFNLEVBQUVLLFNBQVMsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUM5QixNQUFNTSxrQkFBa0JOLG1CQUFPQSxDQUFDO0FBQ2hDLE1BQU1PLFVBQVVQLG1CQUFPQSxDQUFDO0FBRXhCLE1BQU1RLFdBQVcsSUFBSUM7QUFDckIsTUFBTUMsU0FBUyxJQUFJRDtBQUNuQixNQUFNRSxPQUFPLENBQUNDO0lBQ1osSUFBSSxDQUFDRixPQUFPRyxHQUFHLENBQUNELE1BQU07UUFDcEJGLE9BQU9JLEdBQUcsQ0FBQ0YsS0FBSyxJQUFJWCxJQUFJO1lBQUVjLEtBQUs7UUFBSTtJQUNyQztJQUNBLE9BQU9MLE9BQU9NLEdBQUcsQ0FBQ0o7QUFDcEI7QUFFQSxlQUFlSyxZQUFZQyxTQUFTLEtBQUs7SUFDdkNmLDBCQUEwQixJQUFJLEVBQUU7SUFFaEMsTUFBTWdCLFdBQVdkLFVBQVVXLEdBQUcsQ0FBQyxJQUFJO0lBQ25DLE1BQU1JLFFBQVFULEtBQUssSUFBSTtJQUV2QixJQUFJTyxVQUFVLENBQUNDLFVBQVU7UUFDdkIsSUFBSVgsU0FBU0ssR0FBRyxDQUFDLElBQUksR0FBRztZQUN0QixPQUFPTCxTQUFTUSxHQUFHLENBQUMsSUFBSTtRQUMxQjtRQUNBSSxNQUFNQyxLQUFLO1FBQ1hiLFNBQVNNLEdBQUcsQ0FDVixJQUFJLEVBQ0osQ0FBQztZQUNDLE1BQU1RLFdBQVcsTUFBTWYsUUFDcEJnQixJQUFJLENBQUMsSUFBSSxFQUFFO2dCQUNWQyxRQUFRO2dCQUNSQyxjQUFjO2dCQUNkQyxLQUFLLElBQUksQ0FBQ0MsUUFBUTtnQkFDbEJDLFNBQVM7b0JBQ1BDLFFBQVE7Z0JBQ1Y7WUFDRixHQUNDQyxPQUFPLENBQUM7Z0JBQ1B0QixTQUFTdUIsTUFBTSxDQUFDLElBQUk7WUFDdEI7WUFDRixNQUFNQyxPQUFPMUIsZ0JBQWdCZ0I7WUFFN0IsTUFBTVcsZUFBZTdCLFNBQVM4QixRQUFRLENBQUNGLE1BQU07Z0JBQUVHLFlBQVk7WUFBSztZQUNoRWYsTUFBTU4sR0FBRyxDQUFDLFlBQVksTUFBTSxLQUFLO1lBQ2pDVCxVQUFVUyxHQUFHLENBQUMsSUFBSSxFQUFFbUI7WUFFcEIsT0FBT0E7UUFDVDtRQUdGLE9BQU96QixTQUFTUSxHQUFHLENBQUMsSUFBSTtJQUMxQjtJQUVBLE9BQU9HO0FBQ1Q7QUFFQSxlQUFlaUIsY0FBYyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUUsRUFBRSxFQUFFQyxhQUFhLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztJQUM5RSxNQUFNckIsUUFBUVQsS0FBSyxJQUFJO0lBRXZCLE1BQU0rQixNQUFNO1FBQ1ZMO1FBQ0FDO1FBQ0FDO1FBQ0FDO0lBQ0Y7SUFFQSxNQUFNRyxVQUFVNUMsV0FBVzJDLEtBQUs7UUFDOUJFLFdBQVc7UUFDWEMsZUFBZTtRQUNmQyxpQkFBaUI7UUFDakJDLGVBQWU7SUFDakI7SUFFQSw2RUFBNkU7SUFDN0UsTUFBTUMsZUFBZTVCLE1BQU1KLEdBQUcsQ0FBQzJCLFlBQVl2QixNQUFNSixHQUFHLENBQUM7SUFFckQsTUFBTUcsV0FBVyxNQUFNRixZQUFZTSxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUN5QjtJQUMvQyxNQUFNQyxPQUFPOUIsU0FBUytCLEdBQUcsQ0FBQ1I7SUFFMUIsT0FBT0EsSUFBSUYsR0FBRztJQUNkLElBQUlTLEtBQUtFLE1BQU0sS0FBSyxHQUFHO1FBQ3JCLE1BQU0sSUFBSWpELFFBQVE7WUFDaEJrRCxRQUFRO2dCQUFDO2dCQUFpRVY7YUFBSTtZQUM5RVYsTUFBTWI7UUFDUjtJQUNGO0lBRUEsSUFBSSxDQUFDc0IsY0FBY1EsS0FBS0UsTUFBTSxHQUFHLEtBQUssQ0FBQ2QsS0FBSztRQUMxQyxNQUFNLElBQUluQyxRQUFRO1lBQ2hCa0QsUUFBUTtnQkFDTjtnQkFDQVY7YUFDRDtZQUNEVixNQUFNYjtRQUNSO0lBQ0Y7SUFFQUMsTUFBTU4sR0FBRyxDQUFDNkIsU0FBUztJQUVuQixPQUFPTTtBQUNUO0FBRUFJLDRCQUE0QixHQUFHakI7QUFDL0JpQix1QkFBdUIsR0FBR3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hdXRoLXJlZ2lzdGVyLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvaXNzdWVyLmpzPzRhNzIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgb2JqZWN0SGFzaCA9IHJlcXVpcmUoJ29iamVjdC1oYXNoJyk7XG5jb25zdCBMUlUgPSByZXF1aXJlKCdscnUtY2FjaGUnKTtcblxuY29uc3QgeyBSUEVycm9yIH0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcblxuY29uc3QgeyBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uIH0gPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xuY29uc3QgS2V5U3RvcmUgPSByZXF1aXJlKCcuL2tleXN0b3JlJyk7XG5jb25zdCB7IGtleXN0b3JlcyB9ID0gcmVxdWlyZSgnLi93ZWFrX2NhY2hlJyk7XG5jb25zdCBwcm9jZXNzUmVzcG9uc2UgPSByZXF1aXJlKCcuL3Byb2Nlc3NfcmVzcG9uc2UnKTtcbmNvbnN0IHJlcXVlc3QgPSByZXF1aXJlKCcuL3JlcXVlc3QnKTtcblxuY29uc3QgaW5GbGlnaHQgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgY2FjaGVzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGxydXMgPSAoY3R4KSA9PiB7XG4gIGlmICghY2FjaGVzLmhhcyhjdHgpKSB7XG4gICAgY2FjaGVzLnNldChjdHgsIG5ldyBMUlUoeyBtYXg6IDEwMCB9KSk7XG4gIH1cbiAgcmV0dXJuIGNhY2hlcy5nZXQoY3R4KTtcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEtleVN0b3JlKHJlbG9hZCA9IGZhbHNlKSB7XG4gIGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24odGhpcywgJ2p3a3NfdXJpJyk7XG5cbiAgY29uc3Qga2V5c3RvcmUgPSBrZXlzdG9yZXMuZ2V0KHRoaXMpO1xuICBjb25zdCBjYWNoZSA9IGxydXModGhpcyk7XG5cbiAgaWYgKHJlbG9hZCB8fCAha2V5c3RvcmUpIHtcbiAgICBpZiAoaW5GbGlnaHQuaGFzKHRoaXMpKSB7XG4gICAgICByZXR1cm4gaW5GbGlnaHQuZ2V0KHRoaXMpO1xuICAgIH1cbiAgICBjYWNoZS5yZXNldCgpO1xuICAgIGluRmxpZ2h0LnNldChcbiAgICAgIHRoaXMsXG4gICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RcbiAgICAgICAgICAuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICAgICAgICB1cmw6IHRoaXMuandrc191cmksXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24sIGFwcGxpY2F0aW9uL2p3ay1zZXQranNvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgaW5GbGlnaHQuZGVsZXRlKHRoaXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICBjb25zdCBqd2tzID0gcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlKTtcblxuICAgICAgICBjb25zdCBqb3NlS2V5U3RvcmUgPSBLZXlTdG9yZS5mcm9tSldLUyhqd2tzLCB7IG9ubHlQdWJsaWM6IHRydWUgfSk7XG4gICAgICAgIGNhY2hlLnNldCgndGhyb3R0bGUnLCB0cnVlLCA2MCAqIDEwMDApO1xuICAgICAgICBrZXlzdG9yZXMuc2V0KHRoaXMsIGpvc2VLZXlTdG9yZSk7XG5cbiAgICAgICAgcmV0dXJuIGpvc2VLZXlTdG9yZTtcbiAgICAgIH0pKCksXG4gICAgKTtcblxuICAgIHJldHVybiBpbkZsaWdodC5nZXQodGhpcyk7XG4gIH1cblxuICByZXR1cm4ga2V5c3RvcmU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHF1ZXJ5S2V5U3RvcmUoeyBraWQsIGt0eSwgYWxnLCB1c2UgfSwgeyBhbGxvd011bHRpID0gZmFsc2UgfSA9IHt9KSB7XG4gIGNvbnN0IGNhY2hlID0gbHJ1cyh0aGlzKTtcblxuICBjb25zdCBkZWYgPSB7XG4gICAga2lkLFxuICAgIGt0eSxcbiAgICBhbGcsXG4gICAgdXNlLFxuICB9O1xuXG4gIGNvbnN0IGRlZkhhc2ggPSBvYmplY3RIYXNoKGRlZiwge1xuICAgIGFsZ29yaXRobTogJ3NoYTI1NicsXG4gICAgaWdub3JlVW5rbm93bjogdHJ1ZSxcbiAgICB1bm9yZGVyZWRBcnJheXM6IHRydWUsXG4gICAgdW5vcmRlcmVkU2V0czogdHJ1ZSxcbiAgfSk7XG5cbiAgLy8gcmVmcmVzaCBrZXlzdG9yZSBvbiBldmVyeSB1bmtub3duIGtleSBidXQgYWxzbyBvbmx5IHVwdG8gb25jZSBldmVyeSBtaW51dGVcbiAgY29uc3QgZnJlc2hKd2tzVXJpID0gY2FjaGUuZ2V0KGRlZkhhc2gpIHx8IGNhY2hlLmdldCgndGhyb3R0bGUnKTtcblxuICBjb25zdCBrZXlzdG9yZSA9IGF3YWl0IGdldEtleVN0b3JlLmNhbGwodGhpcywgIWZyZXNoSndrc1VyaSk7XG4gIGNvbnN0IGtleXMgPSBrZXlzdG9yZS5hbGwoZGVmKTtcblxuICBkZWxldGUgZGVmLnVzZTtcbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgcHJpbnRmOiBbXCJubyB2YWxpZCBrZXkgZm91bmQgaW4gaXNzdWVyJ3Mgandrc191cmkgZm9yIGtleSBwYXJhbWV0ZXJzICVqXCIsIGRlZl0sXG4gICAgICBqd2tzOiBrZXlzdG9yZSxcbiAgICB9KTtcbiAgfVxuXG4gIGlmICghYWxsb3dNdWx0aSAmJiBrZXlzLmxlbmd0aCA+IDEgJiYgIWtpZCkge1xuICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgIHByaW50ZjogW1xuICAgICAgICBcIm11bHRpcGxlIG1hdGNoaW5nIGtleXMgZm91bmQgaW4gaXNzdWVyJ3Mgandrc191cmkgZm9yIGtleSBwYXJhbWV0ZXJzICVqLCBraWQgbXVzdCBiZSBwcm92aWRlZCBpbiB0aGlzIGNhc2VcIixcbiAgICAgICAgZGVmLFxuICAgICAgXSxcbiAgICAgIGp3a3M6IGtleXN0b3JlLFxuICAgIH0pO1xuICB9XG5cbiAgY2FjaGUuc2V0KGRlZkhhc2gsIHRydWUpO1xuXG4gIHJldHVybiBrZXlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5xdWVyeUtleVN0b3JlID0gcXVlcnlLZXlTdG9yZTtcbm1vZHVsZS5leHBvcnRzLmtleXN0b3JlID0gZ2V0S2V5U3RvcmU7XG4iXSwibmFtZXMiOlsib2JqZWN0SGFzaCIsInJlcXVpcmUiLCJMUlUiLCJSUEVycm9yIiwiYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbiIsIktleVN0b3JlIiwia2V5c3RvcmVzIiwicHJvY2Vzc1Jlc3BvbnNlIiwicmVxdWVzdCIsImluRmxpZ2h0IiwiV2Vha01hcCIsImNhY2hlcyIsImxydXMiLCJjdHgiLCJoYXMiLCJzZXQiLCJtYXgiLCJnZXQiLCJnZXRLZXlTdG9yZSIsInJlbG9hZCIsImtleXN0b3JlIiwiY2FjaGUiLCJyZXNldCIsInJlc3BvbnNlIiwiY2FsbCIsIm1ldGhvZCIsInJlc3BvbnNlVHlwZSIsInVybCIsImp3a3NfdXJpIiwiaGVhZGVycyIsIkFjY2VwdCIsImZpbmFsbHkiLCJkZWxldGUiLCJqd2tzIiwiam9zZUtleVN0b3JlIiwiZnJvbUpXS1MiLCJvbmx5UHVibGljIiwicXVlcnlLZXlTdG9yZSIsImtpZCIsImt0eSIsImFsZyIsInVzZSIsImFsbG93TXVsdGkiLCJkZWYiLCJkZWZIYXNoIiwiYWxnb3JpdGhtIiwiaWdub3JlVW5rbm93biIsInVub3JkZXJlZEFycmF5cyIsInVub3JkZXJlZFNldHMiLCJmcmVzaEp3a3NVcmkiLCJrZXlzIiwiYWxsIiwibGVuZ3RoIiwicHJpbnRmIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/issuer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/keystore.js":
/*!************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/keystore.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const jose = __webpack_require__(/*! jose */ \"(rsc)/./node_modules/jose/dist/node/cjs/index.js\");\nconst clone = __webpack_require__(/*! ./deep_clone */ \"(rsc)/./node_modules/openid-client/lib/helpers/deep_clone.js\");\nconst isPlainObject = __webpack_require__(/*! ./is_plain_object */ \"(rsc)/./node_modules/openid-client/lib/helpers/is_plain_object.js\");\nconst isKeyObject = __webpack_require__(/*! ./is_key_object */ \"(rsc)/./node_modules/openid-client/lib/helpers/is_key_object.js\");\nconst internal = Symbol();\nfunction fauxAlg(kty) {\n    switch(kty){\n        case \"RSA\":\n            return \"RSA-OAEP\";\n        case \"EC\":\n            return \"ECDH-ES\";\n        case \"OKP\":\n            return \"ECDH-ES\";\n        case \"oct\":\n            return \"HS256\";\n        default:\n            return undefined;\n    }\n}\nconst keyscore = (key, { alg, use })=>{\n    let score = 0;\n    if (alg && key.alg) {\n        score++;\n    }\n    if (use && key.use) {\n        score++;\n    }\n    return score;\n};\nfunction getKtyFromAlg(alg) {\n    switch(typeof alg === \"string\" && alg.slice(0, 2)){\n        case \"RS\":\n        case \"PS\":\n            return \"RSA\";\n        case \"ES\":\n            return \"EC\";\n        case \"Ed\":\n            return \"OKP\";\n        default:\n            return undefined;\n    }\n}\nfunction getAlgorithms(use, alg, kty, crv) {\n    // Ed25519, Ed448, and secp256k1 always have \"alg\"\n    // OKP always has use\n    if (alg) {\n        return new Set([\n            alg\n        ]);\n    }\n    switch(kty){\n        case \"EC\":\n            {\n                let algs = [];\n                if (use === \"enc\" || use === undefined) {\n                    algs = algs.concat([\n                        \"ECDH-ES\",\n                        \"ECDH-ES+A128KW\",\n                        \"ECDH-ES+A192KW\",\n                        \"ECDH-ES+A256KW\"\n                    ]);\n                }\n                if (use === \"sig\" || use === undefined) {\n                    algs = algs.concat([\n                        `ES${crv.slice(-3)}`.replace(\"21\", \"12\")\n                    ]);\n                }\n                return new Set(algs);\n            }\n        case \"OKP\":\n            {\n                return new Set([\n                    \"ECDH-ES\",\n                    \"ECDH-ES+A128KW\",\n                    \"ECDH-ES+A192KW\",\n                    \"ECDH-ES+A256KW\"\n                ]);\n            }\n        case \"RSA\":\n            {\n                let algs = [];\n                if (use === \"enc\" || use === undefined) {\n                    algs = algs.concat([\n                        \"RSA-OAEP\",\n                        \"RSA-OAEP-256\",\n                        \"RSA-OAEP-384\",\n                        \"RSA-OAEP-512\",\n                        \"RSA1_5\"\n                    ]);\n                }\n                if (use === \"sig\" || use === undefined) {\n                    algs = algs.concat([\n                        \"PS256\",\n                        \"PS384\",\n                        \"PS512\",\n                        \"RS256\",\n                        \"RS384\",\n                        \"RS512\"\n                    ]);\n                }\n                return new Set(algs);\n            }\n        default:\n            throw new Error(\"unreachable\");\n    }\n}\nmodule.exports = class KeyStore {\n    #keys;\n    constructor(i, keys){\n        if (i !== internal) throw new Error(\"invalid constructor call\");\n        this.#keys = keys;\n    }\n    toJWKS() {\n        return {\n            keys: this.map(({ jwk: { d, p, q, dp, dq, qi, ...jwk } })=>jwk)\n        };\n    }\n    all({ alg, kid, use } = {}) {\n        if (!use || !alg) {\n            throw new Error();\n        }\n        const kty = getKtyFromAlg(alg);\n        const search = {\n            alg,\n            use\n        };\n        return this.filter((key)=>{\n            let candidate = true;\n            if (candidate && kty !== undefined && key.jwk.kty !== kty) {\n                candidate = false;\n            }\n            if (candidate && kid !== undefined && key.jwk.kid !== kid) {\n                candidate = false;\n            }\n            if (candidate && use !== undefined && key.jwk.use !== undefined && key.jwk.use !== use) {\n                candidate = false;\n            }\n            if (candidate && key.jwk.alg && key.jwk.alg !== alg) {\n                candidate = false;\n            } else if (!key.algorithms.has(alg)) {\n                candidate = false;\n            }\n            return candidate;\n        }).sort((first, second)=>keyscore(second, search) - keyscore(first, search));\n    }\n    get(...args) {\n        return this.all(...args)[0];\n    }\n    static async fromJWKS(jwks, { onlyPublic = false, onlyPrivate = false } = {}) {\n        if (!isPlainObject(jwks) || !Array.isArray(jwks.keys) || jwks.keys.some((k)=>!isPlainObject(k) || !(\"kty\" in k))) {\n            throw new TypeError(\"jwks must be a JSON Web Key Set formatted object\");\n        }\n        const keys = [];\n        for (let jwk of jwks.keys){\n            jwk = clone(jwk);\n            const { kty, kid, crv } = jwk;\n            let { alg, use } = jwk;\n            if (typeof kty !== \"string\" || !kty) {\n                continue;\n            }\n            if (use !== undefined && use !== \"sig\" && use !== \"enc\") {\n                continue;\n            }\n            if (typeof alg !== \"string\" && alg !== undefined) {\n                continue;\n            }\n            if (typeof kid !== \"string\" && kid !== undefined) {\n                continue;\n            }\n            if (kty === \"EC\" && use === \"sig\") {\n                switch(crv){\n                    case \"P-256\":\n                        alg = \"ES256\";\n                        break;\n                    case \"P-384\":\n                        alg = \"ES384\";\n                        break;\n                    case \"P-521\":\n                        alg = \"ES512\";\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (crv === \"secp256k1\") {\n                use = \"sig\";\n                alg = \"ES256K\";\n            }\n            if (kty === \"OKP\") {\n                switch(crv){\n                    case \"Ed25519\":\n                    case \"Ed448\":\n                        use = \"sig\";\n                        alg = \"EdDSA\";\n                        break;\n                    case \"X25519\":\n                    case \"X448\":\n                        use = \"enc\";\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (alg && !use) {\n                switch(true){\n                    case alg.startsWith(\"ECDH\"):\n                        use = \"enc\";\n                        break;\n                    case alg.startsWith(\"RSA\"):\n                        use = \"enc\";\n                        break;\n                    default:\n                        break;\n                }\n            }\n            const keyObject = await jose.importJWK(jwk, alg || fauxAlg(jwk.kty)).catch(()=>{});\n            if (!keyObject) continue;\n            if (keyObject instanceof Uint8Array || keyObject.type === \"secret\") {\n                if (onlyPrivate) {\n                    throw new Error(\"jwks must only contain private keys\");\n                }\n                continue;\n            }\n            if (!isKeyObject(keyObject)) {\n                throw new Error(\"what?!\");\n            }\n            if (onlyPrivate && keyObject.type !== \"private\") {\n                throw new Error(\"jwks must only contain private keys\");\n            }\n            if (onlyPublic && keyObject.type !== \"public\") {\n                continue;\n            }\n            if (kty === \"RSA\" && keyObject.asymmetricKeySize < 2048) {\n                continue;\n            }\n            keys.push({\n                jwk: {\n                    ...jwk,\n                    alg,\n                    use\n                },\n                keyObject,\n                get algorithms () {\n                    Object.defineProperty(this, \"algorithms\", {\n                        value: getAlgorithms(this.jwk.use, this.jwk.alg, this.jwk.kty, this.jwk.crv),\n                        enumerable: true,\n                        configurable: false\n                    });\n                    return this.algorithms;\n                }\n            });\n        }\n        return new this(internal, keys);\n    }\n    filter(...args) {\n        return this.#keys.filter(...args);\n    }\n    find(...args) {\n        return this.#keys.find(...args);\n    }\n    every(...args) {\n        return this.#keys.every(...args);\n    }\n    some(...args) {\n        return this.#keys.some(...args);\n    }\n    map(...args) {\n        return this.#keys.map(...args);\n    }\n    forEach(...args) {\n        return this.#keys.forEach(...args);\n    }\n    reduce(...args) {\n        return this.#keys.reduce(...args);\n    }\n    sort(...args) {\n        return this.#keys.sort(...args);\n    }\n    *[Symbol.iterator]() {\n        for (const key of this.#keys){\n            yield key;\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9rZXlzdG9yZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUVyQixNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUN0QixNQUFNRSxnQkFBZ0JGLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1HLGNBQWNILG1CQUFPQSxDQUFDO0FBRTVCLE1BQU1JLFdBQVdDO0FBRWpCLFNBQVNDLFFBQVFDLEdBQUc7SUFDbEIsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQ0UsT0FBT0M7SUFDWDtBQUNGO0FBRUEsTUFBTUMsV0FBVyxDQUFDQyxLQUFLLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFO0lBQ2pDLElBQUlDLFFBQVE7SUFFWixJQUFJRixPQUFPRCxJQUFJQyxHQUFHLEVBQUU7UUFDbEJFO0lBQ0Y7SUFFQSxJQUFJRCxPQUFPRixJQUFJRSxHQUFHLEVBQUU7UUFDbEJDO0lBQ0Y7SUFFQSxPQUFPQTtBQUNUO0FBRUEsU0FBU0MsY0FBY0gsR0FBRztJQUN4QixPQUFRLE9BQU9BLFFBQVEsWUFBWUEsSUFBSUksS0FBSyxDQUFDLEdBQUc7UUFDOUMsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQ0UsT0FBT1A7SUFDWDtBQUNGO0FBRUEsU0FBU1EsY0FBY0osR0FBRyxFQUFFRCxHQUFHLEVBQUVKLEdBQUcsRUFBRVUsR0FBRztJQUN2QyxrREFBa0Q7SUFDbEQscUJBQXFCO0lBQ3JCLElBQUlOLEtBQUs7UUFDUCxPQUFPLElBQUlPLElBQUk7WUFBQ1A7U0FBSTtJQUN0QjtJQUVBLE9BQVFKO1FBQ04sS0FBSztZQUFNO2dCQUNULElBQUlZLE9BQU8sRUFB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Q0FBQ3ZCLElBQUksQ0FBQ2lELE1BQU0sSUFBSTFCO0lBQzlCO0lBRUFKLEtBQUssR0FBR0ksSUFBSSxFQUFFO1FBQ1osT0FBTyxJQUFJLENBQUMsQ0FBQ3ZCLElBQUksQ0FBQ21CLElBQUksSUFBSUk7SUFDNUI7SUFFQSxDQUFDLENBQUM1QyxPQUFPdUUsUUFBUSxDQUFDLEdBQUc7UUFDbkIsS0FBSyxNQUFNbEUsT0FBTyxJQUFJLENBQUMsQ0FBQ2dCLElBQUksQ0FBRTtZQUM1QixNQUFNaEI7UUFDUjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWF1dGgtcmVnaXN0ZXIvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9rZXlzdG9yZS5qcz84ZjhiIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGpvc2UgPSByZXF1aXJlKCdqb3NlJyk7XG5cbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi9kZWVwX2Nsb25lJyk7XG5jb25zdCBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi9pc19wbGFpbl9vYmplY3QnKTtcbmNvbnN0IGlzS2V5T2JqZWN0ID0gcmVxdWlyZSgnLi9pc19rZXlfb2JqZWN0Jyk7XG5cbmNvbnN0IGludGVybmFsID0gU3ltYm9sKCk7XG5cbmZ1bmN0aW9uIGZhdXhBbGcoa3R5KSB7XG4gIHN3aXRjaCAoa3R5KSB7XG4gICAgY2FzZSAnUlNBJzpcbiAgICAgIHJldHVybiAnUlNBLU9BRVAnO1xuICAgIGNhc2UgJ0VDJzpcbiAgICAgIHJldHVybiAnRUNESC1FUyc7XG4gICAgY2FzZSAnT0tQJzpcbiAgICAgIHJldHVybiAnRUNESC1FUyc7XG4gICAgY2FzZSAnb2N0JzpcbiAgICAgIHJldHVybiAnSFMyNTYnO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmNvbnN0IGtleXNjb3JlID0gKGtleSwgeyBhbGcsIHVzZSB9KSA9PiB7XG4gIGxldCBzY29yZSA9IDA7XG5cbiAgaWYgKGFsZyAmJiBrZXkuYWxnKSB7XG4gICAgc2NvcmUrKztcbiAgfVxuXG4gIGlmICh1c2UgJiYga2V5LnVzZSkge1xuICAgIHNjb3JlKys7XG4gIH1cblxuICByZXR1cm4gc2NvcmU7XG59O1xuXG5mdW5jdGlvbiBnZXRLdHlGcm9tQWxnKGFsZykge1xuICBzd2l0Y2ggKHR5cGVvZiBhbGcgPT09ICdzdHJpbmcnICYmIGFsZy5zbGljZSgwLCAyKSkge1xuICAgIGNhc2UgJ1JTJzpcbiAgICBjYXNlICdQUyc6XG4gICAgICByZXR1cm4gJ1JTQSc7XG4gICAgY2FzZSAnRVMnOlxuICAgICAgcmV0dXJuICdFQyc7XG4gICAgY2FzZSAnRWQnOlxuICAgICAgcmV0dXJuICdPS1AnO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFsZ29yaXRobXModXNlLCBhbGcsIGt0eSwgY3J2KSB7XG4gIC8vIEVkMjU1MTksIEVkNDQ4LCBhbmQgc2VjcDI1NmsxIGFsd2F5cyBoYXZlIFwiYWxnXCJcbiAgLy8gT0tQIGFsd2F5cyBoYXMgdXNlXG4gIGlmIChhbGcpIHtcbiAgICByZXR1cm4gbmV3IFNldChbYWxnXSk7XG4gIH1cblxuICBzd2l0Y2ggKGt0eSkge1xuICAgIGNhc2UgJ0VDJzoge1xuICAgICAgbGV0IGFsZ3MgPSBbXTtcblxuICAgICAgaWYgKHVzZSA9PT0gJ2VuYycgfHwgdXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWxncyA9IGFsZ3MuY29uY2F0KFsnRUNESC1FUycsICdFQ0RILUVTK0ExMjhLVycsICdFQ0RILUVTK0ExOTJLVycsICdFQ0RILUVTK0EyNTZLVyddKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVzZSA9PT0gJ3NpZycgfHwgdXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWxncyA9IGFsZ3MuY29uY2F0KFtgRVMke2Nydi5zbGljZSgtMyl9YC5yZXBsYWNlKCcyMScsICcxMicpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgU2V0KGFsZ3MpO1xuICAgIH1cbiAgICBjYXNlICdPS1AnOiB7XG4gICAgICByZXR1cm4gbmV3IFNldChbJ0VDREgtRVMnLCAnRUNESC1FUytBMTI4S1cnLCAnRUNESC1FUytBMTkyS1cnLCAnRUNESC1FUytBMjU2S1cnXSk7XG4gICAgfVxuICAgIGNhc2UgJ1JTQSc6IHtcbiAgICAgIGxldCBhbGdzID0gW107XG5cbiAgICAgIGlmICh1c2UgPT09ICdlbmMnIHx8IHVzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFsZ3MgPSBhbGdzLmNvbmNhdChbJ1JTQS1PQUVQJywgJ1JTQS1PQUVQLTI1NicsICdSU0EtT0FFUC0zODQnLCAnUlNBLU9BRVAtNTEyJywgJ1JTQTFfNSddKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVzZSA9PT0gJ3NpZycgfHwgdXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWxncyA9IGFsZ3MuY29uY2F0KFsnUFMyNTYnLCAnUFMzODQnLCAnUFM1MTInLCAnUlMyNTYnLCAnUlMzODQnLCAnUlM1MTInXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgU2V0KGFsZ3MpO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZScpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgS2V5U3RvcmUge1xuICAja2V5cztcblxuICBjb25zdHJ1Y3RvcihpLCBrZXlzKSB7XG4gICAgaWYgKGkgIT09IGludGVybmFsKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY29uc3RydWN0b3IgY2FsbCcpO1xuICAgIHRoaXMuI2tleXMgPSBrZXlzO1xuICB9XG5cbiAgdG9KV0tTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlzOiB0aGlzLm1hcCgoeyBqd2s6IHsgZCwgcCwgcSwgZHAsIGRxLCBxaSwgLi4uandrIH0gfSkgPT4gandrKSxcbiAgICB9O1xuICB9XG5cbiAgYWxsKHsgYWxnLCBraWQsIHVzZSB9ID0ge30pIHtcbiAgICBpZiAoIXVzZSB8fCAhYWxnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG5cbiAgICBjb25zdCBrdHkgPSBnZXRLdHlGcm9tQWxnKGFsZyk7XG5cbiAgICBjb25zdCBzZWFyY2ggPSB7IGFsZywgdXNlIH07XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyKChrZXkpID0+IHtcbiAgICAgIGxldCBjYW5kaWRhdGUgPSB0cnVlO1xuXG4gICAgICBpZiAoY2FuZGlkYXRlICYmIGt0eSAhPT0gdW5kZWZpbmVkICYmIGtleS5qd2sua3R5ICE9PSBrdHkpIHtcbiAgICAgICAgY2FuZGlkYXRlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5kaWRhdGUgJiYga2lkICE9PSB1bmRlZmluZWQgJiYga2V5Lmp3ay5raWQgIT09IGtpZCkge1xuICAgICAgICBjYW5kaWRhdGUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbmRpZGF0ZSAmJiB1c2UgIT09IHVuZGVmaW5lZCAmJiBrZXkuandrLnVzZSAhPT0gdW5kZWZpbmVkICYmIGtleS5qd2sudXNlICE9PSB1c2UpIHtcbiAgICAgICAgY2FuZGlkYXRlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5kaWRhdGUgJiYga2V5Lmp3ay5hbGcgJiYga2V5Lmp3ay5hbGcgIT09IGFsZykge1xuICAgICAgICBjYW5kaWRhdGUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIWtleS5hbGdvcml0aG1zLmhhcyhhbGcpKSB7XG4gICAgICAgIGNhbmRpZGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FuZGlkYXRlO1xuICAgIH0pLnNvcnQoKGZpcnN0LCBzZWNvbmQpID0+IGtleXNjb3JlKHNlY29uZCwgc2VhcmNoKSAtIGtleXNjb3JlKGZpcnN0LCBzZWFyY2gpKTtcbiAgfVxuXG4gIGdldCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsKC4uLmFyZ3MpWzBdO1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIGZyb21KV0tTKGp3a3MsIHsgb25seVB1YmxpYyA9IGZhbHNlLCBvbmx5UHJpdmF0ZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIGlmIChcbiAgICAgICFpc1BsYWluT2JqZWN0KGp3a3MpIHx8XG4gICAgICAhQXJyYXkuaXNBcnJheShqd2tzLmtleXMpIHx8XG4gICAgICBqd2tzLmtleXMuc29tZSgoaykgPT4gIWlzUGxhaW5PYmplY3QoaykgfHwgISgna3R5JyBpbiBrKSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2p3a3MgbXVzdCBiZSBhIEpTT04gV2ViIEtleSBTZXQgZm9ybWF0dGVkIG9iamVjdCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGtleXMgPSBbXTtcblxuICAgIGZvciAobGV0IGp3ayBvZiBqd2tzLmtleXMpIHtcbiAgICAgIGp3ayA9IGNsb25lKGp3ayk7XG4gICAgICBjb25zdCB7IGt0eSwga2lkLCBjcnYgfSA9IGp3aztcblxuICAgICAgbGV0IHsgYWxnLCB1c2UgfSA9IGp3aztcblxuICAgICAgaWYgKHR5cGVvZiBrdHkgIT09ICdzdHJpbmcnIHx8ICFrdHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh1c2UgIT09IHVuZGVmaW5lZCAmJiB1c2UgIT09ICdzaWcnICYmIHVzZSAhPT0gJ2VuYycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgYWxnICE9PSAnc3RyaW5nJyAmJiBhbGcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBraWQgIT09ICdzdHJpbmcnICYmIGtpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoa3R5ID09PSAnRUMnICYmIHVzZSA9PT0gJ3NpZycpIHtcbiAgICAgICAgc3dpdGNoIChjcnYpIHtcbiAgICAgICAgICBjYXNlICdQLTI1Nic6XG4gICAgICAgICAgICBhbGcgPSAnRVMyNTYnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnUC0zODQnOlxuICAgICAgICAgICAgYWxnID0gJ0VTMzg0JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1AtNTIxJzpcbiAgICAgICAgICAgIGFsZyA9ICdFUzUxMic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNydiA9PT0gJ3NlY3AyNTZrMScpIHtcbiAgICAgICAgdXNlID0gJ3NpZyc7XG4gICAgICAgIGFsZyA9ICdFUzI1NksnO1xuICAgICAgfVxuXG4gICAgICBpZiAoa3R5ID09PSAnT0tQJykge1xuICAgICAgICBzd2l0Y2ggKGNydikge1xuICAgICAgICAgIGNhc2UgJ0VkMjU1MTknOlxuICAgICAgICAgIGNhc2UgJ0VkNDQ4JzpcbiAgICAgICAgICAgIHVzZSA9ICdzaWcnO1xuICAgICAgICAgICAgYWxnID0gJ0VkRFNBJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1gyNTUxOSc6XG4gICAgICAgICAgY2FzZSAnWDQ0OCc6XG4gICAgICAgICAgICB1c2UgPSAnZW5jJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWxnICYmICF1c2UpIHtcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgY2FzZSBhbGcuc3RhcnRzV2l0aCgnRUNESCcpOlxuICAgICAgICAgICAgdXNlID0gJ2VuYyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGFsZy5zdGFydHNXaXRoKCdSU0EnKTpcbiAgICAgICAgICAgIHVzZSA9ICdlbmMnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtleU9iamVjdCA9IGF3YWl0IGpvc2UuaW1wb3J0SldLKGp3aywgYWxnIHx8IGZhdXhBbGcoandrLmt0eSkpLmNhdGNoKCgpID0+IHt9KTtcblxuICAgICAgaWYgKCFrZXlPYmplY3QpIGNvbnRpbnVlO1xuXG4gICAgICBpZiAoa2V5T2JqZWN0IGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBrZXlPYmplY3QudHlwZSA9PT0gJ3NlY3JldCcpIHtcbiAgICAgICAgaWYgKG9ubHlQcml2YXRlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqd2tzIG11c3Qgb25seSBjb250YWluIHByaXZhdGUga2V5cycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzS2V5T2JqZWN0KGtleU9iamVjdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3aGF0PyEnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9ubHlQcml2YXRlICYmIGtleU9iamVjdC50eXBlICE9PSAncHJpdmF0ZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqd2tzIG11c3Qgb25seSBjb250YWluIHByaXZhdGUga2V5cycpO1xuICAgICAgfVxuXG4gICAgICBpZiAob25seVB1YmxpYyAmJiBrZXlPYmplY3QudHlwZSAhPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChrdHkgPT09ICdSU0EnICYmIGtleU9iamVjdC5hc3ltbWV0cmljS2V5U2l6ZSA8IDIwNDgpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIGp3azogeyAuLi5qd2ssIGFsZywgdXNlIH0sXG4gICAgICAgIGtleU9iamVjdCxcbiAgICAgICAgZ2V0IGFsZ29yaXRobXMoKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdhbGdvcml0aG1zJywge1xuICAgICAgICAgICAgdmFsdWU6IGdldEFsZ29yaXRobXModGhpcy5qd2sudXNlLCB0aGlzLmp3ay5hbGcsIHRoaXMuandrLmt0eSwgdGhpcy5qd2suY3J2KSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLmFsZ29yaXRobXM7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IHRoaXMoaW50ZXJuYWwsIGtleXMpO1xuICB9XG5cbiAgZmlsdGVyKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4ja2V5cy5maWx0ZXIoLi4uYXJncyk7XG4gIH1cblxuICBmaW5kKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4ja2V5cy5maW5kKC4uLmFyZ3MpO1xuICB9XG5cbiAgZXZlcnkoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLiNrZXlzLmV2ZXJ5KC4uLmFyZ3MpO1xuICB9XG5cbiAgc29tZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2tleXMuc29tZSguLi5hcmdzKTtcbiAgfVxuXG4gIG1hcCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2tleXMubWFwKC4uLmFyZ3MpO1xuICB9XG5cbiAgZm9yRWFjaCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2tleXMuZm9yRWFjaCguLi5hcmdzKTtcbiAgfVxuXG4gIHJlZHVjZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2tleXMucmVkdWNlKC4uLmFyZ3MpO1xuICB9XG5cbiAgc29ydCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2tleXMuc29ydCguLi5hcmdzKTtcbiAgfVxuXG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLiNrZXlzKSB7XG4gICAgICB5aWVsZCBrZXk7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbImpvc2UiLCJyZXF1aXJlIiwiY2xvbmUiLCJpc1BsYWluT2JqZWN0IiwiaXNLZXlPYmplY3QiLCJpbnRlcm5hbCIsIlN5bWJvbCIsImZhdXhBbGciLCJrdHkiLCJ1bmRlZmluZWQiLCJrZXlzY29yZSIsImtleSIsImFsZyIsInVzZSIsInNjb3JlIiwiZ2V0S3R5RnJvbUFsZyIsInNsaWNlIiwiZ2V0QWxnb3JpdGhtcyIsImNydiIsIlNldCIsImFsZ3MiLCJjb25jYXQiLCJyZXBsYWNlIiwiRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIiwiS2V5U3RvcmUiLCJrZXlzIiwiY29uc3RydWN0b3IiLCJpIiwidG9KV0tTIiwibWFwIiwiandrIiwiZCIsInAiLCJxIiwiZHAiLCJkcSIsInFpIiwiYWxsIiwia2lkIiwic2VhcmNoIiwiZmlsdGVyIiwiY2FuZGlkYXRlIiwiYWxnb3JpdGhtcyIsImhhcyIsInNvcnQiLCJmaXJzdCIsInNlY29uZCIsImdldCIsImFyZ3MiLCJmcm9tSldLUyIsImp3a3MiLCJvbmx5UHVibGljIiwib25seVByaXZhdGUiLCJBcnJheSIsImlzQXJyYXkiLCJzb21lIiwiayIsIlR5cGVFcnJvciIsInN0YXJ0c1dpdGgiLCJrZXlPYmplY3QiLCJpbXBvcnRKV0siLCJjYXRjaCIsIlVpbnQ4QXJyYXkiLCJ0eXBlIiwiYXN5bW1ldHJpY0tleVNpemUiLCJwdXNoIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJmaW5kIiwiZXZlcnkiLCJmb3JFYWNoIiwicmVkdWNlIiwiaXRlcmF0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/keystore.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/merge.js":
/*!*********************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/merge.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const isPlainObject = __webpack_require__(/*! ./is_plain_object */ \"(rsc)/./node_modules/openid-client/lib/helpers/is_plain_object.js\");\nfunction merge(target, ...sources) {\n    for (const source of sources){\n        if (!isPlainObject(source)) {\n            continue;\n        }\n        for (const [key, value] of Object.entries(source)){\n            /* istanbul ignore if */ if (key === \"__proto__\" || key === \"constructor\") {\n                continue;\n            }\n            if (isPlainObject(target[key]) && isPlainObject(value)) {\n                target[key] = merge(target[key], value);\n            } else if (typeof value !== \"undefined\") {\n                target[key] = value;\n            }\n        }\n    }\n    return target;\n}\nmodule.exports = merge;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9tZXJnZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxnQkFBZ0JDLG1CQUFPQSxDQUFDO0FBRTlCLFNBQVNDLE1BQU1DLE1BQU0sRUFBRSxHQUFHQyxPQUFPO0lBQy9CLEtBQUssTUFBTUMsVUFBVUQsUUFBUztRQUM1QixJQUFJLENBQUNKLGNBQWNLLFNBQVM7WUFDMUI7UUFDRjtRQUNBLEtBQUssTUFBTSxDQUFDQyxLQUFLQyxNQUFNLElBQUlDLE9BQU9DLE9BQU8sQ0FBQ0osUUFBUztZQUNqRCxzQkFBc0IsR0FDdEIsSUFBSUMsUUFBUSxlQUFlQSxRQUFRLGVBQWU7Z0JBQ2hEO1lBQ0Y7WUFDQSxJQUFJTixjQUFjRyxNQUFNLENBQUNHLElBQUksS0FBS04sY0FBY08sUUFBUTtnQkFDdERKLE1BQU0sQ0FBQ0csSUFBSSxHQUFHSixNQUFNQyxNQUFNLENBQUNHLElBQUksRUFBRUM7WUFDbkMsT0FBTyxJQUFJLE9BQU9BLFVBQVUsYUFBYTtnQkFDdkNKLE1BQU0sQ0FBQ0csSUFBSSxHQUFHQztZQUNoQjtRQUNGO0lBQ0Y7SUFFQSxPQUFPSjtBQUNUO0FBRUFPLE9BQU9DLE9BQU8sR0FBR1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWF1dGgtcmVnaXN0ZXIvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9tZXJnZS5qcz9hNThmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzX3BsYWluX29iamVjdCcpO1xuXG5mdW5jdGlvbiBtZXJnZSh0YXJnZXQsIC4uLnNvdXJjZXMpIHtcbiAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc291cmNlKSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdCh0YXJnZXRba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZSh0YXJnZXRba2V5XSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcbiJdLCJuYW1lcyI6WyJpc1BsYWluT2JqZWN0IiwicmVxdWlyZSIsIm1lcmdlIiwidGFyZ2V0Iiwic291cmNlcyIsInNvdXJjZSIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/merge.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/pick.js":
/*!********************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/pick.js ***!
  \********************************************************/
/***/ ((module) => {

eval("module.exports = function pick(object, ...paths) {\n    const obj = {};\n    for (const path of paths){\n        if (object[path] !== undefined) {\n            obj[path] = object[path];\n        }\n    }\n    return obj;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWF1dGgtcmVnaXN0ZXIvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9waWNrLmpzPzY4NjciXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwaWNrKG9iamVjdCwgLi4ucGF0aHMpIHtcbiAgY29uc3Qgb2JqID0ge307XG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGlmIChvYmplY3RbcGF0aF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgb2JqW3BhdGhdID0gb2JqZWN0W3BhdGhdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicGljayIsIm9iamVjdCIsInBhdGhzIiwib2JqIiwicGF0aCIsInVuZGVmaW5lZCJdLCJtYXBwaW5ncyI6IkFBQUFBLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxLQUFLQyxNQUFNLEVBQUUsR0FBR0MsS0FBSztJQUM3QyxNQUFNQyxNQUFNLENBQUM7SUFDYixLQUFLLE1BQU1DLFFBQVFGLE1BQU87UUFDeEIsSUFBSUQsTUFBTSxDQUFDRyxLQUFLLEtBQUtDLFdBQVc7WUFDOUJGLEdBQUcsQ0FBQ0MsS0FBSyxHQUFHSCxNQUFNLENBQUNHLEtBQUs7UUFDMUI7SUFDRjtJQUNBLE9BQU9EO0FBQ1QiLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9waWNrLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/pick.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/process_response.js":
/*!********************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/process_response.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { STATUS_CODES } = __webpack_require__(/*! http */ \"http\");\nconst { format } = __webpack_require__(/*! util */ \"util\");\nconst { OPError } = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/openid-client/lib/errors.js\");\nconst parseWwwAuthenticate = __webpack_require__(/*! ./www_authenticate_parser */ \"(rsc)/./node_modules/openid-client/lib/helpers/www_authenticate_parser.js\");\nconst throwAuthenticateErrors = (response)=>{\n    const params = parseWwwAuthenticate(response.headers[\"www-authenticate\"]);\n    if (params.error) {\n        throw new OPError(params, response);\n    }\n};\nconst isStandardBodyError = (response)=>{\n    let result = false;\n    try {\n        let jsonbody;\n        if (typeof response.body !== \"object\" || Buffer.isBuffer(response.body)) {\n            jsonbody = JSON.parse(response.body);\n        } else {\n            jsonbody = response.body;\n        }\n        result = typeof jsonbody.error === \"string\" && jsonbody.error.length;\n        if (result) Object.defineProperty(response, \"body\", {\n            value: jsonbody,\n            configurable: true\n        });\n    } catch (err) {}\n    return result;\n};\nfunction processResponse(response, { statusCode = 200, body = true, bearer = false } = {}) {\n    if (response.statusCode !== statusCode) {\n        if (bearer) {\n            throwAuthenticateErrors(response);\n        }\n        if (isStandardBodyError(response)) {\n            throw new OPError(response.body, response);\n        }\n        throw new OPError({\n            error: format(\"expected %i %s, got: %i %s\", statusCode, STATUS_CODES[statusCode], response.statusCode, STATUS_CODES[response.statusCode])\n        }, response);\n    }\n    if (body && !response.body) {\n        throw new OPError({\n            error: format(\"expected %i %s with body but no body was returned\", statusCode, STATUS_CODES[statusCode])\n        }, response);\n    }\n    return response.body;\n}\nmodule.exports = processResponse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9wcm9jZXNzX3Jlc3BvbnNlLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBRUEsWUFBWSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ2pDLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBRTNCLE1BQU0sRUFBRUUsT0FBTyxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1HLHVCQUF1QkgsbUJBQU9BLENBQUM7QUFFckMsTUFBTUksMEJBQTBCLENBQUNDO0lBQy9CLE1BQU1DLFNBQVNILHFCQUFxQkUsU0FBU0UsT0FBTyxDQUFDLG1CQUFtQjtJQUV4RSxJQUFJRCxPQUFPRSxLQUFLLEVBQUU7UUFDaEIsTUFBTSxJQUFJTixRQUFRSSxRQUFRRDtJQUM1QjtBQUNGO0FBRUEsTUFBTUksc0JBQXNCLENBQUNKO0lBQzNCLElBQUlLLFNBQVM7SUFDYixJQUFJO1FBQ0YsSUFBSUM7UUFDSixJQUFJLE9BQU9OLFNBQVNPLElBQUksS0FBSyxZQUFZQyxPQUFPQyxRQUFRLENBQUNULFNBQVNPLElBQUksR0FBRztZQUN2RUQsV0FBV0ksS0FBS0MsS0FBSyxDQUFDWCxTQUFTTyxJQUFJO1FBQ3JDLE9BQU87WUFDTEQsV0FBV04sU0FBU08sSUFBSTtRQUMxQjtRQUNBRixTQUFTLE9BQU9DLFNBQVNILEtBQUssS0FBSyxZQUFZRyxTQUFTSCxLQUFLLENBQUNTLE1BQU07UUFDcEUsSUFBSVAsUUFBUVEsT0FBT0MsY0FBYyxDQUFDZCxVQUFVLFFBQVE7WUFBRWUsT0FBT1Q7WUFBVVUsY0FBYztRQUFLO0lBQzVGLEVBQUUsT0FBT0MsS0FBSyxDQUFDO0lBRWYsT0FBT1o7QUFDVDtBQUVBLFNBQVNhLGdCQUFnQmxCLFFBQVEsRUFBRSxFQUFFbUIsYUFBYSxHQUFHLEVBQUVaLE9BQU8sSUFBSSxFQUFFYSxTQUFTLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztJQUN2RixJQUFJcEIsU0FBU21CLFVBQVUsS0FBS0EsWUFBWTtRQUN0QyxJQUFJQyxRQUFRO1lBQ1ZyQix3QkFBd0JDO1FBQzFCO1FBRUEsSUFBSUksb0JBQW9CSixXQUFXO1lBQ2pDLE1BQU0sSUFBSUgsUUFBUUcsU0FBU08sSUFBSSxFQUFFUDtRQUNuQztRQUVBLE1BQU0sSUFBSUgsUUFDUjtZQUNFTSxPQUFPUCxPQUNMLDhCQUNBdUIsWUFDQXpCLFlBQVksQ0FBQ3lCLFdBQVcsRUFDeEJuQixTQUFTbUIsVUFBVSxFQUNuQnpCLFlBQVksQ0FBQ00sU0FBU21CLFVBQVUsQ0FBQztRQUVyQyxHQUNBbkI7SUFFSjtJQUVBLElBQUlPLFFBQVEsQ0FBQ1AsU0FBU08sSUFBSSxFQUFFO1FBQzFCLE1BQU0sSUFBSVYsUUFDUjtZQUNFTSxPQUFPUCxPQUNMLHFEQUNBdUIsWUFDQXpCLFlBQVksQ0FBQ3lCLFdBQVc7UUFFNUIsR0FDQW5CO0lBRUo7SUFFQSxPQUFPQSxTQUFTTyxJQUFJO0FBQ3RCO0FBRUFjLE9BQU9DLE9BQU8sR0FBR0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWF1dGgtcmVnaXN0ZXIvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9wcm9jZXNzX3Jlc3BvbnNlLmpzPzdkZTciXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBTVEFUVVNfQ09ERVMgfSA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IHsgZm9ybWF0IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNvbnN0IHsgT1BFcnJvciB9ID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBwYXJzZVd3d0F1dGhlbnRpY2F0ZSA9IHJlcXVpcmUoJy4vd3d3X2F1dGhlbnRpY2F0ZV9wYXJzZXInKTtcblxuY29uc3QgdGhyb3dBdXRoZW50aWNhdGVFcnJvcnMgPSAocmVzcG9uc2UpID0+IHtcbiAgY29uc3QgcGFyYW1zID0gcGFyc2VXd3dBdXRoZW50aWNhdGUocmVzcG9uc2UuaGVhZGVyc1snd3d3LWF1dGhlbnRpY2F0ZSddKTtcblxuICBpZiAocGFyYW1zLmVycm9yKSB7XG4gICAgdGhyb3cgbmV3IE9QRXJyb3IocGFyYW1zLCByZXNwb25zZSk7XG4gIH1cbn07XG5cbmNvbnN0IGlzU3RhbmRhcmRCb2R5RXJyb3IgPSAocmVzcG9uc2UpID0+IHtcbiAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGxldCBqc29uYm9keTtcbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmJvZHkgIT09ICdvYmplY3QnIHx8IEJ1ZmZlci5pc0J1ZmZlcihyZXNwb25zZS5ib2R5KSkge1xuICAgICAganNvbmJvZHkgPSBKU09OLnBhcnNlKHJlc3BvbnNlLmJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBqc29uYm9keSA9IHJlc3BvbnNlLmJvZHk7XG4gICAgfVxuICAgIHJlc3VsdCA9IHR5cGVvZiBqc29uYm9keS5lcnJvciA9PT0gJ3N0cmluZycgJiYganNvbmJvZHkuZXJyb3IubGVuZ3RoO1xuICAgIGlmIChyZXN1bHQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwb25zZSwgJ2JvZHknLCB7IHZhbHVlOiBqc29uYm9keSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZXNwb25zZShyZXNwb25zZSwgeyBzdGF0dXNDb2RlID0gMjAwLCBib2R5ID0gdHJ1ZSwgYmVhcmVyID0gZmFsc2UgfSA9IHt9KSB7XG4gIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlICE9PSBzdGF0dXNDb2RlKSB7XG4gICAgaWYgKGJlYXJlcikge1xuICAgICAgdGhyb3dBdXRoZW50aWNhdGVFcnJvcnMocmVzcG9uc2UpO1xuICAgIH1cblxuICAgIGlmIChpc1N0YW5kYXJkQm9keUVycm9yKHJlc3BvbnNlKSkge1xuICAgICAgdGhyb3cgbmV3IE9QRXJyb3IocmVzcG9uc2UuYm9keSwgcmVzcG9uc2UpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBPUEVycm9yKFxuICAgICAge1xuICAgICAgICBlcnJvcjogZm9ybWF0KFxuICAgICAgICAgICdleHBlY3RlZCAlaSAlcywgZ290OiAlaSAlcycsXG4gICAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgICBTVEFUVVNfQ09ERVNbc3RhdHVzQ29kZV0sXG4gICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgICAgICBTVEFUVVNfQ09ERVNbcmVzcG9uc2Uuc3RhdHVzQ29kZV0sXG4gICAgICAgICksXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2UsXG4gICAgKTtcbiAgfVxuXG4gIGlmIChib2R5ICYmICFyZXNwb25zZS5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IE9QRXJyb3IoXG4gICAgICB7XG4gICAgICAgIGVycm9yOiBmb3JtYXQoXG4gICAgICAgICAgJ2V4cGVjdGVkICVpICVzIHdpdGggYm9keSBidXQgbm8gYm9keSB3YXMgcmV0dXJuZWQnLFxuICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgU1RBVFVTX0NPREVTW3N0YXR1c0NvZGVdLFxuICAgICAgICApLFxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNlLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2UuYm9keTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzUmVzcG9uc2U7XG4iXSwibmFtZXMiOlsiU1RBVFVTX0NPREVTIiwicmVxdWlyZSIsImZvcm1hdCIsIk9QRXJyb3IiLCJwYXJzZVd3d0F1dGhlbnRpY2F0ZSIsInRocm93QXV0aGVudGljYXRlRXJyb3JzIiwicmVzcG9uc2UiLCJwYXJhbXMiLCJoZWFkZXJzIiwiZXJyb3IiLCJpc1N0YW5kYXJkQm9keUVycm9yIiwicmVzdWx0IiwianNvbmJvZHkiLCJib2R5IiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJKU09OIiwicGFyc2UiLCJsZW5ndGgiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwiZXJyIiwicHJvY2Vzc1Jlc3BvbnNlIiwic3RhdHVzQ29kZSIsImJlYXJlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/process_response.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/request.js":
/*!***********************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/request.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const assert = __webpack_require__(/*! assert */ \"assert\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst { once } = __webpack_require__(/*! events */ \"events\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\nconst LRU = __webpack_require__(/*! lru-cache */ \"(rsc)/./node_modules/lru-cache/index.js\");\nconst pkg = __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/openid-client/package.json\");\nconst { RPError } = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/openid-client/lib/errors.js\");\nconst pick = __webpack_require__(/*! ./pick */ \"(rsc)/./node_modules/openid-client/lib/helpers/pick.js\");\nconst { deep: defaultsDeep } = __webpack_require__(/*! ./defaults */ \"(rsc)/./node_modules/openid-client/lib/helpers/defaults.js\");\nconst { HTTP_OPTIONS } = __webpack_require__(/*! ./consts */ \"(rsc)/./node_modules/openid-client/lib/helpers/consts.js\");\nlet DEFAULT_HTTP_OPTIONS;\nconst NQCHAR = /^[\\x21\\x23-\\x5B\\x5D-\\x7E]+$/;\nconst allowed = [\n    \"agent\",\n    \"ca\",\n    \"cert\",\n    \"crl\",\n    \"headers\",\n    \"key\",\n    \"lookup\",\n    \"passphrase\",\n    \"pfx\",\n    \"timeout\"\n];\nconst setDefaults = (props, options)=>{\n    DEFAULT_HTTP_OPTIONS = defaultsDeep({}, props.length ? pick(options, ...props) : options, DEFAULT_HTTP_OPTIONS);\n};\nsetDefaults([], {\n    headers: {\n        \"User-Agent\": `${pkg.name}/${pkg.version} (${pkg.homepage})`\n    },\n    timeout: 3500\n});\nfunction send(req, body, contentType) {\n    if (contentType) {\n        req.removeHeader(\"content-type\");\n        req.setHeader(\"content-type\", contentType);\n    }\n    if (body) {\n        req.removeHeader(\"content-length\");\n        req.setHeader(\"content-length\", Buffer.byteLength(body));\n        req.write(body);\n    }\n    req.end();\n}\nconst nonces = new LRU({\n    max: 100\n});\nmodule.exports = async function request(options, { accessToken, mTLS = false, DPoP } = {}) {\n    let url;\n    try {\n        url = new URL(options.url);\n        delete options.url;\n        assert(/^(https?:)$/.test(url.protocol));\n    } catch (err) {\n        throw new TypeError(\"only valid absolute URLs can be requested\");\n    }\n    const optsFn = this[HTTP_OPTIONS];\n    let opts = options;\n    const nonceKey = `${url.origin}${url.pathname}`;\n    if (DPoP && \"dpopProof\" in this) {\n        opts.headers = opts.headers || {};\n        opts.headers.DPoP = await this.dpopProof({\n            htu: `${url.origin}${url.pathname}`,\n            htm: options.method,\n            nonce: nonces.get(nonceKey)\n        }, DPoP, accessToken);\n    }\n    let userOptions;\n    if (optsFn) {\n        userOptions = pick(optsFn.call(this, url, defaultsDeep({}, opts, DEFAULT_HTTP_OPTIONS)), ...allowed);\n    }\n    opts = defaultsDeep({}, userOptions, opts, DEFAULT_HTTP_OPTIONS);\n    if (mTLS && !opts.pfx && !(opts.key && opts.cert)) {\n        throw new TypeError(\"mutual-TLS certificate and key not set\");\n    }\n    if (opts.searchParams) {\n        for (const [key, value] of Object.entries(opts.searchParams)){\n            url.searchParams.delete(key);\n            url.searchParams.set(key, value);\n        }\n    }\n    let responseType;\n    let form;\n    let json;\n    let body;\n    ({ form, responseType, json, body, ...opts } = opts);\n    for (const [key, value] of Object.entries(opts.headers || {})){\n        if (value === undefined) {\n            delete opts.headers[key];\n        }\n    }\n    let response;\n    const req = (url.protocol === \"https:\" ? https.request : http.request)(url.href, opts);\n    return (async ()=>{\n        if (json) {\n            send(req, JSON.stringify(json), \"application/json\");\n        } else if (form) {\n            send(req, querystring.stringify(form), \"application/x-www-form-urlencoded\");\n        } else if (body) {\n            send(req, body);\n        } else {\n            send(req);\n        }\n        [response] = await Promise.race([\n            once(req, \"response\"),\n            once(req, \"timeout\")\n        ]);\n        // timeout reached\n        if (!response) {\n            req.destroy();\n            throw new RPError(`outgoing request timed out after ${opts.timeout}ms`);\n        }\n        const parts = [];\n        for await (const part of response){\n            parts.push(part);\n        }\n        if (parts.length) {\n            switch(responseType){\n                case \"json\":\n                    {\n                        Object.defineProperty(response, \"body\", {\n                            get () {\n                                let value = Buffer.concat(parts);\n                                try {\n                                    value = JSON.parse(value);\n                                } catch (err) {\n                                    Object.defineProperty(err, \"response\", {\n                                        value: response\n                                    });\n                                    throw err;\n                                } finally{\n                                    Object.defineProperty(response, \"body\", {\n                                        value,\n                                        configurable: true\n                                    });\n                                }\n                                return value;\n                            },\n                            configurable: true\n                        });\n                        break;\n                    }\n                case undefined:\n                case \"buffer\":\n                    {\n                        Object.defineProperty(response, \"body\", {\n                            get () {\n                                const value = Buffer.concat(parts);\n                                Object.defineProperty(response, \"body\", {\n                                    value,\n                                    configurable: true\n                                });\n                                return value;\n                            },\n                            configurable: true\n                        });\n                        break;\n                    }\n                default:\n                    throw new TypeError(\"unsupported responseType request option\");\n            }\n        }\n        return response;\n    })().catch((err)=>{\n        if (response) Object.defineProperty(err, \"response\", {\n            value: response\n        });\n        throw err;\n    }).finally(()=>{\n        const dpopNonce = response && response.headers[\"dpop-nonce\"];\n        if (dpopNonce && NQCHAR.test(dpopNonce)) {\n            nonces.set(nonceKey, dpopNonce);\n        }\n    });\n};\nmodule.exports.setDefaults = setDefaults.bind(undefined, allowed);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9yZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1FLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1HLFFBQVFILG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU0sRUFBRUksSUFBSSxFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU0sRUFBRUssR0FBRyxFQUFFLEdBQUdMLG1CQUFPQSxDQUFDO0FBRXhCLE1BQU1NLE1BQU1OLG1CQUFPQSxDQUFDO0FBRXBCLE1BQU1PLE1BQU1QLG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU0sRUFBRVEsT0FBTyxFQUFFLEdBQUdSLG1CQUFPQSxDQUFDO0FBRTVCLE1BQU1TLE9BQU9ULG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRVUsTUFBTUMsWUFBWSxFQUFFLEdBQUdYLG1CQUFPQSxDQUFDO0FBQ3ZDLE1BQU0sRUFBRVksWUFBWSxFQUFFLEdBQUdaLG1CQUFPQSxDQUFDO0FBRWpDLElBQUlhO0FBQ0osTUFBTUMsU0FBUztBQUVmLE1BQU1DLFVBQVU7SUFDZDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsTUFBTUMsY0FBYyxDQUFDQyxPQUFPQztJQUMxQkwsdUJBQXVCRixhQUNyQixDQUFDLEdBQ0RNLE1BQU1FLE1BQU0sR0FBR1YsS0FBS1MsWUFBWUQsU0FBU0MsU0FDekNMO0FBRUo7QUFFQUcsWUFBWSxFQUFFLEVBQUU7SUFDZEksU0FBUztRQUFFLGNBQWMsQ0FBQyxFQUFFYixJQUFJYyxJQUFJLENBQUMsQ0FBQyxFQUFFZCxJQUFJZSxPQUFPLENBQUMsRUFBRSxFQUFFZixJQUFJZ0IsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUFDO0lBQ3hFQyxTQUFTO0FBQ1g7QUFFQSxT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b0NBQUs7Z0NBQ3RFO2dDQUNBLE9BQU90Qjs0QkFDVDs0QkFDQXNCLGNBQWM7d0JBQ2hCO3dCQUNBO29CQUNGO2dCQUNBLEtBQUtkO2dCQUNMLEtBQUs7b0JBQVU7d0JBQ2JQLE9BQU9rQixjQUFjLENBQUNWLFVBQVUsUUFBUTs0QkFDdENoQjtnQ0FDRSxNQUFNTyxRQUFRbEMsT0FBT3NELE1BQU0sQ0FBQ0o7Z0NBQzVCZixPQUFPa0IsY0FBYyxDQUFDVixVQUFVLFFBQVE7b0NBQUVUO29DQUFPc0IsY0FBYztnQ0FBSztnQ0FDcEUsT0FBT3RCOzRCQUNUOzRCQUNBc0IsY0FBYzt3QkFDaEI7d0JBQ0E7b0JBQ0Y7Z0JBQ0E7b0JBQ0UsTUFBTSxJQUFJeEMsVUFBVTtZQUN4QjtRQUNGO1FBRUEsT0FBTzJCO0lBQ1QsS0FDR2MsS0FBSyxDQUFDLENBQUMxQztRQUNOLElBQUk0QixVQUFVUixPQUFPa0IsY0FBYyxDQUFDdEMsS0FBSyxZQUFZO1lBQUVtQixPQUFPUztRQUFTO1FBQ3ZFLE1BQU01QjtJQUNSLEdBQ0MyQyxPQUFPLENBQUM7UUFDUCxNQUFNQyxZQUFZaEIsWUFBWUEsU0FBU3RELE9BQU8sQ0FBQyxhQUFhO1FBQzVELElBQUlzRSxhQUFhNUUsT0FBTzhCLElBQUksQ0FBQzhDLFlBQVk7WUFDdkN2RCxPQUFPa0MsR0FBRyxDQUFDbkIsVUFBVXdDO1FBQ3ZCO0lBQ0Y7QUFDSjtBQUVBckQsMEJBQTBCLEdBQUdyQixZQUFZMkUsSUFBSSxDQUFDbEIsV0FBVzFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hdXRoLXJlZ2lzdGVyLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvcmVxdWVzdC5qcz9hYzg3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuY29uc3QgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IHsgb25jZSB9ID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgndXJsJyk7XG5cbmNvbnN0IExSVSA9IHJlcXVpcmUoJ2xydS1jYWNoZScpO1xuXG5jb25zdCBwa2cgPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKTtcbmNvbnN0IHsgUlBFcnJvciB9ID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5cbmNvbnN0IHBpY2sgPSByZXF1aXJlKCcuL3BpY2snKTtcbmNvbnN0IHsgZGVlcDogZGVmYXVsdHNEZWVwIH0gPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5jb25zdCB7IEhUVFBfT1BUSU9OUyB9ID0gcmVxdWlyZSgnLi9jb25zdHMnKTtcblxubGV0IERFRkFVTFRfSFRUUF9PUFRJT05TO1xuY29uc3QgTlFDSEFSID0gL15bXFx4MjFcXHgyMy1cXHg1QlxceDVELVxceDdFXSskLztcblxuY29uc3QgYWxsb3dlZCA9IFtcbiAgJ2FnZW50JyxcbiAgJ2NhJyxcbiAgJ2NlcnQnLFxuICAnY3JsJyxcbiAgJ2hlYWRlcnMnLFxuICAna2V5JyxcbiAgJ2xvb2t1cCcsXG4gICdwYXNzcGhyYXNlJyxcbiAgJ3BmeCcsXG4gICd0aW1lb3V0Jyxcbl07XG5cbmNvbnN0IHNldERlZmF1bHRzID0gKHByb3BzLCBvcHRpb25zKSA9PiB7XG4gIERFRkFVTFRfSFRUUF9PUFRJT05TID0gZGVmYXVsdHNEZWVwKFxuICAgIHt9LFxuICAgIHByb3BzLmxlbmd0aCA/IHBpY2sob3B0aW9ucywgLi4ucHJvcHMpIDogb3B0aW9ucyxcbiAgICBERUZBVUxUX0hUVFBfT1BUSU9OUyxcbiAgKTtcbn07XG5cbnNldERlZmF1bHRzKFtdLCB7XG4gIGhlYWRlcnM6IHsgJ1VzZXItQWdlbnQnOiBgJHtwa2cubmFtZX0vJHtwa2cudmVyc2lvbn0gKCR7cGtnLmhvbWVwYWdlfSlgIH0sXG4gIHRpbWVvdXQ6IDM1MDAsXG59KTtcblxuZnVuY3Rpb24gc2VuZChyZXEsIGJvZHksIGNvbnRlbnRUeXBlKSB7XG4gIGlmIChjb250ZW50VHlwZSkge1xuICAgIHJlcS5yZW1vdmVIZWFkZXIoJ2NvbnRlbnQtdHlwZScpO1xuICAgIHJlcS5zZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsIGNvbnRlbnRUeXBlKTtcbiAgfVxuICBpZiAoYm9keSkge1xuICAgIHJlcS5yZW1vdmVIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJyk7XG4gICAgcmVxLnNldEhlYWRlcignY29udGVudC1sZW5ndGgnLCBCdWZmZXIuYnl0ZUxlbmd0aChib2R5KSk7XG4gICAgcmVxLndyaXRlKGJvZHkpO1xuICB9XG4gIHJlcS5lbmQoKTtcbn1cblxuY29uc3Qgbm9uY2VzID0gbmV3IExSVSh7IG1heDogMTAwIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzeW5jIGZ1bmN0aW9uIHJlcXVlc3Qob3B0aW9ucywgeyBhY2Nlc3NUb2tlbiwgbVRMUyA9IGZhbHNlLCBEUG9QIH0gPSB7fSkge1xuICBsZXQgdXJsO1xuICB0cnkge1xuICAgIHVybCA9IG5ldyBVUkwob3B0aW9ucy51cmwpO1xuICAgIGRlbGV0ZSBvcHRpb25zLnVybDtcbiAgICBhc3NlcnQoL14oaHR0cHM/OikkLy50ZXN0KHVybC5wcm90b2NvbCkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvbmx5IHZhbGlkIGFic29sdXRlIFVSTHMgY2FuIGJlIHJlcXVlc3RlZCcpO1xuICB9XG4gIGNvbnN0IG9wdHNGbiA9IHRoaXNbSFRUUF9PUFRJT05TXTtcbiAgbGV0IG9wdHMgPSBvcHRpb25zO1xuXG4gIGNvbnN0IG5vbmNlS2V5ID0gYCR7dXJsLm9yaWdpbn0ke3VybC5wYXRobmFtZX1gO1xuICBpZiAoRFBvUCAmJiAnZHBvcFByb29mJyBpbiB0aGlzKSB7XG4gICAgb3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9O1xuICAgIG9wdHMuaGVhZGVycy5EUG9QID0gYXdhaXQgdGhpcy5kcG9wUHJvb2YoXG4gICAgICB7XG4gICAgICAgIGh0dTogYCR7dXJsLm9yaWdpbn0ke3VybC5wYXRobmFtZX1gLFxuICAgICAgICBodG06IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICBub25jZTogbm9uY2VzLmdldChub25jZUtleSksXG4gICAgICB9LFxuICAgICAgRFBvUCxcbiAgICAgIGFjY2Vzc1Rva2VuLFxuICAgICk7XG4gIH1cblxuICBsZXQgdXNlck9wdGlvbnM7XG4gIGlmIChvcHRzRm4pIHtcbiAgICB1c2VyT3B0aW9ucyA9IHBpY2soXG4gICAgICBvcHRzRm4uY2FsbCh0aGlzLCB1cmwsIGRlZmF1bHRzRGVlcCh7fSwgb3B0cywgREVGQVVMVF9IVFRQX09QVElPTlMpKSxcbiAgICAgIC4uLmFsbG93ZWQsXG4gICAgKTtcbiAgfVxuICBvcHRzID0gZGVmYXVsdHNEZWVwKHt9LCB1c2VyT3B0aW9ucywgb3B0cywgREVGQVVMVF9IVFRQX09QVElPTlMpO1xuXG4gIGlmIChtVExTICYmICFvcHRzLnBmeCAmJiAhKG9wdHMua2V5ICYmIG9wdHMuY2VydCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXR1YWwtVExTIGNlcnRpZmljYXRlIGFuZCBrZXkgbm90IHNldCcpO1xuICB9XG5cbiAgaWYgKG9wdHMuc2VhcmNoUGFyYW1zKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0cy5zZWFyY2hQYXJhbXMpKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShrZXkpO1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHJlc3BvbnNlVHlwZTtcbiAgbGV0IGZvcm07XG4gIGxldCBqc29uO1xuICBsZXQgYm9keTtcbiAgKHsgZm9ybSwgcmVzcG9uc2VUeXBlLCBqc29uLCBib2R5LCAuLi5vcHRzIH0gPSBvcHRzKTtcblxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRzLmhlYWRlcnMgfHwge30pKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnNba2V5XTtcbiAgICB9XG4gIH1cblxuICBsZXQgcmVzcG9uc2U7XG4gIGNvbnN0IHJlcSA9ICh1cmwucHJvdG9jb2wgPT09ICdodHRwczonID8gaHR0cHMucmVxdWVzdCA6IGh0dHAucmVxdWVzdCkodXJsLmhyZWYsIG9wdHMpO1xuICByZXR1cm4gKGFzeW5jICgpID0+IHtcbiAgICBpZiAoanNvbikge1xuICAgICAgc2VuZChyZXEsIEpTT04uc3RyaW5naWZ5KGpzb24pLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIH0gZWxzZSBpZiAoZm9ybSkge1xuICAgICAgc2VuZChyZXEsIHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShmb3JtKSwgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xuICAgIH0gZWxzZSBpZiAoYm9keSkge1xuICAgICAgc2VuZChyZXEsIGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZW5kKHJlcSk7XG4gICAgfVxuXG4gICAgW3Jlc3BvbnNlXSA9IGF3YWl0IFByb21pc2UucmFjZShbb25jZShyZXEsICdyZXNwb25zZScpLCBvbmNlKHJlcSwgJ3RpbWVvdXQnKV0pO1xuXG4gICAgLy8gdGltZW91dCByZWFjaGVkXG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgcmVxLmRlc3Ryb3koKTtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKGBvdXRnb2luZyByZXF1ZXN0IHRpbWVkIG91dCBhZnRlciAke29wdHMudGltZW91dH1tc2ApO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcnRzID0gW107XG5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2YgcmVzcG9uc2UpIHtcbiAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuXG4gICAgaWYgKHBhcnRzLmxlbmd0aCkge1xuICAgICAgc3dpdGNoIChyZXNwb25zZVR5cGUpIHtcbiAgICAgICAgY2FzZSAnanNvbic6IHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzcG9uc2UsICdib2R5Jywge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBCdWZmZXIuY29uY2F0KHBhcnRzKTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCAncmVzcG9uc2UnLCB7IHZhbHVlOiByZXNwb25zZSB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3BvbnNlLCAnYm9keScsIHsgdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICBjYXNlICdidWZmZXInOiB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3BvbnNlLCAnYm9keScsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBCdWZmZXIuY29uY2F0KHBhcnRzKTtcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3BvbnNlLCAnYm9keScsIHsgdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Vuc3VwcG9ydGVkIHJlc3BvbnNlVHlwZSByZXF1ZXN0IG9wdGlvbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSkoKVxuICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2UpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsICdyZXNwb25zZScsIHsgdmFsdWU6IHJlc3BvbnNlIH0pO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pXG4gICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgY29uc3QgZHBvcE5vbmNlID0gcmVzcG9uc2UgJiYgcmVzcG9uc2UuaGVhZGVyc1snZHBvcC1ub25jZSddO1xuICAgICAgaWYgKGRwb3BOb25jZSAmJiBOUUNIQVIudGVzdChkcG9wTm9uY2UpKSB7XG4gICAgICAgIG5vbmNlcy5zZXQobm9uY2VLZXksIGRwb3BOb25jZSk7XG4gICAgICB9XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5zZXREZWZhdWx0cyA9IHNldERlZmF1bHRzLmJpbmQodW5kZWZpbmVkLCBhbGxvd2VkKTtcbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwicXVlcnlzdHJpbmciLCJodHRwIiwiaHR0cHMiLCJvbmNlIiwiVVJMIiwiTFJVIiwicGtnIiwiUlBFcnJvciIsInBpY2siLCJkZWVwIiwiZGVmYXVsdHNEZWVwIiwiSFRUUF9PUFRJT05TIiwiREVGQVVMVF9IVFRQX09QVElPTlMiLCJOUUNIQVIiLCJhbGxvd2VkIiwic2V0RGVmYXVsdHMiLCJwcm9wcyIsIm9wdGlvbnMiLCJsZW5ndGgiLCJoZWFkZXJzIiwibmFtZSIsInZlcnNpb24iLCJob21lcGFnZSIsInRpbWVvdXQiLCJzZW5kIiwicmVxIiwiYm9keSIsImNvbnRlbnRUeXBlIiwicmVtb3ZlSGVhZGVyIiwic2V0SGVhZGVyIiwiQnVmZmVyIiwiYnl0ZUxlbmd0aCIsIndyaXRlIiwiZW5kIiwibm9uY2VzIiwibWF4IiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVlc3QiLCJhY2Nlc3NUb2tlbiIsIm1UTFMiLCJEUG9QIiwidXJsIiwidGVzdCIsInByb3RvY29sIiwiZXJyIiwiVHlwZUVycm9yIiwib3B0c0ZuIiwib3B0cyIsIm5vbmNlS2V5Iiwib3JpZ2luIiwicGF0aG5hbWUiLCJkcG9wUHJvb2YiLCJodHUiLCJodG0iLCJtZXRob2QiLCJub25jZSIsImdldCIsInVzZXJPcHRpb25zIiwiY2FsbCIsInBmeCIsImtleSIsImNlcnQiLCJzZWFyY2hQYXJhbXMiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJkZWxldGUiLCJzZXQiLCJyZXNwb25zZVR5cGUiLCJmb3JtIiwianNvbiIsInVuZGVmaW5lZCIsInJlc3BvbnNlIiwiaHJlZiIsIkpTT04iLCJzdHJpbmdpZnkiLCJQcm9taXNlIiwicmFjZSIsImRlc3Ryb3kiLCJwYXJ0cyIsInBhcnQiLCJwdXNoIiwiZGVmaW5lUHJvcGVydHkiLCJjb25jYXQiLCJwYXJzZSIsImNvbmZpZ3VyYWJsZSIsImNhdGNoIiwiZmluYWxseSIsImRwb3BOb25jZSIsImJpbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/unix_timestamp.js":
/*!******************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/unix_timestamp.js ***!
  \******************************************************************/
/***/ ((module) => {

eval("module.exports = ()=>Math.floor(Date.now() / 1000);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWF1dGgtcmVnaXN0ZXIvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy91bml4X3RpbWVzdGFtcC5qcz80ZTdmIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gKCkgPT4gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIk1hdGgiLCJmbG9vciIsIkRhdGUiLCJub3ciXSwibWFwcGluZ3MiOiJBQUFBQSxPQUFPQyxPQUFPLEdBQUcsSUFBTUMsS0FBS0MsS0FBSyxDQUFDQyxLQUFLQyxHQUFHLEtBQUsiLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy91bml4X3RpbWVzdGFtcC5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/unix_timestamp.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/weak_cache.js":
/*!**************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/weak_cache.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("module.exports.keystores = new WeakMap();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy93ZWFrX2NhY2hlLmpzIiwibWFwcGluZ3MiOiJBQUFBQSx3QkFBd0IsR0FBRyxJQUFJRyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXV0aC1yZWdpc3Rlci8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL3dlYWtfY2FjaGUuanM/YzkzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cy5rZXlzdG9yZXMgPSBuZXcgV2Vha01hcCgpO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJrZXlzdG9yZXMiLCJXZWFrTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/weak_cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/webfinger_normalize.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/webfinger_normalize.js ***!
  \***********************************************************************/
/***/ ((module) => {

eval("// Credit: https://github.com/rohe/pyoidc/blob/master/src/oic/utils/webfinger.py\n// -- Normalization --\n// A string of any other type is interpreted as a URI either the form of scheme\n// \"://\" authority path-abempty [ \"?\" query ] [ \"#\" fragment ] or authority\n// path-abempty [ \"?\" query ] [ \"#\" fragment ] per RFC 3986 [RFC3986] and is\n// normalized according to the following rules:\n//\n// If the user input Identifier does not have an RFC 3986 [RFC3986] scheme\n// portion, the string is interpreted as [userinfo \"@\"] host [\":\" port]\n// path-abempty [ \"?\" query ] [ \"#\" fragment ] per RFC 3986 [RFC3986].\n// If the userinfo component is present and all of the path component, query\n// component, and port component are empty, the acct scheme is assumed. In this\n// case, the normalized URI is formed by prefixing acct: to the string as the\n// scheme. Per the 'acct' URI Scheme [I‑D.ietf‑appsawg‑acct‑uri], if there is an\n// at-sign character ('@') in the userinfo component, it needs to be\n// percent-encoded as described in RFC 3986 [RFC3986].\n// For all other inputs without a scheme portion, the https scheme is assumed,\n// and the normalized URI is formed by prefixing https:// to the string as the\n// scheme.\n// If the resulting URI contains a fragment portion, it MUST be stripped off\n// together with the fragment delimiter character \"#\".\n// The WebFinger [I‑D.ietf‑appsawg‑webfinger] Resource in this case is the\n// resulting URI, and the WebFinger Host is the authority component.\n//\n// Note: Since the definition of authority in RFC 3986 [RFC3986] is\n// [ userinfo \"@\" ] host [ \":\" port ], it is legal to have a user input\n// identifier like userinfo@host:port, e.g., alice@example.com:8080.\nconst PORT = /^\\d+$/;\nfunction hasScheme(input) {\n    if (input.includes(\"://\")) return true;\n    const authority = input.replace(/(\\/|\\?)/g, \"#\").split(\"#\")[0];\n    if (authority.includes(\":\")) {\n        const index = authority.indexOf(\":\");\n        const hostOrPort = authority.slice(index + 1);\n        if (!PORT.test(hostOrPort)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction acctSchemeAssumed(input) {\n    if (!input.includes(\"@\")) return false;\n    const parts = input.split(\"@\");\n    const host = parts[parts.length - 1];\n    return !(host.includes(\":\") || host.includes(\"/\") || host.includes(\"?\"));\n}\nfunction normalize(input) {\n    if (typeof input !== \"string\") {\n        throw new TypeError(\"input must be a string\");\n    }\n    let output;\n    if (hasScheme(input)) {\n        output = input;\n    } else if (acctSchemeAssumed(input)) {\n        output = `acct:${input}`;\n    } else {\n        output = `https://${input}`;\n    }\n    return output.split(\"#\")[0];\n}\nmodule.exports = normalize;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWF1dGgtcmVnaXN0ZXIvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy93ZWJmaW5nZXJfbm9ybWFsaXplLmpzPzM2NmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ3JlZGl0OiBodHRwczovL2dpdGh1Yi5jb20vcm9oZS9weW9pZGMvYmxvYi9tYXN0ZXIvc3JjL29pYy91dGlscy93ZWJmaW5nZXIucHlcblxuLy8gLS0gTm9ybWFsaXphdGlvbiAtLVxuLy8gQSBzdHJpbmcgb2YgYW55IG90aGVyIHR5cGUgaXMgaW50ZXJwcmV0ZWQgYXMgYSBVUkkgZWl0aGVyIHRoZSBmb3JtIG9mIHNjaGVtZVxuLy8gXCI6Ly9cIiBhdXRob3JpdHkgcGF0aC1hYmVtcHR5IFsgXCI/XCIgcXVlcnkgXSBbIFwiI1wiIGZyYWdtZW50IF0gb3IgYXV0aG9yaXR5XG4vLyBwYXRoLWFiZW1wdHkgWyBcIj9cIiBxdWVyeSBdIFsgXCIjXCIgZnJhZ21lbnQgXSBwZXIgUkZDIDM5ODYgW1JGQzM5ODZdIGFuZCBpc1xuLy8gbm9ybWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGZvbGxvd2luZyBydWxlczpcbi8vXG4vLyBJZiB0aGUgdXNlciBpbnB1dCBJZGVudGlmaWVyIGRvZXMgbm90IGhhdmUgYW4gUkZDIDM5ODYgW1JGQzM5ODZdIHNjaGVtZVxuLy8gcG9ydGlvbiwgdGhlIHN0cmluZyBpcyBpbnRlcnByZXRlZCBhcyBbdXNlcmluZm8gXCJAXCJdIGhvc3QgW1wiOlwiIHBvcnRdXG4vLyBwYXRoLWFiZW1wdHkgWyBcIj9cIiBxdWVyeSBdIFsgXCIjXCIgZnJhZ21lbnQgXSBwZXIgUkZDIDM5ODYgW1JGQzM5ODZdLlxuLy8gSWYgdGhlIHVzZXJpbmZvIGNvbXBvbmVudCBpcyBwcmVzZW50IGFuZCBhbGwgb2YgdGhlIHBhdGggY29tcG9uZW50LCBxdWVyeVxuLy8gY29tcG9uZW50LCBhbmQgcG9ydCBjb21wb25lbnQgYXJlIGVtcHR5LCB0aGUgYWNjdCBzY2hlbWUgaXMgYXNzdW1lZC4gSW4gdGhpc1xuLy8gY2FzZSwgdGhlIG5vcm1hbGl6ZWQgVVJJIGlzIGZvcm1lZCBieSBwcmVmaXhpbmcgYWNjdDogdG8gdGhlIHN0cmluZyBhcyB0aGVcbi8vIHNjaGVtZS4gUGVyIHRoZSAnYWNjdCcgVVJJIFNjaGVtZSBbSeKAkUQuaWV0ZuKAkWFwcHNhd2figJFhY2N04oCRdXJpXSwgaWYgdGhlcmUgaXMgYW5cbi8vIGF0LXNpZ24gY2hhcmFjdGVyICgnQCcpIGluIHRoZSB1c2VyaW5mbyBjb21wb25lbnQsIGl0IG5lZWRzIHRvIGJlXG4vLyBwZXJjZW50LWVuY29kZWQgYXMgZGVzY3JpYmVkIGluIFJGQyAzOTg2IFtSRkMzOTg2XS5cbi8vIEZvciBhbGwgb3RoZXIgaW5wdXRzIHdpdGhvdXQgYSBzY2hlbWUgcG9ydGlvbiwgdGhlIGh0dHBzIHNjaGVtZSBpcyBhc3N1bWVkLFxuLy8gYW5kIHRoZSBub3JtYWxpemVkIFVSSSBpcyBmb3JtZWQgYnkgcHJlZml4aW5nIGh0dHBzOi8vIHRvIHRoZSBzdHJpbmcgYXMgdGhlXG4vLyBzY2hlbWUuXG4vLyBJZiB0aGUgcmVzdWx0aW5nIFVSSSBjb250YWlucyBhIGZyYWdtZW50IHBvcnRpb24sIGl0IE1VU1QgYmUgc3RyaXBwZWQgb2ZmXG4vLyB0b2dldGhlciB3aXRoIHRoZSBmcmFnbWVudCBkZWxpbWl0ZXIgY2hhcmFjdGVyIFwiI1wiLlxuLy8gVGhlIFdlYkZpbmdlciBbSeKAkUQuaWV0ZuKAkWFwcHNhd2figJF3ZWJmaW5nZXJdIFJlc291cmNlIGluIHRoaXMgY2FzZSBpcyB0aGVcbi8vIHJlc3VsdGluZyBVUkksIGFuZCB0aGUgV2ViRmluZ2VyIEhvc3QgaXMgdGhlIGF1dGhvcml0eSBjb21wb25lbnQuXG4vL1xuLy8gTm90ZTogU2luY2UgdGhlIGRlZmluaXRpb24gb2YgYXV0aG9yaXR5IGluIFJGQyAzOTg2IFtSRkMzOTg2XSBpc1xuLy8gWyB1c2VyaW5mbyBcIkBcIiBdIGhvc3QgWyBcIjpcIiBwb3J0IF0sIGl0IGlzIGxlZ2FsIHRvIGhhdmUgYSB1c2VyIGlucHV0XG4vLyBpZGVudGlmaWVyIGxpa2UgdXNlcmluZm9AaG9zdDpwb3J0LCBlLmcuLCBhbGljZUBleGFtcGxlLmNvbTo4MDgwLlxuXG5jb25zdCBQT1JUID0gL15cXGQrJC87XG5cbmZ1bmN0aW9uIGhhc1NjaGVtZShpbnB1dCkge1xuICBpZiAoaW5wdXQuaW5jbHVkZXMoJzovLycpKSByZXR1cm4gdHJ1ZTtcblxuICBjb25zdCBhdXRob3JpdHkgPSBpbnB1dC5yZXBsYWNlKC8oXFwvfFxcPykvZywgJyMnKS5zcGxpdCgnIycpWzBdO1xuICBpZiAoYXV0aG9yaXR5LmluY2x1ZGVzKCc6JykpIHtcbiAgICBjb25zdCBpbmRleCA9IGF1dGhvcml0eS5pbmRleE9mKCc6Jyk7XG4gICAgY29uc3QgaG9zdE9yUG9ydCA9IGF1dGhvcml0eS5zbGljZShpbmRleCArIDEpO1xuICAgIGlmICghUE9SVC50ZXN0KGhvc3RPclBvcnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFjY3RTY2hlbWVBc3N1bWVkKGlucHV0KSB7XG4gIGlmICghaW5wdXQuaW5jbHVkZXMoJ0AnKSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwYXJ0cyA9IGlucHV0LnNwbGl0KCdAJyk7XG4gIGNvbnN0IGhvc3QgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuICEoaG9zdC5pbmNsdWRlcygnOicpIHx8IGhvc3QuaW5jbHVkZXMoJy8nKSB8fCBob3N0LmluY2x1ZGVzKCc/JykpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemUoaW5wdXQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnB1dCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBsZXQgb3V0cHV0O1xuICBpZiAoaGFzU2NoZW1lKGlucHV0KSkge1xuICAgIG91dHB1dCA9IGlucHV0O1xuICB9IGVsc2UgaWYgKGFjY3RTY2hlbWVBc3N1bWVkKGlucHV0KSkge1xuICAgIG91dHB1dCA9IGBhY2N0OiR7aW5wdXR9YDtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBgaHR0cHM6Ly8ke2lucHV0fWA7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0LnNwbGl0KCcjJylbMF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbm9ybWFsaXplO1xuIl0sIm5hbWVzIjpbIlBPUlQiLCJoYXNTY2hlbWUiLCJpbnB1dCIsImluY2x1ZGVzIiwiYXV0aG9yaXR5IiwicmVwbGFjZSIsInNwbGl0IiwiaW5kZXgiLCJpbmRleE9mIiwiaG9zdE9yUG9ydCIsInNsaWNlIiwidGVzdCIsImFjY3RTY2hlbWVBc3N1bWVkIiwicGFydHMiLCJob3N0IiwibGVuZ3RoIiwibm9ybWFsaXplIiwiVHlwZUVycm9yIiwib3V0cHV0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUEsZ0ZBQWdGO0FBRWhGLHNCQUFzQjtBQUN0QiwrRUFBK0U7QUFDL0UsMkVBQTJFO0FBQzNFLDRFQUE0RTtBQUM1RSwrQ0FBK0M7QUFDL0MsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx1RUFBdUU7QUFDdkUsc0VBQXNFO0FBQ3RFLDRFQUE0RTtBQUM1RSwrRUFBK0U7QUFDL0UsNkVBQTZFO0FBQzdFLGdGQUFnRjtBQUNoRixvRUFBb0U7QUFDcEUsc0RBQXNEO0FBQ3RELDhFQUE4RTtBQUM5RSw4RUFBOEU7QUFDOUUsVUFBVTtBQUNWLDRFQUE0RTtBQUM1RSxzREFBc0Q7QUFDdEQsMEVBQTBFO0FBQzFFLG9FQUFvRTtBQUNwRSxFQUFFO0FBQ0YsbUVBQW1FO0FBQ25FLHVFQUF1RTtBQUN2RSxvRUFBb0U7QUFFcEUsTUFBTUEsT0FBTztBQUViLFNBQVNDLFVBQVVDLEtBQUs7SUFDdEIsSUFBSUEsTUFBTUMsUUFBUSxDQUFDLFFBQVEsT0FBTztJQUVsQyxNQUFNQyxZQUFZRixNQUFNRyxPQUFPLENBQUMsWUFBWSxLQUFLQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7SUFDOUQsSUFBSUYsVUFBVUQsUUFBUSxDQUFDLE1BQU07UUFDM0IsTUFBTUksUUFBUUgsVUFBVUksT0FBTyxDQUFDO1FBQ2hDLE1BQU1DLGFBQWFMLFVBQVVNLEtBQUssQ0FBQ0gsUUFBUTtRQUMzQyxJQUFJLENBQUNQLEtBQUtXLElBQUksQ0FBQ0YsYUFBYTtZQUMxQixPQUFPO1FBQ1Q7SUFDRjtJQUVBLE9BQU87QUFDVDtBQUVBLFNBQVNHLGtCQUFrQlYsS0FBSztJQUM5QixJQUFJLENBQUNBLE1BQU1DLFFBQVEsQ0FBQyxNQUFNLE9BQU87SUFDakMsTUFBTVUsUUFBUVgsTUFBTUksS0FBSyxDQUFDO0lBQzFCLE1BQU1RLE9BQU9ELEtBQUssQ0FBQ0EsTUFBTUUsTUFBTSxHQUFHLEVBQUU7SUFDcEMsT0FBTyxDQUFFRCxDQUFBQSxLQUFLWCxRQUFRLENBQUMsUUFBUVcsS0FBS1gsUUFBUSxDQUFDLFFBQVFXLEtBQUtYLFFBQVEsQ0FBQyxJQUFHO0FBQ3hFO0FBRUEsU0FBU2EsVUFBVWQsS0FBSztJQUN0QixJQUFJLE9BQU9BLFVBQVUsVUFBVTtRQUM3QixNQUFNLElBQUllLFVBQVU7SUFDdEI7SUFFQSxJQUFJQztJQUNKLElBQUlqQixVQUFVQyxRQUFRO1FBQ3BCZ0IsU0FBU2hCO0lBQ1gsT0FBTyxJQUFJVSxrQkFBa0JWLFFBQVE7UUFDbkNnQixTQUFTLENBQUMsS0FBSyxFQUFFaEIsTUFBTSxDQUFDO0lBQzFCLE9BQU87UUFDTGdCLFNBQVMsQ0FBQyxRQUFRLEVBQUVoQixNQUFNLENBQUM7SUFDN0I7SUFFQSxPQUFPZ0IsT0FBT1osS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQzdCO0FBRUFhLE9BQU9DLE9BQU8sR0FBR0oiLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy93ZWJmaW5nZXJfbm9ybWFsaXplLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/webfinger_normalize.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/www_authenticate_parser.js":
/*!***************************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/www_authenticate_parser.js ***!
  \***************************************************************************/
/***/ ((module) => {

eval("const REGEXP = /(\\w+)=(\"[^\"]*\")/g;\nmodule.exports = (wwwAuthenticate)=>{\n    const params = {};\n    try {\n        while(REGEXP.exec(wwwAuthenticate) !== null){\n            if (RegExp.$1 && RegExp.$2) {\n                params[RegExp.$1] = RegExp.$2.slice(1, -1);\n            }\n        }\n    } catch (err) {}\n    return params;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWF1dGgtcmVnaXN0ZXIvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy93d3dfYXV0aGVudGljYXRlX3BhcnNlci5qcz9mMDBkIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFJFR0VYUCA9IC8oXFx3Kyk9KFwiW15cIl0qXCIpL2c7XG5cbm1vZHVsZS5leHBvcnRzID0gKHd3d0F1dGhlbnRpY2F0ZSkgPT4ge1xuICBjb25zdCBwYXJhbXMgPSB7fTtcbiAgdHJ5IHtcbiAgICB3aGlsZSAoUkVHRVhQLmV4ZWMod3d3QXV0aGVudGljYXRlKSAhPT0gbnVsbCkge1xuICAgICAgaWYgKFJlZ0V4cC4kMSAmJiBSZWdFeHAuJDIpIHtcbiAgICAgICAgcGFyYW1zW1JlZ0V4cC4kMV0gPSBSZWdFeHAuJDIuc2xpY2UoMSwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gIHJldHVybiBwYXJhbXM7XG59O1xuIl0sIm5hbWVzIjpbIlJFR0VYUCIsIm1vZHVsZSIsImV4cG9ydHMiLCJ3d3dBdXRoZW50aWNhdGUiLCJwYXJhbXMiLCJleGVjIiwiUmVnRXhwIiwiJDEiLCIkMiIsInNsaWNlIiwiZXJyIl0sIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxTQUFTO0FBRWZDLE9BQU9DLE9BQU8sR0FBRyxDQUFDQztJQUNoQixNQUFNQyxTQUFTLENBQUM7SUFDaEIsSUFBSTtRQUNGLE1BQU9KLE9BQU9LLElBQUksQ0FBQ0YscUJBQXFCLEtBQU07WUFDNUMsSUFBSUcsT0FBT0MsRUFBRSxJQUFJRCxPQUFPRSxFQUFFLEVBQUU7Z0JBQzFCSixNQUFNLENBQUNFLE9BQU9DLEVBQUUsQ0FBQyxHQUFHRCxPQUFPRSxFQUFFLENBQUNDLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDMUM7UUFDRjtJQUNGLEVBQUUsT0FBT0MsS0FBSyxDQUFDO0lBRWYsT0FBT047QUFDVCIsImZpbGUiOiIocnNjKS8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL3d3d19hdXRoZW50aWNhdGVfcGFyc2VyLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/www_authenticate_parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/openid-client/lib/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Issuer = __webpack_require__(/*! ./issuer */ \"(rsc)/./node_modules/openid-client/lib/issuer.js\");\nconst { OPError, RPError } = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/openid-client/lib/errors.js\");\nconst Strategy = __webpack_require__(/*! ./passport_strategy */ \"(rsc)/./node_modules/openid-client/lib/passport_strategy.js\");\nconst TokenSet = __webpack_require__(/*! ./token_set */ \"(rsc)/./node_modules/openid-client/lib/token_set.js\");\nconst { CLOCK_TOLERANCE, HTTP_OPTIONS } = __webpack_require__(/*! ./helpers/consts */ \"(rsc)/./node_modules/openid-client/lib/helpers/consts.js\");\nconst generators = __webpack_require__(/*! ./helpers/generators */ \"(rsc)/./node_modules/openid-client/lib/helpers/generators.js\");\nconst { setDefaults } = __webpack_require__(/*! ./helpers/request */ \"(rsc)/./node_modules/openid-client/lib/helpers/request.js\");\nmodule.exports = {\n    Issuer,\n    Strategy,\n    TokenSet,\n    errors: {\n        OPError,\n        RPError\n    },\n    custom: {\n        setHttpOptionsDefaults: setDefaults,\n        http_options: HTTP_OPTIONS,\n        clock_tolerance: CLOCK_TOLERANCE\n    },\n    generators\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUNyQyxNQUFNRyxXQUFXSCxtQkFBT0EsQ0FBQztBQUN6QixNQUFNSSxXQUFXSixtQkFBT0EsQ0FBQztBQUN6QixNQUFNLEVBQUVLLGVBQWUsRUFBRUMsWUFBWSxFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBQ2xELE1BQU1PLGFBQWFQLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRVEsV0FBVyxFQUFFLEdBQUdSLG1CQUFPQSxDQUFDO0FBRWhDUyxPQUFPQyxPQUFPLEdBQUc7SUFDZlg7SUFDQUk7SUFDQUM7SUFDQU8sUUFBUTtRQUNOVjtRQUNBQztJQUNGO0lBQ0FVLFFBQVE7UUFDTkMsd0JBQXdCTDtRQUN4Qk0sY0FBY1I7UUFDZFMsaUJBQWlCVjtJQUNuQjtJQUNBRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hdXRoLXJlZ2lzdGVyLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2luZGV4LmpzP2NmOTEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgSXNzdWVyID0gcmVxdWlyZSgnLi9pc3N1ZXInKTtcbmNvbnN0IHsgT1BFcnJvciwgUlBFcnJvciB9ID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IFN0cmF0ZWd5ID0gcmVxdWlyZSgnLi9wYXNzcG9ydF9zdHJhdGVneScpO1xuY29uc3QgVG9rZW5TZXQgPSByZXF1aXJlKCcuL3Rva2VuX3NldCcpO1xuY29uc3QgeyBDTE9DS19UT0xFUkFOQ0UsIEhUVFBfT1BUSU9OUyB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2NvbnN0cycpO1xuY29uc3QgZ2VuZXJhdG9ycyA9IHJlcXVpcmUoJy4vaGVscGVycy9nZW5lcmF0b3JzJyk7XG5jb25zdCB7IHNldERlZmF1bHRzIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvcmVxdWVzdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSXNzdWVyLFxuICBTdHJhdGVneSxcbiAgVG9rZW5TZXQsXG4gIGVycm9yczoge1xuICAgIE9QRXJyb3IsXG4gICAgUlBFcnJvcixcbiAgfSxcbiAgY3VzdG9tOiB7XG4gICAgc2V0SHR0cE9wdGlvbnNEZWZhdWx0czogc2V0RGVmYXVsdHMsXG4gICAgaHR0cF9vcHRpb25zOiBIVFRQX09QVElPTlMsXG4gICAgY2xvY2tfdG9sZXJhbmNlOiBDTE9DS19UT0xFUkFOQ0UsXG4gIH0sXG4gIGdlbmVyYXRvcnMsXG59O1xuIl0sIm5hbWVzIjpbIklzc3VlciIsInJlcXVpcmUiLCJPUEVycm9yIiwiUlBFcnJvciIsIlN0cmF0ZWd5IiwiVG9rZW5TZXQiLCJDTE9DS19UT0xFUkFOQ0UiLCJIVFRQX09QVElPTlMiLCJnZW5lcmF0b3JzIiwic2V0RGVmYXVsdHMiLCJtb2R1bGUiLCJleHBvcnRzIiwiZXJyb3JzIiwiY3VzdG9tIiwic2V0SHR0cE9wdGlvbnNEZWZhdWx0cyIsImh0dHBfb3B0aW9ucyIsImNsb2NrX3RvbGVyYW5jZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/issuer.js":
/*!**************************************************!*\
  !*** ./node_modules/openid-client/lib/issuer.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { inspect } = __webpack_require__(/*! util */ \"util\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst { RPError } = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/openid-client/lib/errors.js\");\nconst getClient = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/openid-client/lib/client.js\");\nconst registry = __webpack_require__(/*! ./issuer_registry */ \"(rsc)/./node_modules/openid-client/lib/issuer_registry.js\");\nconst processResponse = __webpack_require__(/*! ./helpers/process_response */ \"(rsc)/./node_modules/openid-client/lib/helpers/process_response.js\");\nconst webfingerNormalize = __webpack_require__(/*! ./helpers/webfinger_normalize */ \"(rsc)/./node_modules/openid-client/lib/helpers/webfinger_normalize.js\");\nconst request = __webpack_require__(/*! ./helpers/request */ \"(rsc)/./node_modules/openid-client/lib/helpers/request.js\");\nconst clone = __webpack_require__(/*! ./helpers/deep_clone */ \"(rsc)/./node_modules/openid-client/lib/helpers/deep_clone.js\");\nconst { keystore } = __webpack_require__(/*! ./helpers/issuer */ \"(rsc)/./node_modules/openid-client/lib/helpers/issuer.js\");\nconst AAD_MULTITENANT_DISCOVERY = [\n    \"https://login.microsoftonline.com/common/.well-known/openid-configuration\",\n    \"https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration\",\n    \"https://login.microsoftonline.com/organizations/v2.0/.well-known/openid-configuration\",\n    \"https://login.microsoftonline.com/consumers/v2.0/.well-known/openid-configuration\"\n];\nconst AAD_MULTITENANT = Symbol();\nconst ISSUER_DEFAULTS = {\n    claim_types_supported: [\n        \"normal\"\n    ],\n    claims_parameter_supported: false,\n    grant_types_supported: [\n        \"authorization_code\",\n        \"implicit\"\n    ],\n    request_parameter_supported: false,\n    request_uri_parameter_supported: true,\n    require_request_uri_registration: false,\n    response_modes_supported: [\n        \"query\",\n        \"fragment\"\n    ],\n    token_endpoint_auth_methods_supported: [\n        \"client_secret_basic\"\n    ]\n};\nclass Issuer {\n    #metadata;\n    constructor(meta = {}){\n        const aadIssValidation = meta[AAD_MULTITENANT];\n        delete meta[AAD_MULTITENANT];\n        [\n            \"introspection\",\n            \"revocation\"\n        ].forEach((endpoint)=>{\n            // if intro/revocation endpoint auth specific meta is missing use the token ones if they\n            // are defined\n            if (meta[`${endpoint}_endpoint`] && meta[`${endpoint}_endpoint_auth_methods_supported`] === undefined && meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] === undefined) {\n                if (meta.token_endpoint_auth_methods_supported) {\n                    meta[`${endpoint}_endpoint_auth_methods_supported`] = meta.token_endpoint_auth_methods_supported;\n                }\n                if (meta.token_endpoint_auth_signing_alg_values_supported) {\n                    meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] = meta.token_endpoint_auth_signing_alg_values_supported;\n                }\n            }\n        });\n        this.#metadata = new Map();\n        Object.entries(meta).forEach(([key, value])=>{\n            this.#metadata.set(key, value);\n            if (!this[key]) {\n                Object.defineProperty(this, key, {\n                    get () {\n                        return this.#metadata.get(key);\n                    },\n                    enumerable: true\n                });\n            }\n        });\n        registry.set(this.issuer, this);\n        const Client = getClient(this, aadIssValidation);\n        Object.defineProperties(this, {\n            Client: {\n                value: Client,\n                enumerable: true\n            },\n            FAPI1Client: {\n                value: class FAPI1Client extends Client {\n                },\n                enumerable: true\n            }\n        });\n    }\n    get metadata() {\n        return clone(Object.fromEntries(this.#metadata.entries()));\n    }\n    static async webfinger(input) {\n        const resource = webfingerNormalize(input);\n        const { host } = url.parse(resource);\n        const webfingerUrl = `https://${host}/.well-known/webfinger`;\n        const response = await request.call(this, {\n            method: \"GET\",\n            url: webfingerUrl,\n            responseType: \"json\",\n            searchParams: {\n                resource,\n                rel: \"http://openid.net/specs/connect/1.0/issuer\"\n            },\n            headers: {\n                Accept: \"application/json\"\n            }\n        });\n        const body = processResponse(response);\n        const location = Array.isArray(body.links) && body.links.find((link)=>typeof link === \"object\" && link.rel === \"http://openid.net/specs/connect/1.0/issuer\" && link.href);\n        if (!location) {\n            throw new RPError({\n                message: \"no issuer found in webfinger response\",\n                body\n            });\n        }\n        if (typeof location.href !== \"string\" || !location.href.startsWith(\"https://\")) {\n            throw new RPError({\n                printf: [\n                    \"invalid issuer location %s\",\n                    location.href\n                ],\n                body\n            });\n        }\n        const expectedIssuer = location.href;\n        if (registry.has(expectedIssuer)) {\n            return registry.get(expectedIssuer);\n        }\n        const issuer = await this.discover(expectedIssuer);\n        if (issuer.issuer !== expectedIssuer) {\n            registry.del(issuer.issuer);\n            throw new RPError(\"discovered issuer mismatch, expected %s, got: %s\", expectedIssuer, issuer.issuer);\n        }\n        return issuer;\n    }\n    static async discover(uri) {\n        const parsed = url.parse(uri);\n        if (parsed.pathname.includes(\"/.well-known/\")) {\n            const response = await request.call(this, {\n                method: \"GET\",\n                responseType: \"json\",\n                url: uri,\n                headers: {\n                    Accept: \"application/json\"\n                }\n            });\n            const body = processResponse(response);\n            return new Issuer({\n                ...ISSUER_DEFAULTS,\n                ...body,\n                [AAD_MULTITENANT]: !!AAD_MULTITENANT_DISCOVERY.find((discoveryURL)=>uri.startsWith(discoveryURL))\n            });\n        }\n        let pathname;\n        if (parsed.pathname.endsWith(\"/\")) {\n            pathname = `${parsed.pathname}.well-known/openid-configuration`;\n        } else {\n            pathname = `${parsed.pathname}/.well-known/openid-configuration`;\n        }\n        const wellKnownUri = url.format({\n            ...parsed,\n            pathname\n        });\n        const response = await request.call(this, {\n            method: \"GET\",\n            responseType: \"json\",\n            url: wellKnownUri,\n            headers: {\n                Accept: \"application/json\"\n            }\n        });\n        const body = processResponse(response);\n        return new Issuer({\n            ...ISSUER_DEFAULTS,\n            ...body,\n            [AAD_MULTITENANT]: !!AAD_MULTITENANT_DISCOVERY.find((discoveryURL)=>wellKnownUri.startsWith(discoveryURL))\n        });\n    }\n    async reloadJwksUri() {\n        await keystore.call(this, true);\n    }\n    /* istanbul ignore next */ [inspect.custom]() {\n        return `${this.constructor.name} ${inspect(this.metadata, {\n            depth: Infinity,\n            colors: process.stdout.isTTY,\n            compact: false,\n            sorted: true\n        })}`;\n    }\n}\nmodule.exports = Issuer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaXNzdWVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBRUEsT0FBTyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1DLE1BQU1ELG1CQUFPQSxDQUFDO0FBRXBCLE1BQU0sRUFBRUUsT0FBTyxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1HLFlBQVlILG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1JLFdBQVdKLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU1LLGtCQUFrQkwsbUJBQU9BLENBQUM7QUFDaEMsTUFBTU0scUJBQXFCTixtQkFBT0EsQ0FBQztBQUNuQyxNQUFNTyxVQUFVUCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNUSxRQUFRUixtQkFBT0EsQ0FBQztBQUN0QixNQUFNLEVBQUVTLFFBQVEsRUFBRSxHQUFHVCxtQkFBT0EsQ0FBQztBQUU3QixNQUFNVSw0QkFBNEI7SUFDaEM7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUNELE1BQU1DLGtCQUFrQkM7QUFDeEIsTUFBTUMsa0JBQWtCO0lBQ3RCQyx1QkFBdUI7UUFBQztLQUFTO0lBQ2pDQyw0QkFBNEI7SUFDNUJDLHVCQUF1QjtRQUFDO1FBQXNCO0tBQVc7SUFDekRDLDZCQUE2QjtJQUM3QkMsaUNBQWlDO0lBQ2pDQyxrQ0FBa0M7SUFDbENDLDBCQUEwQjtRQUFDO1FBQVM7S0FBVztJQUMvQ0MsdUNBQXVDO1FBQUM7S0FBc0I7QUFDaEU7QUFFQSxNQUFNQztJQUNKLENBQUNDLFFBQVEsQ0FBQztJQUNWQyxZQUFZQyxPQUFPLENBQUMsQ0FBQyxDQUFFO1FBQ3JCLE1BQU1DLG1CQUFtQkQsSUFBSSxDQUFDZCxnQkFBZ0I7UUFDOUMsT0FBT2MsSUFBSSxDQUFDZCxnQkFBZ0I7UUFDNUI7WUFBQztZQUFpQjtTQUFhLENBQUNnQixPQUFPLENBQUMsQ0FBQ0M7WUFDdkMsd0ZBQXdGO1lBQ3hGLGNBQWM7WUFDZCxJQUNFSCxJQUFJ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QUV0RCxNQUFNekIsV0FBVyxNQUFNNUMsUUFBUTZDLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDeENDLFFBQVE7WUFDUkMsY0FBYztZQUNkckQsS0FBSytFO1lBQ0x2QixTQUFTO2dCQUNQQyxRQUFRO1lBQ1Y7UUFDRjtRQUNBLE1BQU1DLE9BQU90RCxnQkFBZ0I4QztRQUM3QixPQUFPLElBQUk3QixPQUFPO1lBQ2hCLEdBQUdULGVBQWU7WUFDbEIsR0FBRzhDLElBQUk7WUFDUCxDQUFDaEQsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDRCwwQkFBMEJzRCxJQUFJLENBQUMsQ0FBQ2MsZUFDbkRFLGFBQWFaLFVBQVUsQ0FBQ1U7UUFFNUI7SUFDRjtJQUVBLE1BQU1JLGdCQUFnQjtRQUNwQixNQUFNekUsU0FBUzJDLElBQUksQ0FBQyxJQUFJLEVBQUU7SUFDNUI7SUFFQSx3QkFBd0IsR0FDeEIsQ0FBQ3JELFFBQVFvRixNQUFNLENBQUMsR0FBRztRQUNqQixPQUFPLENBQUMsRUFBRSxJQUFJLENBQUMzRCxXQUFXLENBQUM0RCxJQUFJLENBQUMsQ0FBQyxFQUFFckYsUUFBUSxJQUFJLENBQUN3QixRQUFRLEVBQUU7WUFDeEQ4RCxPQUFPQztZQUNQQyxRQUFRQyxRQUFRQyxNQUFNLENBQUNDLEtBQUs7WUFDNUJDLFNBQVM7WUFDVEMsUUFBUTtRQUNWLEdBQUcsQ0FBQztJQUNOO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWF1dGgtcmVnaXN0ZXIvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaXNzdWVyLmpzP2VlZGMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBpbnNwZWN0IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3QgeyBSUEVycm9yIH0gPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgZ2V0Q2xpZW50ID0gcmVxdWlyZSgnLi9jbGllbnQnKTtcbmNvbnN0IHJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9pc3N1ZXJfcmVnaXN0cnknKTtcbmNvbnN0IHByb2Nlc3NSZXNwb25zZSA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9jZXNzX3Jlc3BvbnNlJyk7XG5jb25zdCB3ZWJmaW5nZXJOb3JtYWxpemUgPSByZXF1aXJlKCcuL2hlbHBlcnMvd2ViZmluZ2VyX25vcm1hbGl6ZScpO1xuY29uc3QgcmVxdWVzdCA9IHJlcXVpcmUoJy4vaGVscGVycy9yZXF1ZXN0Jyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4vaGVscGVycy9kZWVwX2Nsb25lJyk7XG5jb25zdCB7IGtleXN0b3JlIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNzdWVyJyk7XG5cbmNvbnN0IEFBRF9NVUxUSVRFTkFOVF9ESVNDT1ZFUlkgPSBbXG4gICdodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS5jb20vY29tbW9uLy53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uJyxcbiAgJ2h0dHBzOi8vbG9naW4ubWljcm9zb2Z0b25saW5lLmNvbS9jb21tb24vdjIuMC8ud2VsbC1rbm93bi9vcGVuaWQtY29uZmlndXJhdGlvbicsXG4gICdodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS5jb20vb3JnYW5pemF0aW9ucy92Mi4wLy53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uJyxcbiAgJ2h0dHBzOi8vbG9naW4ubWljcm9zb2Z0b25saW5lLmNvbS9jb25zdW1lcnMvdjIuMC8ud2VsbC1rbm93bi9vcGVuaWQtY29uZmlndXJhdGlvbicsXG5dO1xuY29uc3QgQUFEX01VTFRJVEVOQU5UID0gU3ltYm9sKCk7XG5jb25zdCBJU1NVRVJfREVGQVVMVFMgPSB7XG4gIGNsYWltX3R5cGVzX3N1cHBvcnRlZDogWydub3JtYWwnXSxcbiAgY2xhaW1zX3BhcmFtZXRlcl9zdXBwb3J0ZWQ6IGZhbHNlLFxuICBncmFudF90eXBlc19zdXBwb3J0ZWQ6IFsnYXV0aG9yaXphdGlvbl9jb2RlJywgJ2ltcGxpY2l0J10sXG4gIHJlcXVlc3RfcGFyYW1ldGVyX3N1cHBvcnRlZDogZmFsc2UsXG4gIHJlcXVlc3RfdXJpX3BhcmFtZXRlcl9zdXBwb3J0ZWQ6IHRydWUsXG4gIHJlcXVpcmVfcmVxdWVzdF91cmlfcmVnaXN0cmF0aW9uOiBmYWxzZSxcbiAgcmVzcG9uc2VfbW9kZXNfc3VwcG9ydGVkOiBbJ3F1ZXJ5JywgJ2ZyYWdtZW50J10sXG4gIHRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kc19zdXBwb3J0ZWQ6IFsnY2xpZW50X3NlY3JldF9iYXNpYyddLFxufTtcblxuY2xhc3MgSXNzdWVyIHtcbiAgI21ldGFkYXRhO1xuICBjb25zdHJ1Y3RvcihtZXRhID0ge30pIHtcbiAgICBjb25zdCBhYWRJc3NWYWxpZGF0aW9uID0gbWV0YVtBQURfTVVMVElURU5BTlRdO1xuICAgIGRlbGV0ZSBtZXRhW0FBRF9NVUxUSVRFTkFOVF07XG4gICAgWydpbnRyb3NwZWN0aW9uJywgJ3Jldm9jYXRpb24nXS5mb3JFYWNoKChlbmRwb2ludCkgPT4ge1xuICAgICAgLy8gaWYgaW50cm8vcmV2b2NhdGlvbiBlbmRwb2ludCBhdXRoIHNwZWNpZmljIG1ldGEgaXMgbWlzc2luZyB1c2UgdGhlIHRva2VuIG9uZXMgaWYgdGhleVxuICAgICAgLy8gYXJlIGRlZmluZWRcbiAgICAgIGlmIChcbiAgICAgICAgbWV0YVtgJHtlbmRwb2ludH1fZW5kcG9pbnRgXSAmJlxuICAgICAgICBtZXRhW2Ake2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX21ldGhvZHNfc3VwcG9ydGVkYF0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBtZXRhW2Ake2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWRgXSA9PT0gdW5kZWZpbmVkXG4gICAgICApIHtcbiAgICAgICAgaWYgKG1ldGEudG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2RzX3N1cHBvcnRlZCkge1xuICAgICAgICAgIG1ldGFbYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfbWV0aG9kc19zdXBwb3J0ZWRgXSA9XG4gICAgICAgICAgICBtZXRhLnRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kc19zdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEudG9rZW5fZW5kcG9pbnRfYXV0aF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkKSB7XG4gICAgICAgICAgbWV0YVtgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkYF0gPVxuICAgICAgICAgICAgbWV0YS50b2tlbl9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuI21ldGFkYXRhID0gbmV3IE1hcCgpO1xuXG4gICAgT2JqZWN0LmVudHJpZXMobWV0YSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICB0aGlzLiNtZXRhZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIXRoaXNba2V5XSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI21ldGFkYXRhLmdldChrZXkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWdpc3RyeS5zZXQodGhpcy5pc3N1ZXIsIHRoaXMpO1xuXG4gICAgY29uc3QgQ2xpZW50ID0gZ2V0Q2xpZW50KHRoaXMsIGFhZElzc1ZhbGlkYXRpb24pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgQ2xpZW50OiB7IHZhbHVlOiBDbGllbnQsIGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgIEZBUEkxQ2xpZW50OiB7IHZhbHVlOiBjbGFzcyBGQVBJMUNsaWVudCBleHRlbmRzIENsaWVudCB7fSwgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IG1ldGFkYXRhKCkge1xuICAgIHJldHVybiBjbG9uZShPYmplY3QuZnJvbUVudHJpZXModGhpcy4jbWV0YWRhdGEuZW50cmllcygpKSk7XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgd2ViZmluZ2VyKGlucHV0KSB7XG4gICAgY29uc3QgcmVzb3VyY2UgPSB3ZWJmaW5nZXJOb3JtYWxpemUoaW5wdXQpO1xuICAgIGNvbnN0IHsgaG9zdCB9ID0gdXJsLnBhcnNlKHJlc291cmNlKTtcbiAgICBjb25zdCB3ZWJmaW5nZXJVcmwgPSBgaHR0cHM6Ly8ke2hvc3R9Ly53ZWxsLWtub3duL3dlYmZpbmdlcmA7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QuY2FsbCh0aGlzLCB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsOiB3ZWJmaW5nZXJVcmwsXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgIHNlYXJjaFBhcmFtczogeyByZXNvdXJjZSwgcmVsOiAnaHR0cDovL29wZW5pZC5uZXQvc3BlY3MvY29ubmVjdC8xLjAvaXNzdWVyJyB9LFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgYm9keSA9IHByb2Nlc3NSZXNwb25zZShyZXNwb25zZSk7XG5cbiAgICBjb25zdCBsb2NhdGlvbiA9XG4gICAgICBBcnJheS5pc0FycmF5KGJvZHkubGlua3MpICYmXG4gICAgICBib2R5LmxpbmtzLmZpbmQoXG4gICAgICAgIChsaW5rKSA9PlxuICAgICAgICAgIHR5cGVvZiBsaW5rID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgIGxpbmsucmVsID09PSAnaHR0cDovL29wZW5pZC5uZXQvc3BlY3MvY29ubmVjdC8xLjAvaXNzdWVyJyAmJlxuICAgICAgICAgIGxpbmsuaHJlZixcbiAgICAgICk7XG5cbiAgICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6ICdubyBpc3N1ZXIgZm91bmQgaW4gd2ViZmluZ2VyIHJlc3BvbnNlJyxcbiAgICAgICAgYm9keSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbG9jYXRpb24uaHJlZiAhPT0gJ3N0cmluZycgfHwgIWxvY2F0aW9uLmhyZWYuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBwcmludGY6IFsnaW52YWxpZCBpc3N1ZXIgbG9jYXRpb24gJXMnLCBsb2NhdGlvbi5ocmVmXSxcbiAgICAgICAgYm9keSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGV4cGVjdGVkSXNzdWVyID0gbG9jYXRpb24uaHJlZjtcbiAgICBpZiAocmVnaXN0cnkuaGFzKGV4cGVjdGVkSXNzdWVyKSkge1xuICAgICAgcmV0dXJuIHJlZ2lzdHJ5LmdldChleHBlY3RlZElzc3Vlcik7XG4gICAgfVxuXG4gICAgY29uc3QgaXNzdWVyID0gYXdhaXQgdGhpcy5kaXNjb3ZlcihleHBlY3RlZElzc3Vlcik7XG5cbiAgICBpZiAoaXNzdWVyLmlzc3VlciAhPT0gZXhwZWN0ZWRJc3N1ZXIpIHtcbiAgICAgIHJlZ2lzdHJ5LmRlbChpc3N1ZXIuaXNzdWVyKTtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKFxuICAgICAgICAnZGlzY292ZXJlZCBpc3N1ZXIgbWlzbWF0Y2gsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJyxcbiAgICAgICAgZXhwZWN0ZWRJc3N1ZXIsXG4gICAgICAgIGlzc3Vlci5pc3N1ZXIsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gaXNzdWVyO1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIGRpc2NvdmVyKHVyaSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHVybC5wYXJzZSh1cmkpO1xuXG4gICAgaWYgKHBhcnNlZC5wYXRobmFtZS5pbmNsdWRlcygnLy53ZWxsLWtub3duLycpKSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QuY2FsbCh0aGlzLCB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICB1cmw6IHVyaSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICBjb25zdCBib2R5ID0gcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIHJldHVybiBuZXcgSXNzdWVyKHtcbiAgICAgICAgLi4uSVNTVUVSX0RFRkFVTFRTLFxuICAgICAgICAuLi5ib2R5LFxuICAgICAgICBbQUFEX01VTFRJVEVOQU5UXTogISFBQURfTVVMVElURU5BTlRfRElTQ09WRVJZLmZpbmQoKGRpc2NvdmVyeVVSTCkgPT5cbiAgICAgICAgICB1cmkuc3RhcnRzV2l0aChkaXNjb3ZlcnlVUkwpLFxuICAgICAgICApLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0IHBhdGhuYW1lO1xuICAgIGlmIChwYXJzZWQucGF0aG5hbWUuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgcGF0aG5hbWUgPSBgJHtwYXJzZWQucGF0aG5hbWV9LndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb25gO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRobmFtZSA9IGAke3BhcnNlZC5wYXRobmFtZX0vLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb25gO1xuICAgIH1cblxuICAgIGNvbnN0IHdlbGxLbm93blVyaSA9IHVybC5mb3JtYXQoeyAuLi5wYXJzZWQsIHBhdGhuYW1lIH0pO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LmNhbGwodGhpcywge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgdXJsOiB3ZWxsS25vd25VcmksXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBib2R5ID0gcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICByZXR1cm4gbmV3IElzc3Vlcih7XG4gICAgICAuLi5JU1NVRVJfREVGQVVMVFMsXG4gICAgICAuLi5ib2R5LFxuICAgICAgW0FBRF9NVUxUSVRFTkFOVF06ICEhQUFEX01VTFRJVEVOQU5UX0RJU0NPVkVSWS5maW5kKChkaXNjb3ZlcnlVUkwpID0+XG4gICAgICAgIHdlbGxLbm93blVyaS5zdGFydHNXaXRoKGRpc2NvdmVyeVVSTCksXG4gICAgICApLFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgcmVsb2FkSndrc1VyaSgpIHtcbiAgICBhd2FpdCBrZXlzdG9yZS5jYWxsKHRoaXMsIHRydWUpO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgW2luc3BlY3QuY3VzdG9tXSgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSAke2luc3BlY3QodGhpcy5tZXRhZGF0YSwge1xuICAgICAgZGVwdGg6IEluZmluaXR5LFxuICAgICAgY29sb3JzOiBwcm9jZXNzLnN0ZG91dC5pc1RUWSxcbiAgICAgIGNvbXBhY3Q6IGZhbHNlLFxuICAgICAgc29ydGVkOiB0cnVlLFxuICAgIH0pfWA7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJc3N1ZXI7XG4iXSwibmFtZXMiOlsiaW5zcGVjdCIsInJlcXVpcmUiLCJ1cmwiLCJSUEVycm9yIiwiZ2V0Q2xpZW50IiwicmVnaXN0cnkiLCJwcm9jZXNzUmVzcG9uc2UiLCJ3ZWJmaW5nZXJOb3JtYWxpemUiLCJyZXF1ZXN0IiwiY2xvbmUiLCJrZXlzdG9yZSIsIkFBRF9NVUxUSVRFTkFOVF9ESVNDT1ZFUlkiLCJBQURfTVVMVElURU5BTlQiLCJTeW1ib2wiLCJJU1NVRVJfREVGQVVMVFMiLCJjbGFpbV90eXBlc19zdXBwb3J0ZWQiLCJjbGFpbXNfcGFyYW1ldGVyX3N1cHBvcnRlZCIsImdyYW50X3R5cGVzX3N1cHBvcnRlZCIsInJlcXVlc3RfcGFyYW1ldGVyX3N1cHBvcnRlZCIsInJlcXVlc3RfdXJpX3BhcmFtZXRlcl9zdXBwb3J0ZWQiLCJyZXF1aXJlX3JlcXVlc3RfdXJpX3JlZ2lzdHJhdGlvbiIsInJlc3BvbnNlX21vZGVzX3N1cHBvcnRlZCIsInRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kc19zdXBwb3J0ZWQiLCJJc3N1ZXIiLCJtZXRhZGF0YSIsImNvbnN0cnVjdG9yIiwibWV0YSIsImFhZElzc1ZhbGlkYXRpb24iLCJmb3JFYWNoIiwiZW5kcG9pbnQiLCJ1bmRlZmluZWQiLCJ0b2tlbl9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQiLCJNYXAiLCJPYmplY3QiLCJlbnRyaWVzIiwia2V5IiwidmFsdWUiLCJzZXQiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImVudW1lcmFibGUiLCJpc3N1ZXIiLCJDbGllbnQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiRkFQSTFDbGllbnQiLCJmcm9tRW50cmllcyIsIndlYmZpbmdlciIsImlucHV0IiwicmVzb3VyY2UiLCJob3N0IiwicGFyc2UiLCJ3ZWJmaW5nZXJVcmwiLCJyZXNwb25zZSIsImNhbGwiLCJtZXRob2QiLCJyZXNwb25zZVR5cGUiLCJzZWFyY2hQYXJhbXMiLCJyZWwiLCJoZWFkZXJzIiwiQWNjZXB0IiwiYm9keSIsImxvY2F0aW9uIiwiQXJyYXkiLCJpc0FycmF5IiwibGlua3MiLCJmaW5kIiwibGluayIsImhyZWYiLCJtZXNzYWdlIiwic3RhcnRzV2l0aCIsInByaW50ZiIsImV4cGVjdGVkSXNzdWVyIiwiaGFzIiwiZGlzY292ZXIiLCJkZWwiLCJ1cmkiLCJwYXJzZWQiLCJwYXRobmFtZSIsImluY2x1ZGVzIiwiZGlzY292ZXJ5VVJMIiwiZW5kc1dpdGgiLCJ3ZWxsS25vd25VcmkiLCJmb3JtYXQiLCJyZWxvYWRKd2tzVXJpIiwiY3VzdG9tIiwibmFtZSIsImRlcHRoIiwiSW5maW5pdHkiLCJjb2xvcnMiLCJwcm9jZXNzIiwic3Rkb3V0IiwiaXNUVFkiLCJjb21wYWN0Iiwic29ydGVkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/issuer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/issuer_registry.js":
/*!***********************************************************!*\
  !*** ./node_modules/openid-client/lib/issuer_registry.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const LRU = __webpack_require__(/*! lru-cache */ \"(rsc)/./node_modules/lru-cache/index.js\");\nmodule.exports = new LRU({\n    max: 100\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaXNzdWVyX3JlZ2lzdHJ5LmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLE1BQU1DLG1CQUFPQSxDQUFDO0FBRXBCQyxPQUFPQyxPQUFPLEdBQUcsSUFBSUgsSUFBSTtJQUFFSSxLQUFLO0FBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWF1dGgtcmVnaXN0ZXIvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaXNzdWVyX3JlZ2lzdHJ5LmpzP2IwNmQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgTFJVID0gcmVxdWlyZSgnbHJ1LWNhY2hlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IExSVSh7IG1heDogMTAwIH0pO1xuIl0sIm5hbWVzIjpbIkxSVSIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwibWF4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/issuer_registry.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/passport_strategy.js":
/*!*************************************************************!*\
  !*** ./node_modules/openid-client/lib/passport_strategy.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const url = __webpack_require__(/*! url */ \"url\");\nconst { format } = __webpack_require__(/*! util */ \"util\");\nconst cloneDeep = __webpack_require__(/*! ./helpers/deep_clone */ \"(rsc)/./node_modules/openid-client/lib/helpers/deep_clone.js\");\nconst { RPError, OPError } = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/openid-client/lib/errors.js\");\nconst { BaseClient } = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/openid-client/lib/client.js\");\nconst { random, codeChallenge } = __webpack_require__(/*! ./helpers/generators */ \"(rsc)/./node_modules/openid-client/lib/helpers/generators.js\");\nconst pick = __webpack_require__(/*! ./helpers/pick */ \"(rsc)/./node_modules/openid-client/lib/helpers/pick.js\");\nconst { resolveResponseType, resolveRedirectUri } = __webpack_require__(/*! ./helpers/client */ \"(rsc)/./node_modules/openid-client/lib/helpers/client.js\");\nfunction verified(err, user, info = {}) {\n    if (err) {\n        this.error(err);\n    } else if (!user) {\n        this.fail(info);\n    } else {\n        this.success(user, info);\n    }\n}\nfunction OpenIDConnectStrategy({ client, params = {}, passReqToCallback = false, sessionKey, usePKCE = true, extras = {} } = {}, verify) {\n    if (!(client instanceof BaseClient)) {\n        throw new TypeError(\"client must be an instance of openid-client Client\");\n    }\n    if (typeof verify !== \"function\") {\n        throw new TypeError(\"verify callback must be a function\");\n    }\n    if (!client.issuer || !client.issuer.issuer) {\n        throw new TypeError(\"client must have an issuer with an identifier\");\n    }\n    this._client = client;\n    this._issuer = client.issuer;\n    this._verify = verify;\n    this._passReqToCallback = passReqToCallback;\n    this._usePKCE = usePKCE;\n    this._key = sessionKey || `oidc:${url.parse(this._issuer.issuer).hostname}`;\n    this._params = cloneDeep(params);\n    // state and nonce are handled in authenticate()\n    delete this._params.state;\n    delete this._params.nonce;\n    this._extras = cloneDeep(extras);\n    if (!this._params.response_type) this._params.response_type = resolveResponseType.call(client);\n    if (!this._params.redirect_uri) this._params.redirect_uri = resolveRedirectUri.call(client);\n    if (!this._params.scope) this._params.scope = \"openid\";\n    if (this._usePKCE === true) {\n        const supportedMethods = Array.isArray(this._issuer.code_challenge_methods_supported) ? this._issuer.code_challenge_methods_supported : false;\n        if (supportedMethods && supportedMethods.includes(\"S256\")) {\n            this._usePKCE = \"S256\";\n        } else if (supportedMethods && supportedMethods.includes(\"plain\")) {\n            this._usePKCE = \"plain\";\n        } else if (supportedMethods) {\n            throw new TypeError(\"neither code_challenge_method supported by the client is supported by the issuer\");\n        } else {\n            this._usePKCE = \"S256\";\n        }\n    } else if (typeof this._usePKCE === \"string\" && ![\n        \"plain\",\n        \"S256\"\n    ].includes(this._usePKCE)) {\n        throw new TypeError(`${this._usePKCE} is not valid/implemented PKCE code_challenge_method`);\n    }\n    this.name = url.parse(client.issuer.issuer).hostname;\n}\nOpenIDConnectStrategy.prototype.authenticate = function authenticate(req, options) {\n    (async ()=>{\n        const client = this._client;\n        if (!req.session) {\n            throw new TypeError(\"authentication requires session support\");\n        }\n        const reqParams = client.callbackParams(req);\n        const sessionKey = this._key;\n        const { 0: parameter, length } = Object.keys(reqParams);\n        /**\n     * Start authentication request if this has no authorization response parameters or\n     * this might a login initiated from a third party as per\n     * https://openid.net/specs/openid-connect-core-1_0.html#ThirdPartyInitiatedLogin.\n     */ if (length === 0 || length === 1 && parameter === \"iss\") {\n            // provide options object with extra authentication parameters\n            const params = {\n                state: random(),\n                ...this._params,\n                ...options\n            };\n            if (!params.nonce && params.response_type.includes(\"id_token\")) {\n                params.nonce = random();\n            }\n            req.session[sessionKey] = pick(params, \"nonce\", \"state\", \"max_age\", \"response_type\");\n            if (this._usePKCE && params.response_type.includes(\"code\")) {\n                const verifier = random();\n                req.session[sessionKey].code_verifier = verifier;\n                switch(this._usePKCE){\n                    case \"S256\":\n                        params.code_challenge = codeChallenge(verifier);\n                        params.code_challenge_method = \"S256\";\n                        break;\n                    case \"plain\":\n                        params.code_challenge = verifier;\n                        break;\n                }\n            }\n            this.redirect(client.authorizationUrl(params));\n            return;\n        }\n        /* end authentication request */ /* start authentication response */ const session = req.session[sessionKey];\n        if (Object.keys(session || {}).length === 0) {\n            throw new Error(format('did not find expected authorization request details in session, req.session[\"%s\"] is %j', sessionKey, session));\n        }\n        const { state, nonce, max_age: maxAge, code_verifier: codeVerifier, response_type: responseType } = session;\n        try {\n            delete req.session[sessionKey];\n        } catch (err) {}\n        const opts = {\n            redirect_uri: this._params.redirect_uri,\n            ...options\n        };\n        const checks = {\n            state,\n            nonce,\n            max_age: maxAge,\n            code_verifier: codeVerifier,\n            response_type: responseType\n        };\n        const tokenset = await client.callback(opts.redirect_uri, reqParams, checks, this._extras);\n        const passReq = this._passReqToCallback;\n        const loadUserinfo = this._verify.length > (passReq ? 3 : 2) && client.issuer.userinfo_endpoint;\n        const args = [\n            tokenset,\n            verified.bind(this)\n        ];\n        if (loadUserinfo) {\n            if (!tokenset.access_token) {\n                throw new RPError({\n                    message: \"expected access_token to be returned when asking for userinfo in verify callback\",\n                    tokenset\n                });\n            }\n            const userinfo = await client.userinfo(tokenset);\n            args.splice(1, 0, userinfo);\n        }\n        if (passReq) {\n            args.unshift(req);\n        }\n        this._verify(...args);\n    /* end authentication response */ })().catch((error)=>{\n        if (error instanceof OPError && error.error !== \"server_error\" && !error.error.startsWith(\"invalid\") || error instanceof RPError) {\n            this.fail(error);\n        } else {\n            this.error(error);\n        }\n    });\n};\nmodule.exports = OpenIDConnectStrategy;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvcGFzc3BvcnRfc3RyYXRlZ3kuanMiLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUEsTUFBTUMsbUJBQU9BLENBQUM7QUFDcEIsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFFM0IsTUFBTUUsWUFBWUYsbUJBQU9BLENBQUM7QUFDMUIsTUFBTSxFQUFFRyxPQUFPLEVBQUVDLE9BQU8sRUFBRSxHQUFHSixtQkFBT0EsQ0FBQztBQUNyQyxNQUFNLEVBQUVLLFVBQVUsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUMvQixNQUFNLEVBQUVNLE1BQU0sRUFBRUMsYUFBYSxFQUFFLEdBQUdQLG1CQUFPQSxDQUFDO0FBQzFDLE1BQU1RLE9BQU9SLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRVMsbUJBQW1CLEVBQUVDLGtCQUFrQixFQUFFLEdBQUdWLG1CQUFPQSxDQUFDO0FBRTVELFNBQVNXLFNBQVNDLEdBQUcsRUFBRUMsSUFBSSxFQUFFQyxPQUFPLENBQUMsQ0FBQztJQUNwQyxJQUFJRixLQUFLO1FBQ1AsSUFBSSxDQUFDRyxLQUFLLENBQUNIO0lBQ2IsT0FBTyxJQUFJLENBQUNDLE1BQU07UUFDaEIsSUFBSSxDQUFDRyxJQUFJLENBQUNGO0lBQ1osT0FBTztRQUNMLElBQUksQ0FBQ0csT0FBTyxDQUFDSixNQUFNQztJQUNyQjtBQUNGO0FBRUEsU0FBU0ksc0JBQ1AsRUFBRUMsTUFBTSxFQUFFQyxTQUFTLENBQUMsQ0FBQyxFQUFFQyxvQkFBb0IsS0FBSyxFQUFFQyxVQUFVLEVBQUVDLFVBQVUsSUFBSSxFQUFFQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQ2hHQyxNQUFNO0lBRU4sSUFBSSxDQUFFTixDQUFBQSxrQkFBa0JkLFVBQVMsR0FBSTtRQUNuQyxNQUFNLElBQUlxQixVQUFVO0lBQ3RCO0lBRUEsSUFBSSxPQUFPRCxXQUFXLFlBQVk7UUFDaEMs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LE1BQU1BLEtBQUssQ0FBQ3dFLFVBQVUsQ0FBQyxjQUMxQnhFLGlCQUFpQlosU0FDakI7WUFDQSxJQUFJLENBQUNhLElBQUksQ0FBQ0Q7UUFDWixPQUFPO1lBQ0wsSUFBSSxDQUFDQSxLQUFLLENBQUNBO1FBQ2I7SUFDRjtBQUNGO0FBRUF5RSxPQUFPQyxPQUFPLEdBQUd2RSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXV0aC1yZWdpc3Rlci8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9wYXNzcG9ydF9zdHJhdGVneS5qcz8yYWY4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuY29uc3QgeyBmb3JtYXQgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY29uc3QgY2xvbmVEZWVwID0gcmVxdWlyZSgnLi9oZWxwZXJzL2RlZXBfY2xvbmUnKTtcbmNvbnN0IHsgUlBFcnJvciwgT1BFcnJvciB9ID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IHsgQmFzZUNsaWVudCB9ID0gcmVxdWlyZSgnLi9jbGllbnQnKTtcbmNvbnN0IHsgcmFuZG9tLCBjb2RlQ2hhbGxlbmdlIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2VuZXJhdG9ycycpO1xuY29uc3QgcGljayA9IHJlcXVpcmUoJy4vaGVscGVycy9waWNrJyk7XG5jb25zdCB7IHJlc29sdmVSZXNwb25zZVR5cGUsIHJlc29sdmVSZWRpcmVjdFVyaSB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2NsaWVudCcpO1xuXG5mdW5jdGlvbiB2ZXJpZmllZChlcnIsIHVzZXIsIGluZm8gPSB7fSkge1xuICBpZiAoZXJyKSB7XG4gICAgdGhpcy5lcnJvcihlcnIpO1xuICB9IGVsc2UgaWYgKCF1c2VyKSB7XG4gICAgdGhpcy5mYWlsKGluZm8pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc3VjY2Vzcyh1c2VyLCBpbmZvKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBPcGVuSURDb25uZWN0U3RyYXRlZ3koXG4gIHsgY2xpZW50LCBwYXJhbXMgPSB7fSwgcGFzc1JlcVRvQ2FsbGJhY2sgPSBmYWxzZSwgc2Vzc2lvbktleSwgdXNlUEtDRSA9IHRydWUsIGV4dHJhcyA9IHt9IH0gPSB7fSxcbiAgdmVyaWZ5LFxuKSB7XG4gIGlmICghKGNsaWVudCBpbnN0YW5jZW9mIEJhc2VDbGllbnQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2xpZW50IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2Ygb3BlbmlkLWNsaWVudCBDbGllbnQnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyaWZ5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmVyaWZ5IGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKCFjbGllbnQuaXNzdWVyIHx8ICFjbGllbnQuaXNzdWVyLmlzc3Vlcikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NsaWVudCBtdXN0IGhhdmUgYW4gaXNzdWVyIHdpdGggYW4gaWRlbnRpZmllcicpO1xuICB9XG5cbiAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICB0aGlzLl9pc3N1ZXIgPSBjbGllbnQuaXNzdWVyO1xuICB0aGlzLl92ZXJpZnkgPSB2ZXJpZnk7XG4gIHRoaXMuX3Bhc3NSZXFUb0NhbGxiYWNrID0gcGFzc1JlcVRvQ2FsbGJhY2s7XG4gIHRoaXMuX3VzZVBLQ0UgPSB1c2VQS0NFO1xuICB0aGlzLl9rZXkgPSBzZXNzaW9uS2V5IHx8IGBvaWRjOiR7dXJsLnBhcnNlKHRoaXMuX2lzc3Vlci5pc3N1ZXIpLmhvc3RuYW1lfWA7XG4gIHRoaXMuX3BhcmFtcyA9IGNsb25lRGVlcChwYXJhbXMpO1xuXG4gIC8vIHN0YXRlIGFuZCBub25jZSBhcmUgaGFuZGxlZCBpbiBhdXRoZW50aWNhdGUoKVxuICBkZWxldGUgdGhpcy5fcGFyYW1zLnN0YXRlO1xuICBkZWxldGUgdGhpcy5fcGFyYW1zLm5vbmNlO1xuXG4gIHRoaXMuX2V4dHJhcyA9IGNsb25lRGVlcChleHRyYXMpO1xuXG4gIGlmICghdGhpcy5fcGFyYW1zLnJlc3BvbnNlX3R5cGUpIHRoaXMuX3BhcmFtcy5yZXNwb25zZV90eXBlID0gcmVzb2x2ZVJlc3BvbnNlVHlwZS5jYWxsKGNsaWVudCk7XG4gIGlmICghdGhpcy5fcGFyYW1zLnJlZGlyZWN0X3VyaSkgdGhpcy5fcGFyYW1zLnJlZGlyZWN0X3VyaSA9IHJlc29sdmVSZWRpcmVjdFVyaS5jYWxsKGNsaWVudCk7XG4gIGlmICghdGhpcy5fcGFyYW1zLnNjb3BlKSB0aGlzLl9wYXJhbXMuc2NvcGUgPSAnb3BlbmlkJztcblxuICBpZiAodGhpcy5fdXNlUEtDRSA9PT0gdHJ1ZSkge1xuICAgIGNvbnN0IHN1cHBvcnRlZE1ldGhvZHMgPSBBcnJheS5pc0FycmF5KHRoaXMuX2lzc3Vlci5jb2RlX2NoYWxsZW5nZV9tZXRob2RzX3N1cHBvcnRlZClcbiAgICAgID8gdGhpcy5faXNzdWVyLmNvZGVfY2hhbGxlbmdlX21ldGhvZHNfc3VwcG9ydGVkXG4gICAgICA6IGZhbHNlO1xuXG4gICAgaWYgKHN1cHBvcnRlZE1ldGhvZHMgJiYgc3VwcG9ydGVkTWV0aG9kcy5pbmNsdWRlcygnUzI1NicpKSB7XG4gICAgICB0aGlzLl91c2VQS0NFID0gJ1MyNTYnO1xuICAgIH0gZWxzZSBpZiAoc3VwcG9ydGVkTWV0aG9kcyAmJiBzdXBwb3J0ZWRNZXRob2RzLmluY2x1ZGVzKCdwbGFpbicpKSB7XG4gICAgICB0aGlzLl91c2VQS0NFID0gJ3BsYWluJztcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnRlZE1ldGhvZHMpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICduZWl0aGVyIGNvZGVfY2hhbGxlbmdlX21ldGhvZCBzdXBwb3J0ZWQgYnkgdGhlIGNsaWVudCBpcyBzdXBwb3J0ZWQgYnkgdGhlIGlzc3VlcicsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91c2VQS0NFID0gJ1MyNTYnO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5fdXNlUEtDRSA9PT0gJ3N0cmluZycgJiYgIVsncGxhaW4nLCAnUzI1NiddLmluY2x1ZGVzKHRoaXMuX3VzZVBLQ0UpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt0aGlzLl91c2VQS0NFfSBpcyBub3QgdmFsaWQvaW1wbGVtZW50ZWQgUEtDRSBjb2RlX2NoYWxsZW5nZV9tZXRob2RgKTtcbiAgfVxuXG4gIHRoaXMubmFtZSA9IHVybC5wYXJzZShjbGllbnQuaXNzdWVyLmlzc3VlcikuaG9zdG5hbWU7XG59XG5cbk9wZW5JRENvbm5lY3RTdHJhdGVneS5wcm90b3R5cGUuYXV0aGVudGljYXRlID0gZnVuY3Rpb24gYXV0aGVudGljYXRlKHJlcSwgb3B0aW9ucykge1xuICAoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuX2NsaWVudDtcbiAgICBpZiAoIXJlcS5zZXNzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdXRoZW50aWNhdGlvbiByZXF1aXJlcyBzZXNzaW9uIHN1cHBvcnQnKTtcbiAgICB9XG4gICAgY29uc3QgcmVxUGFyYW1zID0gY2xpZW50LmNhbGxiYWNrUGFyYW1zKHJlcSk7XG4gICAgY29uc3Qgc2Vzc2lvbktleSA9IHRoaXMuX2tleTtcblxuICAgIGNvbnN0IHsgMDogcGFyYW1ldGVyLCBsZW5ndGggfSA9IE9iamVjdC5rZXlzKHJlcVBhcmFtcyk7XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBhdXRoZW50aWNhdGlvbiByZXF1ZXN0IGlmIHRoaXMgaGFzIG5vIGF1dGhvcml6YXRpb24gcmVzcG9uc2UgcGFyYW1ldGVycyBvclxuICAgICAqIHRoaXMgbWlnaHQgYSBsb2dpbiBpbml0aWF0ZWQgZnJvbSBhIHRoaXJkIHBhcnR5IGFzIHBlclxuICAgICAqIGh0dHBzOi8vb3BlbmlkLm5ldC9zcGVjcy9vcGVuaWQtY29ubmVjdC1jb3JlLTFfMC5odG1sI1RoaXJkUGFydHlJbml0aWF0ZWRMb2dpbi5cbiAgICAgKi9cbiAgICBpZiAobGVuZ3RoID09PSAwIHx8IChsZW5ndGggPT09IDEgJiYgcGFyYW1ldGVyID09PSAnaXNzJykpIHtcbiAgICAgIC8vIHByb3ZpZGUgb3B0aW9ucyBvYmplY3Qgd2l0aCBleHRyYSBhdXRoZW50aWNhdGlvbiBwYXJhbWV0ZXJzXG4gICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIHN0YXRlOiByYW5kb20oKSxcbiAgICAgICAgLi4udGhpcy5fcGFyYW1zLFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgfTtcblxuICAgICAgaWYgKCFwYXJhbXMubm9uY2UgJiYgcGFyYW1zLnJlc3BvbnNlX3R5cGUuaW5jbHVkZXMoJ2lkX3Rva2VuJykpIHtcbiAgICAgICAgcGFyYW1zLm5vbmNlID0gcmFuZG9tKCk7XG4gICAgICB9XG5cbiAgICAgIHJlcS5zZXNzaW9uW3Nlc3Npb25LZXldID0gcGljayhwYXJhbXMsICdub25jZScsICdzdGF0ZScsICdtYXhfYWdlJywgJ3Jlc3BvbnNlX3R5cGUnKTtcblxuICAgICAgaWYgKHRoaXMuX3VzZVBLQ0UgJiYgcGFyYW1zLnJlc3BvbnNlX3R5cGUuaW5jbHVkZXMoJ2NvZGUnKSkge1xuICAgICAgICBjb25zdCB2ZXJpZmllciA9IHJhbmRvbSgpO1xuICAgICAgICByZXEuc2Vzc2lvbltzZXNzaW9uS2V5XS5jb2RlX3ZlcmlmaWVyID0gdmVyaWZpZXI7XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLl91c2VQS0NFKSB7XG4gICAgICAgICAgY2FzZSAnUzI1Nic6XG4gICAgICAgICAgICBwYXJhbXMuY29kZV9jaGFsbGVuZ2UgPSBjb2RlQ2hhbGxlbmdlKHZlcmlmaWVyKTtcbiAgICAgICAgICAgIHBhcmFtcy5jb2RlX2NoYWxsZW5nZV9tZXRob2QgPSAnUzI1Nic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdwbGFpbic6XG4gICAgICAgICAgICBwYXJhbXMuY29kZV9jaGFsbGVuZ2UgPSB2ZXJpZmllcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVkaXJlY3QoY2xpZW50LmF1dGhvcml6YXRpb25VcmwocGFyYW1zKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qIGVuZCBhdXRoZW50aWNhdGlvbiByZXF1ZXN0ICovXG5cbiAgICAvKiBzdGFydCBhdXRoZW50aWNhdGlvbiByZXNwb25zZSAqL1xuXG4gICAgY29uc3Qgc2Vzc2lvbiA9IHJlcS5zZXNzaW9uW3Nlc3Npb25LZXldO1xuICAgIGlmIChPYmplY3Qua2V5cyhzZXNzaW9uIHx8IHt9KS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0KFxuICAgICAgICAgICdkaWQgbm90IGZpbmQgZXhwZWN0ZWQgYXV0aG9yaXphdGlvbiByZXF1ZXN0IGRldGFpbHMgaW4gc2Vzc2lvbiwgcmVxLnNlc3Npb25bXCIlc1wiXSBpcyAlaicsXG4gICAgICAgICAgc2Vzc2lvbktleSxcbiAgICAgICAgICBzZXNzaW9uLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBzdGF0ZSxcbiAgICAgIG5vbmNlLFxuICAgICAgbWF4X2FnZTogbWF4QWdlLFxuICAgICAgY29kZV92ZXJpZmllcjogY29kZVZlcmlmaWVyLFxuICAgICAgcmVzcG9uc2VfdHlwZTogcmVzcG9uc2VUeXBlLFxuICAgIH0gPSBzZXNzaW9uO1xuXG4gICAgdHJ5IHtcbiAgICAgIGRlbGV0ZSByZXEuc2Vzc2lvbltzZXNzaW9uS2V5XTtcbiAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgcmVkaXJlY3RfdXJpOiB0aGlzLl9wYXJhbXMucmVkaXJlY3RfdXJpLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuXG4gICAgY29uc3QgY2hlY2tzID0ge1xuICAgICAgc3RhdGUsXG4gICAgICBub25jZSxcbiAgICAgIG1heF9hZ2U6IG1heEFnZSxcbiAgICAgIGNvZGVfdmVyaWZpZXI6IGNvZGVWZXJpZmllcixcbiAgICAgIHJlc3BvbnNlX3R5cGU6IHJlc3BvbnNlVHlwZSxcbiAgICB9O1xuXG4gICAgY29uc3QgdG9rZW5zZXQgPSBhd2FpdCBjbGllbnQuY2FsbGJhY2sob3B0cy5yZWRpcmVjdF91cmksIHJlcVBhcmFtcywgY2hlY2tzLCB0aGlzLl9leHRyYXMpO1xuXG4gICAgY29uc3QgcGFzc1JlcSA9IHRoaXMuX3Bhc3NSZXFUb0NhbGxiYWNrO1xuICAgIGNvbnN0IGxvYWRVc2VyaW5mbyA9IHRoaXMuX3ZlcmlmeS5sZW5ndGggPiAocGFzc1JlcSA/IDMgOiAyKSAmJiBjbGllbnQuaXNzdWVyLnVzZXJpbmZvX2VuZHBvaW50O1xuXG4gICAgY29uc3QgYXJncyA9IFt0b2tlbnNldCwgdmVyaWZpZWQuYmluZCh0aGlzKV07XG5cbiAgICBpZiAobG9hZFVzZXJpbmZvKSB7XG4gICAgICBpZiAoIXRva2Vuc2V0LmFjY2Vzc190b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICdleHBlY3RlZCBhY2Nlc3NfdG9rZW4gdG8gYmUgcmV0dXJuZWQgd2hlbiBhc2tpbmcgZm9yIHVzZXJpbmZvIGluIHZlcmlmeSBjYWxsYmFjaycsXG4gICAgICAgICAgdG9rZW5zZXQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgdXNlcmluZm8gPSBhd2FpdCBjbGllbnQudXNlcmluZm8odG9rZW5zZXQpO1xuICAgICAgYXJncy5zcGxpY2UoMSwgMCwgdXNlcmluZm8pO1xuICAgIH1cblxuICAgIGlmIChwYXNzUmVxKSB7XG4gICAgICBhcmdzLnVuc2hpZnQocmVxKTtcbiAgICB9XG5cbiAgICB0aGlzLl92ZXJpZnkoLi4uYXJncyk7XG4gICAgLyogZW5kIGF1dGhlbnRpY2F0aW9uIHJlc3BvbnNlICovXG4gIH0pKCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgaWYgKFxuICAgICAgKGVycm9yIGluc3RhbmNlb2YgT1BFcnJvciAmJlxuICAgICAgICBlcnJvci5lcnJvciAhPT0gJ3NlcnZlcl9lcnJvcicgJiZcbiAgICAgICAgIWVycm9yLmVycm9yLnN0YXJ0c1dpdGgoJ2ludmFsaWQnKSkgfHxcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgUlBFcnJvclxuICAgICkge1xuICAgICAgdGhpcy5mYWlsKGVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT3BlbklEQ29ubmVjdFN0cmF0ZWd5O1xuIl0sIm5hbWVzIjpbInVybCIsInJlcXVpcmUiLCJmb3JtYXQiLCJjbG9uZURlZXAiLCJSUEVycm9yIiwiT1BFcnJvciIsIkJhc2VDbGllbnQiLCJyYW5kb20iLCJjb2RlQ2hhbGxlbmdlIiwicGljayIsInJlc29sdmVSZXNwb25zZVR5cGUiLCJyZXNvbHZlUmVkaXJlY3RVcmkiLCJ2ZXJpZmllZCIsImVyciIsInVzZXIiLCJpbmZvIiwiZXJyb3IiLCJmYWlsIiwic3VjY2VzcyIsIk9wZW5JRENvbm5lY3RTdHJhdGVneSIsImNsaWVudCIsInBhcmFtcyIsInBhc3NSZXFUb0NhbGxiYWNrIiwic2Vzc2lvbktleSIsInVzZVBLQ0UiLCJleHRyYXMiLCJ2ZXJpZnkiLCJUeXBlRXJyb3IiLCJpc3N1ZXIiLCJfY2xpZW50IiwiX2lzc3VlciIsIl92ZXJpZnkiLCJfcGFzc1JlcVRvQ2FsbGJhY2siLCJfdXNlUEtDRSIsIl9rZXkiLCJwYXJzZSIsImhvc3RuYW1lIiwiX3BhcmFtcyIsInN0YXRlIiwibm9uY2UiLCJfZXh0cmFzIiwicmVzcG9uc2VfdHlwZSIsImNhbGwiLCJyZWRpcmVjdF91cmkiLCJzY29wZSIsInN1cHBvcnRlZE1ldGhvZHMiLCJBcnJheSIsImlzQXJyYXkiLCJjb2RlX2NoYWxsZW5nZV9tZXRob2RzX3N1cHBvcnRlZCIsImluY2x1ZGVzIiwibmFtZSIsInByb3RvdHlwZSIsImF1dGhlbnRpY2F0ZSIsInJlcSIsIm9wdGlvbnMiLCJzZXNzaW9uIiwicmVxUGFyYW1zIiwiY2FsbGJhY2tQYXJhbXMiLCJwYXJhbWV0ZXIiLCJsZW5ndGgiLCJPYmplY3QiLCJrZXlzIiwidmVyaWZpZXIiLCJjb2RlX3ZlcmlmaWVyIiwiY29kZV9jaGFsbGVuZ2UiLCJjb2RlX2NoYWxsZW5nZV9tZXRob2QiLCJyZWRpcmVjdCIsImF1dGhvcml6YXRpb25VcmwiLCJFcnJvciIsIm1heF9hZ2UiLCJtYXhBZ2UiLCJjb2RlVmVyaWZpZXIiLCJyZXNwb25zZVR5cGUiLCJvcHRzIiwiY2hlY2tzIiwidG9rZW5zZXQiLCJjYWxsYmFjayIsInBhc3NSZXEiLCJsb2FkVXNlcmluZm8iLCJ1c2VyaW5mb19lbmRwb2ludCIsImFyZ3MiLCJiaW5kIiwiYWNjZXNzX3Rva2VuIiwibWVzc2FnZSIsInVzZXJpbmZvIiwic3BsaWNlIiwidW5zaGlmdCIsImNhdGNoIiwic3RhcnRzV2l0aCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/passport_strategy.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/token_set.js":
/*!*****************************************************!*\
  !*** ./node_modules/openid-client/lib/token_set.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const base64url = __webpack_require__(/*! ./helpers/base64url */ \"(rsc)/./node_modules/openid-client/lib/helpers/base64url.js\");\nconst now = __webpack_require__(/*! ./helpers/unix_timestamp */ \"(rsc)/./node_modules/openid-client/lib/helpers/unix_timestamp.js\");\nclass TokenSet {\n    constructor(values){\n        Object.assign(this, values);\n        const { constructor, ...properties } = Object.getOwnPropertyDescriptors(this.constructor.prototype);\n        Object.defineProperties(this, properties);\n    }\n    set expires_in(value) {\n        this.expires_at = now() + Number(value);\n    }\n    get expires_in() {\n        return Math.max.apply(null, [\n            this.expires_at - now(),\n            0\n        ]);\n    }\n    expired() {\n        return this.expires_in === 0;\n    }\n    claims() {\n        if (!this.id_token) {\n            throw new TypeError(\"id_token not present in TokenSet\");\n        }\n        return JSON.parse(base64url.decode(this.id_token.split(\".\")[1]));\n    }\n}\nmodule.exports = TokenSet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvdG9rZW5fc2V0LmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLFlBQVlDLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1DLE1BQU1ELG1CQUFPQSxDQUFDO0FBRXBCLE1BQU1FO0lBQ0pDLFlBQVlDLE1BQU0sQ0FBRTtRQUNsQkMsT0FBT0MsTUFBTSxDQUFDLElBQUksRUFBRUY7UUFDcEIsTUFBTSxFQUFFRCxXQUFXLEVBQUUsR0FBR0ksWUFBWSxHQUFHRixPQUFPRyx5QkFBeUIsQ0FDckUsSUFBSSxDQUFDTCxXQUFXLENBQUNNLFNBQVM7UUFHNUJKLE9BQU9LLGdCQUFnQixDQUFDLElBQUksRUFBRUg7SUFDaEM7SUFFQSxJQUFJSSxXQUFXQyxLQUFLLEVBQUU7UUFDcEIsSUFBSSxDQUFDQyxVQUFVLEdBQUdaLFFBQVFhLE9BQU9GO0lBQ25DO0lBRUEsSUFBSUQsYUFBYTtRQUNmLE9BQU9JLEtBQUtDLEdBQUcsQ0FBQ0MsS0FBSyxDQUFDLE1BQU07WUFBQyxJQUFJLENBQUNKLFVBQVUsR0FBR1o7WUFBTztTQUFFO0lBQzFEO0lBRUFpQixVQUFVO1FBQ1IsT0FBTyxJQUFJLENBQUNQLFVBQVUsS0FBSztJQUM3QjtJQUVBUSxTQUFTO1FBQ1AsSUFBSSxDQUFDLElBQUksQ0FBQ0MsUUFBUSxFQUFFO1lBQ2xCLE1BQU0sSUFBSUMsVUFBVTtRQUN0QjtRQUVBLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ3hCLFVBQVV5QixNQUFNLENBQUMsSUFBSSxDQUFDSixRQUFRLENBQUNLLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtJQUNoRTtBQUNGO0FBRUFDLE9BQU9DLE9BQU8sR0FBR3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hdXRoLXJlZ2lzdGVyLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL3Rva2VuX3NldC5qcz8yODNiIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGJhc2U2NHVybCA9IHJlcXVpcmUoJy4vaGVscGVycy9iYXNlNjR1cmwnKTtcbmNvbnN0IG5vdyA9IHJlcXVpcmUoJy4vaGVscGVycy91bml4X3RpbWVzdGFtcCcpO1xuXG5jbGFzcyBUb2tlblNldCB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlcykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgdmFsdWVzKTtcbiAgICBjb25zdCB7IGNvbnN0cnVjdG9yLCAuLi5wcm9wZXJ0aWVzIH0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhcbiAgICAgIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLFxuICAgICk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgfVxuXG4gIHNldCBleHBpcmVzX2luKHZhbHVlKSB7XG4gICAgdGhpcy5leHBpcmVzX2F0ID0gbm93KCkgKyBOdW1iZXIodmFsdWUpO1xuICB9XG5cbiAgZ2V0IGV4cGlyZXNfaW4oKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIFt0aGlzLmV4cGlyZXNfYXQgLSBub3coKSwgMF0pO1xuICB9XG5cbiAgZXhwaXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5leHBpcmVzX2luID09PSAwO1xuICB9XG5cbiAgY2xhaW1zKCkge1xuICAgIGlmICghdGhpcy5pZF90b2tlbikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaWRfdG9rZW4gbm90IHByZXNlbnQgaW4gVG9rZW5TZXQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gSlNPTi5wYXJzZShiYXNlNjR1cmwuZGVjb2RlKHRoaXMuaWRfdG9rZW4uc3BsaXQoJy4nKVsxXSkpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVG9rZW5TZXQ7XG4iXSwibmFtZXMiOlsiYmFzZTY0dXJsIiwicmVxdWlyZSIsIm5vdyIsIlRva2VuU2V0IiwiY29uc3RydWN0b3IiLCJ2YWx1ZXMiLCJPYmplY3QiLCJhc3NpZ24iLCJwcm9wZXJ0aWVzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsInByb3RvdHlwZSIsImRlZmluZVByb3BlcnRpZXMiLCJleHBpcmVzX2luIiwidmFsdWUiLCJleHBpcmVzX2F0IiwiTnVtYmVyIiwiTWF0aCIsIm1heCIsImFwcGx5IiwiZXhwaXJlZCIsImNsYWltcyIsImlkX3Rva2VuIiwiVHlwZUVycm9yIiwiSlNPTiIsInBhcnNlIiwiZGVjb2RlIiwic3BsaXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/token_set.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/node_modules/object-hash/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/openid-client/node_modules/object-hash/index.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\n/**\n * Exported function\n *\n * Options:\n *\n *  - `algorithm` hash algo to be used by this instance: *'sha1', 'md5'\n *  - `excludeValues` {true|*false} hash object keys, values ignored\n *  - `encoding` hash encoding, supports 'buffer', '*hex', 'binary', 'base64'\n *  - `ignoreUnknown` {true|*false} ignore unknown object types\n *  - `replacer` optional function that replaces values before hashing\n *  - `respectFunctionProperties` {*true|false} consider function properties when hashing\n *  - `respectFunctionNames` {*true|false} consider 'name' property of functions for hashing\n *  - `respectType` {*true|false} Respect special properties (prototype, constructor)\n *    when hashing to distinguish between types\n *  - `unorderedArrays` {true|*false} Sort all arrays before hashing\n *  - `unorderedSets` {*true|false} Sort `Set` and `Map` instances before hashing\n *  * = default\n *\n * @param {object} object value to hash\n * @param {object} options hashing options\n * @return {string} hash value\n * @api public\n */ exports = module.exports = objectHash;\nfunction objectHash(object, options) {\n    options = applyDefaults(object, options);\n    return hash(object, options);\n}\n/**\n * Exported sugar methods\n *\n * @param {object} object value to hash\n * @return {string} hash value\n * @api public\n */ exports.sha1 = function(object) {\n    return objectHash(object);\n};\nexports.keys = function(object) {\n    return objectHash(object, {\n        excludeValues: true,\n        algorithm: \"sha1\",\n        encoding: \"hex\"\n    });\n};\nexports.MD5 = function(object) {\n    return objectHash(object, {\n        algorithm: \"md5\",\n        encoding: \"hex\"\n    });\n};\nexports.keysMD5 = function(object) {\n    return objectHash(object, {\n        algorithm: \"md5\",\n        encoding: \"hex\",\n        excludeValues: true\n    });\n};\n// Internals\nvar hashes = crypto.getHashes ? crypto.getHashes().slice() : [\n    \"sha1\",\n    \"md5\"\n];\nhashes.push(\"passthrough\");\nvar encodings = [\n    \"buffer\",\n    \"hex\",\n    \"binary\",\n    \"base64\"\n];\nfunction applyDefaults(object, sourceOptions) {\n    sourceOptions = sourceOptions || {};\n    // create a copy rather than mutating\n    var options = {};\n    options.algorithm = sourceOptions.algorithm || \"sha1\";\n    options.encoding = sourceOptions.encoding || \"hex\";\n    options.excludeValues = sourceOptions.excludeValues ? true : false;\n    options.algorithm = options.algorithm.toLowerCase();\n    options.encoding = options.encoding.toLowerCase();\n    options.ignoreUnknown = sourceOptions.ignoreUnknown !== true ? false : true; // default to false\n    options.respectType = sourceOptions.respectType === false ? false : true; // default to true\n    options.respectFunctionNames = sourceOptions.respectFunctionNames === false ? false : true;\n    options.respectFunctionProperties = sourceOptions.respectFunctionProperties === false ? false : true;\n    options.unorderedArrays = sourceOptions.unorderedArrays !== true ? false : true; // default to false\n    options.unorderedSets = sourceOptions.unorderedSets === false ? false : true; // default to false\n    options.unorderedObjects = sourceOptions.unorderedObjects === false ? false : true; // default to true\n    options.replacer = sourceOptions.replacer || undefined;\n    options.excludeKeys = sourceOptions.excludeKeys || undefined;\n    if (typeof object === \"undefined\") {\n        throw new Error(\"Object argument required.\");\n    }\n    // if there is a case-insensitive match in the hashes list, accept it\n    // (i.e. SHA256 for sha256)\n    for(var i = 0; i < hashes.length; ++i){\n        if (hashes[i].toLowerCase() === options.algorithm.toLowerCase()) {\n            options.algorithm = hashes[i];\n        }\n    }\n    if (hashes.indexOf(options.algorithm) === -1) {\n        throw new Error('Algorithm \"' + options.algorithm + '\"  not supported. ' + \"supported values: \" + hashes.join(\", \"));\n    }\n    if (encodings.indexOf(options.encoding) === -1 && options.algorithm !== \"passthrough\") {\n        throw new Error('Encoding \"' + options.encoding + '\"  not supported. ' + \"supported values: \" + encodings.join(\", \"));\n    }\n    return options;\n}\n/** Check if the given function is a native function */ function isNativeFunction(f) {\n    if (typeof f !== \"function\") {\n        return false;\n    }\n    var exp = /^function\\s+\\w*\\s*\\(\\s*\\)\\s*{\\s+\\[native code\\]\\s+}$/i;\n    return exp.exec(Function.prototype.toString.call(f)) != null;\n}\nfunction hash(object, options) {\n    var hashingStream;\n    if (options.algorithm !== \"passthrough\") {\n        hashingStream = crypto.createHash(options.algorithm);\n    } else {\n        hashingStream = new PassThrough();\n    }\n    if (typeof hashingStream.write === \"undefined\") {\n        hashingStream.write = hashingStream.update;\n        hashingStream.end = hashingStream.update;\n    }\n    var hasher = typeHasher(options, hashingStream);\n    hasher.dispatch(object);\n    if (!hashingStream.update) {\n        hashingStream.end(\"\");\n    }\n    if (hashingStream.digest) {\n        return hashingStream.digest(options.encoding === \"buffer\" ? undefined : options.encoding);\n    }\n    var buf = hashingStream.read();\n    if (options.encoding === \"buffer\") {\n        return buf;\n    }\n    return buf.toString(options.encoding);\n}\n/**\n * Expose streaming API\n *\n * @param {object} object  Value to serialize\n * @param {object} options  Options, as for hash()\n * @param {object} stream  A stream to write the serializiation to\n * @api public\n */ exports.writeToStream = function(object, options, stream) {\n    if (typeof stream === \"undefined\") {\n        stream = options;\n        options = {};\n    }\n    options = applyDefaults(object, options);\n    return typeHasher(options, stream).dispatch(object);\n};\nfunction typeHasher(options, writeTo, context) {\n    context = context || [];\n    var write = function(str) {\n        if (writeTo.update) {\n            return writeTo.update(str, \"utf8\");\n        } else {\n            return writeTo.write(str, \"utf8\");\n        }\n    };\n    return {\n        dispatch: function(value) {\n            if (options.replacer) {\n                value = options.replacer(value);\n            }\n            var type = typeof value;\n            if (value === null) {\n                type = \"null\";\n            }\n            //console.log(\"[DEBUG] Dispatch: \", value, \"->\", type, \" -> \", \"_\" + type);\n            return this[\"_\" + type](value);\n        },\n        _object: function(object) {\n            var pattern = /\\[object (.*)\\]/i;\n            var objString = Object.prototype.toString.call(object);\n            var objType = pattern.exec(objString);\n            if (!objType) {\n                objType = \"unknown:[\" + objString + \"]\";\n            } else {\n                objType = objType[1]; // take only the class name\n            }\n            objType = objType.toLowerCase();\n            var objectNumber = null;\n            if ((objectNumber = context.indexOf(object)) >= 0) {\n                return this.dispatch(\"[CIRCULAR:\" + objectNumber + \"]\");\n            } else {\n                context.push(object);\n            }\n            if (typeof Buffer !== \"undefined\" && Buffer.isBuffer && Buffer.isBuffer(object)) {\n                write(\"buffer:\");\n                return write(object);\n            }\n            if (objType !== \"object\" && objType !== \"function\" && objType !== \"asyncfunction\") {\n                if (this[\"_\" + objType]) {\n                    this[\"_\" + objType](object);\n                } else if (options.ignoreUnknown) {\n                    return write(\"[\" + objType + \"]\");\n                } else {\n                    throw new Error('Unknown object type \"' + objType + '\"');\n                }\n            } else {\n                var keys = Object.keys(object);\n                if (options.unorderedObjects) {\n                    keys = keys.sort();\n                }\n                // Make sure to incorporate special properties, so\n                // Types with different prototypes will produce\n                // a different hash and objects derived from\n                // different functions (`new Foo`, `new Bar`) will\n                // produce different hashes.\n                // We never do this for native functions since some\n                // seem to break because of that.\n                if (options.respectType !== false && !isNativeFunction(object)) {\n                    keys.splice(0, 0, \"prototype\", \"__proto__\", \"constructor\");\n                }\n                if (options.excludeKeys) {\n                    keys = keys.filter(function(key) {\n                        return !options.excludeKeys(key);\n                    });\n                }\n                write(\"object:\" + keys.length + \":\");\n                var self = this;\n                return keys.forEach(function(key) {\n                    self.dispatch(key);\n                    write(\":\");\n                    if (!options.excludeValues) {\n                        self.dispatch(object[key]);\n                    }\n                    write(\",\");\n                });\n            }\n        },\n        _array: function(arr, unordered) {\n            unordered = typeof unordered !== \"undefined\" ? unordered : options.unorderedArrays !== false; // default to options.unorderedArrays\n            var self = this;\n            write(\"array:\" + arr.length + \":\");\n            if (!unordered || arr.length <= 1) {\n                return arr.forEach(function(entry) {\n                    return self.dispatch(entry);\n                });\n            }\n            // the unordered case is a little more complicated:\n            // since there is no canonical ordering on objects,\n            // i.e. {a:1} < {a:2} and {a:1} > {a:2} are both false,\n            // we first serialize each entry using a PassThrough stream\n            // before sorting.\n            // also: we can’t use the same context array for all entries\n            // since the order of hashing should *not* matter. instead,\n            // we keep track of the additions to a copy of the context array\n            // and add all of them to the global context array when we’re done\n            var contextAdditions = [];\n            var entries = arr.map(function(entry) {\n                var strm = new PassThrough();\n                var localContext = context.slice(); // make copy\n                var hasher = typeHasher(options, strm, localContext);\n                hasher.dispatch(entry);\n                // take only what was added to localContext and append it to contextAdditions\n                contextAdditions = contextAdditions.concat(localContext.slice(context.length));\n                return strm.read().toString();\n            });\n            context = context.concat(contextAdditions);\n            entries.sort();\n            return this._array(entries, false);\n        },\n        _date: function(date) {\n            return write(\"date:\" + date.toJSON());\n        },\n        _symbol: function(sym) {\n            return write(\"symbol:\" + sym.toString());\n        },\n        _error: function(err) {\n            return write(\"error:\" + err.toString());\n        },\n        _boolean: function(bool) {\n            return write(\"bool:\" + bool.toString());\n        },\n        _string: function(string) {\n            write(\"string:\" + string.length + \":\");\n            write(string.toString());\n        },\n        _function: function(fn) {\n            write(\"fn:\");\n            if (isNativeFunction(fn)) {\n                this.dispatch(\"[native]\");\n            } else {\n                this.dispatch(fn.toString());\n            }\n            if (options.respectFunctionNames !== false) {\n                // Make sure we can still distinguish native functions\n                // by their name, otherwise String and Function will\n                // have the same hash\n                this.dispatch(\"function-name:\" + String(fn.name));\n            }\n            if (options.respectFunctionProperties) {\n                this._object(fn);\n            }\n        },\n        _number: function(number) {\n            return write(\"number:\" + number.toString());\n        },\n        _xml: function(xml) {\n            return write(\"xml:\" + xml.toString());\n        },\n        _null: function() {\n            return write(\"Null\");\n        },\n        _undefined: function() {\n            return write(\"Undefined\");\n        },\n        _regexp: function(regex) {\n            return write(\"regex:\" + regex.toString());\n        },\n        _uint8array: function(arr) {\n            write(\"uint8array:\");\n            return this.dispatch(Array.prototype.slice.call(arr));\n        },\n        _uint8clampedarray: function(arr) {\n            write(\"uint8clampedarray:\");\n            return this.dispatch(Array.prototype.slice.call(arr));\n        },\n        _int8array: function(arr) {\n            write(\"uint8array:\");\n            return this.dispatch(Array.prototype.slice.call(arr));\n        },\n        _uint16array: function(arr) {\n            write(\"uint16array:\");\n            return this.dispatch(Array.prototype.slice.call(arr));\n        },\n        _int16array: function(arr) {\n            write(\"uint16array:\");\n            return this.dispatch(Array.prototype.slice.call(arr));\n        },\n        _uint32array: function(arr) {\n            write(\"uint32array:\");\n            return this.dispatch(Array.prototype.slice.call(arr));\n        },\n        _int32array: function(arr) {\n            write(\"uint32array:\");\n            return this.dispatch(Array.prototype.slice.call(arr));\n        },\n        _float32array: function(arr) {\n            write(\"float32array:\");\n            return this.dispatch(Array.prototype.slice.call(arr));\n        },\n        _float64array: function(arr) {\n            write(\"float64array:\");\n            return this.dispatch(Array.prototype.slice.call(arr));\n        },\n        _arraybuffer: function(arr) {\n            write(\"arraybuffer:\");\n            return this.dispatch(new Uint8Array(arr));\n        },\n        _url: function(url) {\n            return write(\"url:\" + url.toString(), \"utf8\");\n        },\n        _map: function(map) {\n            write(\"map:\");\n            var arr = Array.from(map);\n            return this._array(arr, options.unorderedSets !== false);\n        },\n        _set: function(set) {\n            write(\"set:\");\n            var arr = Array.from(set);\n            return this._array(arr, options.unorderedSets !== false);\n        },\n        _file: function(file) {\n            write(\"file:\");\n            return this.dispatch([\n                file.name,\n                file.size,\n                file.type,\n                file.lastModfied\n            ]);\n        },\n        _blob: function() {\n            if (options.ignoreUnknown) {\n                return write(\"[blob]\");\n            }\n            throw Error(\"Hashing Blob objects is currently not supported\\n\" + \"(see https://github.com/puleos/object-hash/issues/26)\\n\" + 'Use \"options.replacer\" or \"options.ignoreUnknown\"\\n');\n        },\n        _domwindow: function() {\n            return write(\"domwindow\");\n        },\n        _bigint: function(number) {\n            return write(\"bigint:\" + number.toString());\n        },\n        /* Node.js standard native objects */ _process: function() {\n            return write(\"process\");\n        },\n        _timer: function() {\n            return write(\"timer\");\n        },\n        _pipe: function() {\n            return write(\"pipe\");\n        },\n        _tcp: function() {\n            return write(\"tcp\");\n        },\n        _udp: function() {\n            return write(\"udp\");\n        },\n        _tty: function() {\n            return write(\"tty\");\n        },\n        _statwatcher: function() {\n            return write(\"statwatcher\");\n        },\n        _securecontext: function() {\n            return write(\"securecontext\");\n        },\n        _connection: function() {\n            return write(\"connection\");\n        },\n        _zlib: function() {\n            return write(\"zlib\");\n        },\n        _context: function() {\n            return write(\"context\");\n        },\n        _nodescript: function() {\n            return write(\"nodescript\");\n        },\n        _httpparser: function() {\n            return write(\"httpparser\");\n        },\n        _dataview: function() {\n            return write(\"dataview\");\n        },\n        _signal: function() {\n            return write(\"signal\");\n        },\n        _fsevent: function() {\n            return write(\"fsevent\");\n        },\n        _tlswrap: function() {\n            return write(\"tlswrap\");\n        }\n    };\n}\n// Mini-implementation of stream.PassThrough\n// We are far from having need for the full implementation, and we can\n// make assumptions like \"many writes, then only one final read\"\n// and we can ignore encoding specifics\nfunction PassThrough() {\n    return {\n        buf: \"\",\n        write: function(b) {\n            this.buf += b;\n        },\n        end: function(b) {\n            this.buf += b;\n        },\n        read: function() {\n            return this.buf;\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9ub2RlX21vZHVsZXMvb2JqZWN0LWhhc2gvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUVyQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNEQyxVQUFVQyxPQUFPRCxPQUFPLEdBQUdFO0FBRTNCLFNBQVNBLFdBQVdDLE1BQU0sRUFBRUMsT0FBTztJQUNqQ0EsVUFBVUMsY0FBY0YsUUFBUUM7SUFFaEMsT0FBT0UsS0FBS0gsUUFBUUM7QUFDdEI7QUFFQTs7Ozs7O0NBTUMsR0FDREosWUFBWSxHQUFHLFNBQVNHLE1BQU07SUFDNUIsT0FBT0QsV0FBV0M7QUFDcEI7QUFDQUgsWUFBWSxHQUFHLFNBQVNHLE1BQU07SUFDNUIsT0FBT0QsV0FBV0MsUUFBUTtRQUFDTSxlQUFlO1FBQU1DLFdBQVc7UUFBUUMsVUFBVTtJQUFLO0FBQ3BGO0FBQ0FYLFdBQVcsR0FBRyxTQUFTRyxNQUFNO0lBQzNCLE9BQU9ELFdBQVdDLFFBQVE7UUFBQ08sV0FBVztRQUFPQyxVQUFVO0lBQUs7QUFDOUQ7QUFDQVgsZUFBZSxHQUFHLFNBQVNHLE1BQU07SUFDL0IsT0FBT0QsV0FBV0MsUUFBUTtRQUFDTyxXQUFXO1FBQU9DLFVBQVU7UUFBT0YsZUFBZTtJQUFJO0FBQ25GO0FBRUEsWUFBWTtBQUNaLElBQUlLLFNBQVNoQixPQUFPaUIsU0FBUyxHQUFHakIsT0FBT2lCLFNBQVMsR0FBR0MsS0FBSyxLQUFLO0lBQUM7SUFBUTtDQUFNO0FBQzVFRixPQUFPRyxJQUFJLENBQUM7QUFDWixJQUFJQyxZQUFZO0lBQUM7SUFBVTtJQUFPO0lBQVU7Q0FBUztBQUVyRCxTQUFTYixjQUFjRixNQUFNLEVBQUVnQixhQUFhO0lBQzFDQSxnQkFBZ0JBLGlCQUFpQixDQUFDO0lBRWxDLHFDQUFxQztJQUNyQyxJQUFJZixVQUFVLENBQUM7SUFDZkEsUUFBUU0sU0FBUyxHQUFHUyxj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QUFNO1FBQVE7UUFDeEM4RixjQUFjO1lBQWEsT0FBTzlGLE1BQU07UUFBZ0I7UUFDeEQrRixnQkFBZ0I7WUFBYSxPQUFPL0YsTUFBTTtRQUFrQjtRQUM1RGdHLGFBQWE7WUFBYSxPQUFPaEcsTUFBTTtRQUFlO1FBQ3REaUcsT0FBTztZQUFhLE9BQU9qRyxNQUFNO1FBQVM7UUFDMUNrRyxVQUFVO1lBQWEsT0FBT2xHLE1BQU07UUFBWTtRQUNoRG1HLGFBQWE7WUFBYSxPQUFPbkcsTUFBTTtRQUFlO1FBQ3REb0csYUFBYTtZQUFhLE9BQU9wRyxNQUFNO1FBQWU7UUFDdERxRyxXQUFXO1lBQWEsT0FBT3JHLE1BQU07UUFBYTtRQUNsRHNHLFNBQVM7WUFBYSxPQUFPdEcsTUFBTTtRQUFXO1FBQzlDdUcsVUFBVTtZQUFhLE9BQU92RyxNQUFNO1FBQVk7UUFDaER3RyxVQUFVO1lBQWEsT0FBT3hHLE1BQU07UUFBWTtJQUNsRDtBQUNGO0FBRUEsNENBQTRDO0FBQzVDLHNFQUFzRTtBQUN0RSxnRUFBZ0U7QUFDaEUsdUNBQXVDO0FBQ3ZDLFNBQVNEO0lBQ1AsT0FBTztRQUNMUSxLQUFLO1FBRUxQLE9BQU8sU0FBU3lHLENBQUM7WUFDZixJQUFJLENBQUNsRyxHQUFHLElBQUlrRztRQUNkO1FBRUF2RyxLQUFLLFNBQVN1RyxDQUFDO1lBQ2IsSUFBSSxDQUFDbEcsR0FBRyxJQUFJa0c7UUFDZDtRQUVBakcsTUFBTTtZQUNKLE9BQU8sSUFBSSxDQUFDRCxHQUFHO1FBQ2pCO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXV0aC1yZWdpc3Rlci8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L25vZGVfbW9kdWxlcy9vYmplY3QtaGFzaC9pbmRleC5qcz9hZDE1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG4vKipcbiAqIEV4cG9ydGVkIGZ1bmN0aW9uXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgYWxnb3JpdGhtYCBoYXNoIGFsZ28gdG8gYmUgdXNlZCBieSB0aGlzIGluc3RhbmNlOiAqJ3NoYTEnLCAnbWQ1J1xuICogIC0gYGV4Y2x1ZGVWYWx1ZXNgIHt0cnVlfCpmYWxzZX0gaGFzaCBvYmplY3Qga2V5cywgdmFsdWVzIGlnbm9yZWRcbiAqICAtIGBlbmNvZGluZ2AgaGFzaCBlbmNvZGluZywgc3VwcG9ydHMgJ2J1ZmZlcicsICcqaGV4JywgJ2JpbmFyeScsICdiYXNlNjQnXG4gKiAgLSBgaWdub3JlVW5rbm93bmAge3RydWV8KmZhbHNlfSBpZ25vcmUgdW5rbm93biBvYmplY3QgdHlwZXNcbiAqICAtIGByZXBsYWNlcmAgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXBsYWNlcyB2YWx1ZXMgYmVmb3JlIGhhc2hpbmdcbiAqICAtIGByZXNwZWN0RnVuY3Rpb25Qcm9wZXJ0aWVzYCB7KnRydWV8ZmFsc2V9IGNvbnNpZGVyIGZ1bmN0aW9uIHByb3BlcnRpZXMgd2hlbiBoYXNoaW5nXG4gKiAgLSBgcmVzcGVjdEZ1bmN0aW9uTmFtZXNgIHsqdHJ1ZXxmYWxzZX0gY29uc2lkZXIgJ25hbWUnIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBmb3IgaGFzaGluZ1xuICogIC0gYHJlc3BlY3RUeXBlYCB7KnRydWV8ZmFsc2V9IFJlc3BlY3Qgc3BlY2lhbCBwcm9wZXJ0aWVzIChwcm90b3R5cGUsIGNvbnN0cnVjdG9yKVxuICogICAgd2hlbiBoYXNoaW5nIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdHlwZXNcbiAqICAtIGB1bm9yZGVyZWRBcnJheXNgIHt0cnVlfCpmYWxzZX0gU29ydCBhbGwgYXJyYXlzIGJlZm9yZSBoYXNoaW5nXG4gKiAgLSBgdW5vcmRlcmVkU2V0c2Ageyp0cnVlfGZhbHNlfSBTb3J0IGBTZXRgIGFuZCBgTWFwYCBpbnN0YW5jZXMgYmVmb3JlIGhhc2hpbmdcbiAqICAqID0gZGVmYXVsdFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgdmFsdWUgdG8gaGFzaFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgaGFzaGluZyBvcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGhhc2ggdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IG9iamVjdEhhc2g7XG5cbmZ1bmN0aW9uIG9iamVjdEhhc2gob2JqZWN0LCBvcHRpb25zKXtcbiAgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdHMob2JqZWN0LCBvcHRpb25zKTtcblxuICByZXR1cm4gaGFzaChvYmplY3QsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEV4cG9ydGVkIHN1Z2FyIG1ldGhvZHNcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IHZhbHVlIHRvIGhhc2hcbiAqIEByZXR1cm4ge3N0cmluZ30gaGFzaCB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5zaGExID0gZnVuY3Rpb24ob2JqZWN0KXtcbiAgcmV0dXJuIG9iamVjdEhhc2gob2JqZWN0KTtcbn07XG5leHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3Qpe1xuICByZXR1cm4gb2JqZWN0SGFzaChvYmplY3QsIHtleGNsdWRlVmFsdWVzOiB0cnVlLCBhbGdvcml0aG06ICdzaGExJywgZW5jb2Rpbmc6ICdoZXgnfSk7XG59O1xuZXhwb3J0cy5NRDUgPSBmdW5jdGlvbihvYmplY3Qpe1xuICByZXR1cm4gb2JqZWN0SGFzaChvYmplY3QsIHthbGdvcml0aG06ICdtZDUnLCBlbmNvZGluZzogJ2hleCd9KTtcbn07XG5leHBvcnRzLmtleXNNRDUgPSBmdW5jdGlvbihvYmplY3Qpe1xuICByZXR1cm4gb2JqZWN0SGFzaChvYmplY3QsIHthbGdvcml0aG06ICdtZDUnLCBlbmNvZGluZzogJ2hleCcsIGV4Y2x1ZGVWYWx1ZXM6IHRydWV9KTtcbn07XG5cbi8vIEludGVybmFsc1xudmFyIGhhc2hlcyA9IGNyeXB0by5nZXRIYXNoZXMgPyBjcnlwdG8uZ2V0SGFzaGVzKCkuc2xpY2UoKSA6IFsnc2hhMScsICdtZDUnXTtcbmhhc2hlcy5wdXNoKCdwYXNzdGhyb3VnaCcpO1xudmFyIGVuY29kaW5ncyA9IFsnYnVmZmVyJywgJ2hleCcsICdiaW5hcnknLCAnYmFzZTY0J107XG5cbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdHMob2JqZWN0LCBzb3VyY2VPcHRpb25zKXtcbiAgc291cmNlT3B0aW9ucyA9IHNvdXJjZU9wdGlvbnMgfHwge307XG5cbiAgLy8gY3JlYXRlIGEgY29weSByYXRoZXIgdGhhbiBtdXRhdGluZ1xuICB2YXIgb3B0aW9ucyA9IHt9O1xuICBvcHRpb25zLmFsZ29yaXRobSA9IHNvdXJjZU9wdGlvbnMuYWxnb3JpdGhtIHx8ICdzaGExJztcbiAgb3B0aW9ucy5lbmNvZGluZyA9IHNvdXJjZU9wdGlvbnMuZW5jb2RpbmcgfHwgJ2hleCc7XG4gIG9wdGlvbnMuZXhjbHVkZVZhbHVlcyA9IHNvdXJjZU9wdGlvbnMuZXhjbHVkZVZhbHVlcyA/IHRydWUgOiBmYWxzZTtcbiAgb3B0aW9ucy5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobS50b0xvd2VyQ2FzZSgpO1xuICBvcHRpb25zLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBvcHRpb25zLmlnbm9yZVVua25vd24gPSBzb3VyY2VPcHRpb25zLmlnbm9yZVVua25vd24gIT09IHRydWUgPyBmYWxzZSA6IHRydWU7IC8vIGRlZmF1bHQgdG8gZmFsc2VcbiAgb3B0aW9ucy5yZXNwZWN0VHlwZSA9IHNvdXJjZU9wdGlvbnMucmVzcGVjdFR5cGUgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlOyAvLyBkZWZhdWx0IHRvIHRydWVcbiAgb3B0aW9ucy5yZXNwZWN0RnVuY3Rpb25OYW1lcyA9IHNvdXJjZU9wdGlvbnMucmVzcGVjdEZ1bmN0aW9uTmFtZXMgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xuICBvcHRpb25zLnJlc3BlY3RGdW5jdGlvblByb3BlcnRpZXMgPSBzb3VyY2VPcHRpb25zLnJlc3BlY3RGdW5jdGlvblByb3BlcnRpZXMgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xuICBvcHRpb25zLnVub3JkZXJlZEFycmF5cyA9IHNvdXJjZU9wdGlvbnMudW5vcmRlcmVkQXJyYXlzICE9PSB0cnVlID8gZmFsc2UgOiB0cnVlOyAvLyBkZWZhdWx0IHRvIGZhbHNlXG4gIG9wdGlvbnMudW5vcmRlcmVkU2V0cyA9IHNvdXJjZU9wdGlvbnMudW5vcmRlcmVkU2V0cyA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7IC8vIGRlZmF1bHQgdG8gZmFsc2VcbiAgb3B0aW9ucy51bm9yZGVyZWRPYmplY3RzID0gc291cmNlT3B0aW9ucy51bm9yZGVyZWRPYmplY3RzID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTsgLy8gZGVmYXVsdCB0byB0cnVlXG4gIG9wdGlvbnMucmVwbGFjZXIgPSBzb3VyY2VPcHRpb25zLnJlcGxhY2VyIHx8IHVuZGVmaW5lZDtcbiAgb3B0aW9ucy5leGNsdWRlS2V5cyA9IHNvdXJjZU9wdGlvbnMuZXhjbHVkZUtleXMgfHwgdW5kZWZpbmVkO1xuXG4gIGlmKHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPYmplY3QgYXJndW1lbnQgcmVxdWlyZWQuJyk7XG4gIH1cblxuICAvLyBpZiB0aGVyZSBpcyBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggaW4gdGhlIGhhc2hlcyBsaXN0LCBhY2NlcHQgaXRcbiAgLy8gKGkuZS4gU0hBMjU2IGZvciBzaGEyNTYpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGFzaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGhhc2hlc1tpXS50b0xvd2VyQ2FzZSgpID09PSBvcHRpb25zLmFsZ29yaXRobS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBvcHRpb25zLmFsZ29yaXRobSA9IGhhc2hlc1tpXTtcbiAgICB9XG4gIH1cblxuICBpZihoYXNoZXMuaW5kZXhPZihvcHRpb25zLmFsZ29yaXRobSkgPT09IC0xKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsZ29yaXRobSBcIicgKyBvcHRpb25zLmFsZ29yaXRobSArICdcIiAgbm90IHN1cHBvcnRlZC4gJyArXG4gICAgICAnc3VwcG9ydGVkIHZhbHVlczogJyArIGhhc2hlcy5qb2luKCcsICcpKTtcbiAgfVxuXG4gIGlmKGVuY29kaW5ncy5pbmRleE9mKG9wdGlvbnMuZW5jb2RpbmcpID09PSAtMSAmJlxuICAgICBvcHRpb25zLmFsZ29yaXRobSAhPT0gJ3Bhc3N0aHJvdWdoJyl7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvZGluZyBcIicgKyBvcHRpb25zLmVuY29kaW5nICsgJ1wiICBub3Qgc3VwcG9ydGVkLiAnICtcbiAgICAgICdzdXBwb3J0ZWQgdmFsdWVzOiAnICsgZW5jb2RpbmdzLmpvaW4oJywgJykpO1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZnVuY3Rpb24gaXMgYSBuYXRpdmUgZnVuY3Rpb24gKi9cbmZ1bmN0aW9uIGlzTmF0aXZlRnVuY3Rpb24oZikge1xuICBpZiAoKHR5cGVvZiBmKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgZXhwID0gL15mdW5jdGlvblxccytcXHcqXFxzKlxcKFxccypcXClcXHMqe1xccytcXFtuYXRpdmUgY29kZVxcXVxccyt9JC9pO1xuICByZXR1cm4gZXhwLmV4ZWMoRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZikpICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGhhc2gob2JqZWN0LCBvcHRpb25zKSB7XG4gIHZhciBoYXNoaW5nU3RyZWFtO1xuXG4gIGlmIChvcHRpb25zLmFsZ29yaXRobSAhPT0gJ3Bhc3N0aHJvdWdoJykge1xuICAgIGhhc2hpbmdTdHJlYW0gPSBjcnlwdG8uY3JlYXRlSGFzaChvcHRpb25zLmFsZ29yaXRobSk7XG4gIH0gZWxzZSB7XG4gICAgaGFzaGluZ1N0cmVhbSA9IG5ldyBQYXNzVGhyb3VnaCgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBoYXNoaW5nU3RyZWFtLndyaXRlID09PSAndW5kZWZpbmVkJykge1xuICAgIGhhc2hpbmdTdHJlYW0ud3JpdGUgPSBoYXNoaW5nU3RyZWFtLnVwZGF0ZTtcbiAgICBoYXNoaW5nU3RyZWFtLmVuZCAgID0gaGFzaGluZ1N0cmVhbS51cGRhdGU7XG4gIH1cblxuICB2YXIgaGFzaGVyID0gdHlwZUhhc2hlcihvcHRpb25zLCBoYXNoaW5nU3RyZWFtKTtcbiAgaGFzaGVyLmRpc3BhdGNoKG9iamVjdCk7XG4gIGlmICghaGFzaGluZ1N0cmVhbS51cGRhdGUpIHtcbiAgICBoYXNoaW5nU3RyZWFtLmVuZCgnJyk7XG4gIH1cblxuICBpZiAoaGFzaGluZ1N0cmVhbS5kaWdlc3QpIHtcbiAgICByZXR1cm4gaGFzaGluZ1N0cmVhbS5kaWdlc3Qob3B0aW9ucy5lbmNvZGluZyA9PT0gJ2J1ZmZlcicgPyB1bmRlZmluZWQgOiBvcHRpb25zLmVuY29kaW5nKTtcbiAgfVxuXG4gIHZhciBidWYgPSBoYXNoaW5nU3RyZWFtLnJlYWQoKTtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcgPT09ICdidWZmZXInKSB7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHJldHVybiBidWYudG9TdHJpbmcob3B0aW9ucy5lbmNvZGluZyk7XG59XG5cbi8qKlxuICogRXhwb3NlIHN0cmVhbWluZyBBUElcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0ICBWYWx1ZSB0byBzZXJpYWxpemVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICBPcHRpb25zLCBhcyBmb3IgaGFzaCgpXG4gKiBAcGFyYW0ge29iamVjdH0gc3RyZWFtICBBIHN0cmVhbSB0byB3cml0ZSB0aGUgc2VyaWFsaXppYXRpb24gdG9cbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMud3JpdGVUb1N0cmVhbSA9IGZ1bmN0aW9uKG9iamVjdCwgb3B0aW9ucywgc3RyZWFtKSB7XG4gIGlmICh0eXBlb2Ygc3RyZWFtID09PSAndW5kZWZpbmVkJykge1xuICAgIHN0cmVhbSA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdHMob2JqZWN0LCBvcHRpb25zKTtcblxuICByZXR1cm4gdHlwZUhhc2hlcihvcHRpb25zLCBzdHJlYW0pLmRpc3BhdGNoKG9iamVjdCk7XG59O1xuXG5mdW5jdGlvbiB0eXBlSGFzaGVyKG9wdGlvbnMsIHdyaXRlVG8sIGNvbnRleHQpe1xuICBjb250ZXh0ID0gY29udGV4dCB8fCBbXTtcbiAgdmFyIHdyaXRlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKHdyaXRlVG8udXBkYXRlKSB7XG4gICAgICByZXR1cm4gd3JpdGVUby51cGRhdGUoc3RyLCAndXRmOCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd3JpdGVUby53cml0ZShzdHIsICd1dGY4Jyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgZGlzcGF0Y2g6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIGlmIChvcHRpb25zLnJlcGxhY2VyKSB7XG4gICAgICAgIHZhbHVlID0gb3B0aW9ucy5yZXBsYWNlcih2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGUgPSAnbnVsbCc7XG4gICAgICB9XG5cbiAgICAgIC8vY29uc29sZS5sb2coXCJbREVCVUddIERpc3BhdGNoOiBcIiwgdmFsdWUsIFwiLT5cIiwgdHlwZSwgXCIgLT4gXCIsIFwiX1wiICsgdHlwZSk7XG5cbiAgICAgIHJldHVybiB0aGlzWydfJyArIHR5cGVdKHZhbHVlKTtcbiAgICB9LFxuICAgIF9vYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHBhdHRlcm4gPSAoL1xcW29iamVjdCAoLiopXFxdL2kpO1xuICAgICAgdmFyIG9ialN0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpO1xuICAgICAgdmFyIG9ialR5cGUgPSBwYXR0ZXJuLmV4ZWMob2JqU3RyaW5nKTtcbiAgICAgIGlmICghb2JqVHlwZSkgeyAvLyBvYmplY3QgdHlwZSBkaWQgbm90IG1hdGNoIFtvYmplY3QgLi4uXVxuICAgICAgICBvYmpUeXBlID0gJ3Vua25vd246WycgKyBvYmpTdHJpbmcgKyAnXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpUeXBlID0gb2JqVHlwZVsxXTsgLy8gdGFrZSBvbmx5IHRoZSBjbGFzcyBuYW1lXG4gICAgICB9XG5cbiAgICAgIG9ialR5cGUgPSBvYmpUeXBlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIHZhciBvYmplY3ROdW1iZXIgPSBudWxsO1xuXG4gICAgICBpZiAoKG9iamVjdE51bWJlciA9IGNvbnRleHQuaW5kZXhPZihvYmplY3QpKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKCdbQ0lSQ1VMQVI6JyArIG9iamVjdE51bWJlciArICddJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LnB1c2gob2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEJ1ZmZlci5pc0J1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIob2JqZWN0KSkge1xuICAgICAgICB3cml0ZSgnYnVmZmVyOicpO1xuICAgICAgICByZXR1cm4gd3JpdGUob2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYob2JqVHlwZSAhPT0gJ29iamVjdCcgJiYgb2JqVHlwZSAhPT0gJ2Z1bmN0aW9uJyAmJiBvYmpUeXBlICE9PSAnYXN5bmNmdW5jdGlvbicpIHtcbiAgICAgICAgaWYodGhpc1snXycgKyBvYmpUeXBlXSkge1xuICAgICAgICAgIHRoaXNbJ18nICsgb2JqVHlwZV0ob2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmlnbm9yZVVua25vd24pIHtcbiAgICAgICAgICByZXR1cm4gd3JpdGUoJ1snICsgb2JqVHlwZSArICddJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG9iamVjdCB0eXBlIFwiJyArIG9ialR5cGUgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICAgICAgaWYgKG9wdGlvbnMudW5vcmRlcmVkT2JqZWN0cykge1xuICAgICAgICAgIGtleXMgPSBrZXlzLnNvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdG8gaW5jb3Jwb3JhdGUgc3BlY2lhbCBwcm9wZXJ0aWVzLCBzb1xuICAgICAgICAvLyBUeXBlcyB3aXRoIGRpZmZlcmVudCBwcm90b3R5cGVzIHdpbGwgcHJvZHVjZVxuICAgICAgICAvLyBhIGRpZmZlcmVudCBoYXNoIGFuZCBvYmplY3RzIGRlcml2ZWQgZnJvbVxuICAgICAgICAvLyBkaWZmZXJlbnQgZnVuY3Rpb25zIChgbmV3IEZvb2AsIGBuZXcgQmFyYCkgd2lsbFxuICAgICAgICAvLyBwcm9kdWNlIGRpZmZlcmVudCBoYXNoZXMuXG4gICAgICAgIC8vIFdlIG5ldmVyIGRvIHRoaXMgZm9yIG5hdGl2ZSBmdW5jdGlvbnMgc2luY2Ugc29tZVxuICAgICAgICAvLyBzZWVtIHRvIGJyZWFrIGJlY2F1c2Ugb2YgdGhhdC5cbiAgICAgICAgaWYgKG9wdGlvbnMucmVzcGVjdFR5cGUgIT09IGZhbHNlICYmICFpc05hdGl2ZUZ1bmN0aW9uKG9iamVjdCkpIHtcbiAgICAgICAgICBrZXlzLnNwbGljZSgwLCAwLCAncHJvdG90eXBlJywgJ19fcHJvdG9fXycsICdjb25zdHJ1Y3RvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZXhjbHVkZUtleXMpIHtcbiAgICAgICAgICBrZXlzID0ga2V5cy5maWx0ZXIoZnVuY3Rpb24oa2V5KSB7IHJldHVybiAhb3B0aW9ucy5leGNsdWRlS2V5cyhrZXkpOyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdyaXRlKCdvYmplY3Q6JyArIGtleXMubGVuZ3RoICsgJzonKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4ga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaChrZXkpO1xuICAgICAgICAgIHdyaXRlKCc6Jyk7XG4gICAgICAgICAgaWYoIW9wdGlvbnMuZXhjbHVkZVZhbHVlcykge1xuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaChvYmplY3Rba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdyaXRlKCcsJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2FycmF5OiBmdW5jdGlvbihhcnIsIHVub3JkZXJlZCl7XG4gICAgICB1bm9yZGVyZWQgPSB0eXBlb2YgdW5vcmRlcmVkICE9PSAndW5kZWZpbmVkJyA/IHVub3JkZXJlZCA6XG4gICAgICAgIG9wdGlvbnMudW5vcmRlcmVkQXJyYXlzICE9PSBmYWxzZTsgLy8gZGVmYXVsdCB0byBvcHRpb25zLnVub3JkZXJlZEFycmF5c1xuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB3cml0ZSgnYXJyYXk6JyArIGFyci5sZW5ndGggKyAnOicpO1xuICAgICAgaWYgKCF1bm9yZGVyZWQgfHwgYXJyLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJldHVybiBhcnIuZm9yRWFjaChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgIHJldHVybiBzZWxmLmRpc3BhdGNoKGVudHJ5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZSB1bm9yZGVyZWQgY2FzZSBpcyBhIGxpdHRsZSBtb3JlIGNvbXBsaWNhdGVkOlxuICAgICAgLy8gc2luY2UgdGhlcmUgaXMgbm8gY2Fub25pY2FsIG9yZGVyaW5nIG9uIG9iamVjdHMsXG4gICAgICAvLyBpLmUuIHthOjF9IDwge2E6Mn0gYW5kIHthOjF9ID4ge2E6Mn0gYXJlIGJvdGggZmFsc2UsXG4gICAgICAvLyB3ZSBmaXJzdCBzZXJpYWxpemUgZWFjaCBlbnRyeSB1c2luZyBhIFBhc3NUaHJvdWdoIHN0cmVhbVxuICAgICAgLy8gYmVmb3JlIHNvcnRpbmcuXG4gICAgICAvLyBhbHNvOiB3ZSBjYW7igJl0IHVzZSB0aGUgc2FtZSBjb250ZXh0IGFycmF5IGZvciBhbGwgZW50cmllc1xuICAgICAgLy8gc2luY2UgdGhlIG9yZGVyIG9mIGhhc2hpbmcgc2hvdWxkICpub3QqIG1hdHRlci4gaW5zdGVhZCxcbiAgICAgIC8vIHdlIGtlZXAgdHJhY2sgb2YgdGhlIGFkZGl0aW9ucyB0byBhIGNvcHkgb2YgdGhlIGNvbnRleHQgYXJyYXlcbiAgICAgIC8vIGFuZCBhZGQgYWxsIG9mIHRoZW0gdG8gdGhlIGdsb2JhbCBjb250ZXh0IGFycmF5IHdoZW4gd2XigJlyZSBkb25lXG4gICAgICB2YXIgY29udGV4dEFkZGl0aW9ucyA9IFtdO1xuICAgICAgdmFyIGVudHJpZXMgPSBhcnIubWFwKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgIHZhciBzdHJtID0gbmV3IFBhc3NUaHJvdWdoKCk7XG4gICAgICAgIHZhciBsb2NhbENvbnRleHQgPSBjb250ZXh0LnNsaWNlKCk7IC8vIG1ha2UgY29weVxuICAgICAgICB2YXIgaGFzaGVyID0gdHlwZUhhc2hlcihvcHRpb25zLCBzdHJtLCBsb2NhbENvbnRleHQpO1xuICAgICAgICBoYXNoZXIuZGlzcGF0Y2goZW50cnkpO1xuICAgICAgICAvLyB0YWtlIG9ubHkgd2hhdCB3YXMgYWRkZWQgdG8gbG9jYWxDb250ZXh0IGFuZCBhcHBlbmQgaXQgdG8gY29udGV4dEFkZGl0aW9uc1xuICAgICAgICBjb250ZXh0QWRkaXRpb25zID0gY29udGV4dEFkZGl0aW9ucy5jb25jYXQobG9jYWxDb250ZXh0LnNsaWNlKGNvbnRleHQubGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiBzdHJtLnJlYWQoKS50b1N0cmluZygpO1xuICAgICAgfSk7XG4gICAgICBjb250ZXh0ID0gY29udGV4dC5jb25jYXQoY29udGV4dEFkZGl0aW9ucyk7XG4gICAgICBlbnRyaWVzLnNvcnQoKTtcbiAgICAgIHJldHVybiB0aGlzLl9hcnJheShlbnRyaWVzLCBmYWxzZSk7XG4gICAgfSxcbiAgICBfZGF0ZTogZnVuY3Rpb24oZGF0ZSl7XG4gICAgICByZXR1cm4gd3JpdGUoJ2RhdGU6JyArIGRhdGUudG9KU09OKCkpO1xuICAgIH0sXG4gICAgX3N5bWJvbDogZnVuY3Rpb24oc3ltKXtcbiAgICAgIHJldHVybiB3cml0ZSgnc3ltYm9sOicgKyBzeW0udG9TdHJpbmcoKSk7XG4gICAgfSxcbiAgICBfZXJyb3I6IGZ1bmN0aW9uKGVycil7XG4gICAgICByZXR1cm4gd3JpdGUoJ2Vycm9yOicgKyBlcnIudG9TdHJpbmcoKSk7XG4gICAgfSxcbiAgICBfYm9vbGVhbjogZnVuY3Rpb24oYm9vbCl7XG4gICAgICByZXR1cm4gd3JpdGUoJ2Jvb2w6JyArIGJvb2wudG9TdHJpbmcoKSk7XG4gICAgfSxcbiAgICBfc3RyaW5nOiBmdW5jdGlvbihzdHJpbmcpe1xuICAgICAgd3JpdGUoJ3N0cmluZzonICsgc3RyaW5nLmxlbmd0aCArICc6Jyk7XG4gICAgICB3cml0ZShzdHJpbmcudG9TdHJpbmcoKSk7XG4gICAgfSxcbiAgICBfZnVuY3Rpb246IGZ1bmN0aW9uKGZuKXtcbiAgICAgIHdyaXRlKCdmbjonKTtcbiAgICAgIGlmIChpc05hdGl2ZUZ1bmN0aW9uKGZuKSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKCdbbmF0aXZlXScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaChmbi50b1N0cmluZygpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucmVzcGVjdEZ1bmN0aW9uTmFtZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBjYW4gc3RpbGwgZGlzdGluZ3Vpc2ggbmF0aXZlIGZ1bmN0aW9uc1xuICAgICAgICAvLyBieSB0aGVpciBuYW1lLCBvdGhlcndpc2UgU3RyaW5nIGFuZCBGdW5jdGlvbiB3aWxsXG4gICAgICAgIC8vIGhhdmUgdGhlIHNhbWUgaGFzaFxuICAgICAgICB0aGlzLmRpc3BhdGNoKFwiZnVuY3Rpb24tbmFtZTpcIiArIFN0cmluZyhmbi5uYW1lKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnJlc3BlY3RGdW5jdGlvblByb3BlcnRpZXMpIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0KGZuKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9udW1iZXI6IGZ1bmN0aW9uKG51bWJlcil7XG4gICAgICByZXR1cm4gd3JpdGUoJ251bWJlcjonICsgbnVtYmVyLnRvU3RyaW5nKCkpO1xuICAgIH0sXG4gICAgX3htbDogZnVuY3Rpb24oeG1sKXtcbiAgICAgIHJldHVybiB3cml0ZSgneG1sOicgKyB4bWwudG9TdHJpbmcoKSk7XG4gICAgfSxcbiAgICBfbnVsbDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gd3JpdGUoJ051bGwnKTtcbiAgICB9LFxuICAgIF91bmRlZmluZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHdyaXRlKCdVbmRlZmluZWQnKTtcbiAgICB9LFxuICAgIF9yZWdleHA6IGZ1bmN0aW9uKHJlZ2V4KXtcbiAgICAgIHJldHVybiB3cml0ZSgncmVnZXg6JyArIHJlZ2V4LnRvU3RyaW5nKCkpO1xuICAgIH0sXG4gICAgX3VpbnQ4YXJyYXk6IGZ1bmN0aW9uKGFycil7XG4gICAgICB3cml0ZSgndWludDhhcnJheTonKTtcbiAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycikpO1xuICAgIH0sXG4gICAgX3VpbnQ4Y2xhbXBlZGFycmF5OiBmdW5jdGlvbihhcnIpe1xuICAgICAgd3JpdGUoJ3VpbnQ4Y2xhbXBlZGFycmF5OicpO1xuICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKSk7XG4gICAgfSxcbiAgICBfaW50OGFycmF5OiBmdW5jdGlvbihhcnIpe1xuICAgICAgd3JpdGUoJ3VpbnQ4YXJyYXk6Jyk7XG4gICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIpKTtcbiAgICB9LFxuICAgIF91aW50MTZhcnJheTogZnVuY3Rpb24oYXJyKXtcbiAgICAgIHdyaXRlKCd1aW50MTZhcnJheTonKTtcbiAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycikpO1xuICAgIH0sXG4gICAgX2ludDE2YXJyYXk6IGZ1bmN0aW9uKGFycil7XG4gICAgICB3cml0ZSgndWludDE2YXJyYXk6Jyk7XG4gICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIpKTtcbiAgICB9LFxuICAgIF91aW50MzJhcnJheTogZnVuY3Rpb24oYXJyKXtcbiAgICAgIHdyaXRlKCd1aW50MzJhcnJheTonKTtcbiAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycikpO1xuICAgIH0sXG4gICAgX2ludDMyYXJyYXk6IGZ1bmN0aW9uKGFycil7XG4gICAgICB3cml0ZSgndWludDMyYXJyYXk6Jyk7XG4gICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIpKTtcbiAgICB9LFxuICAgIF9mbG9hdDMyYXJyYXk6IGZ1bmN0aW9uKGFycil7XG4gICAgICB3cml0ZSgnZmxvYXQzMmFycmF5OicpO1xuICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKSk7XG4gICAgfSxcbiAgICBfZmxvYXQ2NGFycmF5OiBmdW5jdGlvbihhcnIpe1xuICAgICAgd3JpdGUoJ2Zsb2F0NjRhcnJheTonKTtcbiAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycikpO1xuICAgIH0sXG4gICAgX2FycmF5YnVmZmVyOiBmdW5jdGlvbihhcnIpe1xuICAgICAgd3JpdGUoJ2FycmF5YnVmZmVyOicpO1xuICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2gobmV3IFVpbnQ4QXJyYXkoYXJyKSk7XG4gICAgfSxcbiAgICBfdXJsOiBmdW5jdGlvbih1cmwpIHtcbiAgICAgIHJldHVybiB3cml0ZSgndXJsOicgKyB1cmwudG9TdHJpbmcoKSwgJ3V0ZjgnKTtcbiAgICB9LFxuICAgIF9tYXA6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgd3JpdGUoJ21hcDonKTtcbiAgICAgIHZhciBhcnIgPSBBcnJheS5mcm9tKG1hcCk7XG4gICAgICByZXR1cm4gdGhpcy5fYXJyYXkoYXJyLCBvcHRpb25zLnVub3JkZXJlZFNldHMgIT09IGZhbHNlKTtcbiAgICB9LFxuICAgIF9zZXQ6IGZ1bmN0aW9uKHNldCkge1xuICAgICAgd3JpdGUoJ3NldDonKTtcbiAgICAgIHZhciBhcnIgPSBBcnJheS5mcm9tKHNldCk7XG4gICAgICByZXR1cm4gdGhpcy5fYXJyYXkoYXJyLCBvcHRpb25zLnVub3JkZXJlZFNldHMgIT09IGZhbHNlKTtcbiAgICB9LFxuICAgIF9maWxlOiBmdW5jdGlvbihmaWxlKSB7XG4gICAgICB3cml0ZSgnZmlsZTonKTtcbiAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFtmaWxlLm5hbWUsIGZpbGUuc2l6ZSwgZmlsZS50eXBlLCBmaWxlLmxhc3RNb2RmaWVkXSk7XG4gICAgfSxcbiAgICBfYmxvYjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAob3B0aW9ucy5pZ25vcmVVbmtub3duKSB7XG4gICAgICAgIHJldHVybiB3cml0ZSgnW2Jsb2JdJyk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IEVycm9yKCdIYXNoaW5nIEJsb2Igb2JqZWN0cyBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFxcbicgK1xuICAgICAgICAnKHNlZSBodHRwczovL2dpdGh1Yi5jb20vcHVsZW9zL29iamVjdC1oYXNoL2lzc3Vlcy8yNilcXG4nICtcbiAgICAgICAgJ1VzZSBcIm9wdGlvbnMucmVwbGFjZXJcIiBvciBcIm9wdGlvbnMuaWdub3JlVW5rbm93blwiXFxuJyk7XG4gICAgfSxcbiAgICBfZG9td2luZG93OiBmdW5jdGlvbigpIHsgcmV0dXJuIHdyaXRlKCdkb213aW5kb3cnKTsgfSxcbiAgICBfYmlnaW50OiBmdW5jdGlvbihudW1iZXIpe1xuICAgICAgcmV0dXJuIHdyaXRlKCdiaWdpbnQ6JyArIG51bWJlci50b1N0cmluZygpKTtcbiAgICB9LFxuICAgIC8qIE5vZGUuanMgc3RhbmRhcmQgbmF0aXZlIG9iamVjdHMgKi9cbiAgICBfcHJvY2VzczogZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZSgncHJvY2VzcycpOyB9LFxuICAgIF90aW1lcjogZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZSgndGltZXInKTsgfSxcbiAgICBfcGlwZTogZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZSgncGlwZScpOyB9LFxuICAgIF90Y3A6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGUoJ3RjcCcpOyB9LFxuICAgIF91ZHA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGUoJ3VkcCcpOyB9LFxuICAgIF90dHk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGUoJ3R0eScpOyB9LFxuICAgIF9zdGF0d2F0Y2hlcjogZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZSgnc3RhdHdhdGNoZXInKTsgfSxcbiAgICBfc2VjdXJlY29udGV4dDogZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZSgnc2VjdXJlY29udGV4dCcpOyB9LFxuICAgIF9jb25uZWN0aW9uOiBmdW5jdGlvbigpIHsgcmV0dXJuIHdyaXRlKCdjb25uZWN0aW9uJyk7IH0sXG4gICAgX3psaWI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGUoJ3psaWInKTsgfSxcbiAgICBfY29udGV4dDogZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZSgnY29udGV4dCcpOyB9LFxuICAgIF9ub2Rlc2NyaXB0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHdyaXRlKCdub2Rlc2NyaXB0Jyk7IH0sXG4gICAgX2h0dHBwYXJzZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGUoJ2h0dHBwYXJzZXInKTsgfSxcbiAgICBfZGF0YXZpZXc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGUoJ2RhdGF2aWV3Jyk7IH0sXG4gICAgX3NpZ25hbDogZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZSgnc2lnbmFsJyk7IH0sXG4gICAgX2ZzZXZlbnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGUoJ2ZzZXZlbnQnKTsgfSxcbiAgICBfdGxzd3JhcDogZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZSgndGxzd3JhcCcpOyB9LFxuICB9O1xufVxuXG4vLyBNaW5pLWltcGxlbWVudGF0aW9uIG9mIHN0cmVhbS5QYXNzVGhyb3VnaFxuLy8gV2UgYXJlIGZhciBmcm9tIGhhdmluZyBuZWVkIGZvciB0aGUgZnVsbCBpbXBsZW1lbnRhdGlvbiwgYW5kIHdlIGNhblxuLy8gbWFrZSBhc3N1bXB0aW9ucyBsaWtlIFwibWFueSB3cml0ZXMsIHRoZW4gb25seSBvbmUgZmluYWwgcmVhZFwiXG4vLyBhbmQgd2UgY2FuIGlnbm9yZSBlbmNvZGluZyBzcGVjaWZpY3NcbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKCkge1xuICByZXR1cm4ge1xuICAgIGJ1ZjogJycsXG5cbiAgICB3cml0ZTogZnVuY3Rpb24oYikge1xuICAgICAgdGhpcy5idWYgKz0gYjtcbiAgICB9LFxuXG4gICAgZW5kOiBmdW5jdGlvbihiKSB7XG4gICAgICB0aGlzLmJ1ZiArPSBiO1xuICAgIH0sXG5cbiAgICByZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ1ZjtcbiAgICB9XG4gIH07XG59XG4iXSwibmFtZXMiOlsiY3J5cHRvIiwicmVxdWlyZSIsImV4cG9ydHMiLCJtb2R1bGUiLCJvYmplY3RIYXNoIiwib2JqZWN0Iiwib3B0aW9ucyIsImFwcGx5RGVmYXVsdHMiLCJoYXNoIiwic2hhMSIsImtleXMiLCJleGNsdWRlVmFsdWVzIiwiYWxnb3JpdGhtIiwiZW5jb2RpbmciLCJNRDUiLCJrZXlzTUQ1IiwiaGFzaGVzIiwiZ2V0SGFzaGVzIiwic2xpY2UiLCJwdXNoIiwiZW5jb2RpbmdzIiwic291cmNlT3B0aW9ucyIsInRvTG93ZXJDYXNlIiwiaWdub3JlVW5rbm93biIsInJlc3BlY3RUeXBlIiwicmVzcGVjdEZ1bmN0aW9uTmFtZXMiLCJyZXNwZWN0RnVuY3Rpb25Qcm9wZXJ0aWVzIiwidW5vcmRlcmVkQXJyYXlzIiwidW5vcmRlcmVkU2V0cyIsInVub3JkZXJlZE9iamVjdHMiLCJyZXBsYWNlciIsInVuZGVmaW5lZCIsImV4Y2x1ZGVLZXlzIiwiRXJyb3IiLCJpIiwibGVuZ3RoIiwiaW5kZXhPZiIsImpvaW4iLCJpc05hdGl2ZUZ1bmN0aW9uIiwiZiIsImV4cCIsImV4ZWMiLCJGdW5jdGlvbiIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImhhc2hpbmdTdHJlYW0iLCJjcmVhdGVIYXNoIiwiUGFzc1Rocm91Z2giLCJ3cml0ZSIsInVwZGF0ZSIsImVuZCIsImhhc2hlciIsInR5cGVIYXNoZXIiLCJkaXNwYXRjaCIsImRpZ2VzdCIsImJ1ZiIsInJlYWQiLCJ3cml0ZVRvU3RyZWFtIiwic3RyZWFtIiwid3JpdGVUbyIsImNvbnRleHQiLCJzdHIiLCJ2YWx1ZSIsInR5cGUiLCJfb2JqZWN0IiwicGF0dGVybiIsIm9ialN0cmluZyIsIk9iamVjdCIsIm9ialR5cGUiLCJvYmplY3ROdW1iZXIiLCJCdWZmZXIiLCJpc0J1ZmZlciIsInNvcnQiLCJzcGxpY2UiLCJmaWx0ZXIiLCJrZXkiLCJzZWxmIiwiZm9yRWFjaCIsIl9hcnJheSIsImFyciIsInVub3JkZXJlZCIsImVudHJ5IiwiY29udGV4dEFkZGl0aW9ucyIsImVudHJpZXMiLCJtYXAiLCJzdHJtIiwibG9jYWxDb250ZXh0IiwiY29uY2F0IiwiX2RhdGUiLCJkYXRlIiwidG9KU09OIiwiX3N5bWJvbCIsInN5bSIsIl9lcnJvciIsImVyciIsIl9ib29sZWFuIiwiYm9vbCIsIl9zdHJpbmciLCJzdHJpbmciLCJfZnVuY3Rpb24iLCJmbiIsIlN0cmluZyIsIm5hbWUiLCJfbnVtYmVyIiwibnVtYmVyIiwiX3htbCIsInhtbCIsIl9udWxsIiwiX3VuZGVmaW5lZCIsIl9yZWdleHAiLCJyZWdleCIsIl91aW50OGFycmF5IiwiQXJyYXkiLCJfdWludDhjbGFtcGVkYXJyYXkiLCJfaW50OGFycmF5IiwiX3VpbnQxNmFycmF5IiwiX2ludDE2YXJyYXkiLCJfdWludDMyYXJyYXkiLCJfaW50MzJhcnJheSIsIl9mbG9hdDMyYXJyYXkiLCJfZmxvYXQ2NGFycmF5IiwiX2FycmF5YnVmZmVyIiwiVWludDhBcnJheSIsIl91cmwiLCJ1cmwiLCJfbWFwIiwiZnJvbSIsIl9zZXQiLCJzZXQiLCJfZmlsZSIsImZpbGUiLCJzaXplIiwibGFzdE1vZGZpZWQiLCJfYmxvYiIsIl9kb213aW5kb3ciLCJfYmlnaW50IiwiX3Byb2Nlc3MiLCJfdGltZXIiLCJfcGlwZSIsIl90Y3AiLCJfdWRwIiwiX3R0eSIsIl9zdGF0d2F0Y2hlciIsIl9zZWN1cmVjb250ZXh0IiwiX2Nvbm5lY3Rpb24iLCJfemxpYiIsIl9jb250ZXh0IiwiX25vZGVzY3JpcHQiLCJfaHR0cHBhcnNlciIsIl9kYXRhdmlldyIsIl9zaWduYWwiLCJfZnNldmVudCIsIl90bHN3cmFwIiwiYiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/node_modules/object-hash/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/package.json":
/*!*************************************************!*\
  !*** ./node_modules/openid-client/package.json ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"openid-client","version":"5.5.0","description":"OpenID Connect Relying Party (RP, Client) implementation for Node.js runtime, supports passportjs","keywords":["auth","authentication","basic","certified","client","connect","dynamic","electron","hybrid","identity","implicit","oauth","oauth2","oidc","openid","passport","relying party","strategy"],"homepage":"https://github.com/panva/node-openid-client","repository":"panva/node-openid-client","funding":{"url":"https://github.com/sponsors/panva"},"license":"MIT","author":"Filip Skokan <panva.ip@gmail.com>","exports":{"types":"./types/index.d.ts","import":"./lib/index.mjs","require":"./lib/index.js"},"main":"./lib/index.js","types":"./types/index.d.ts","files":["lib","types/index.d.ts"],"scripts":{"format":"npx prettier --loglevel silent --write ./lib ./test ./certification ./types","test":"mocha test/**/*.test.js"},"dependencies":{"jose":"^4.14.4","lru-cache":"^6.0.0","object-hash":"^2.2.0","oidc-token-hash":"^5.0.3"},"devDependencies":{"@types/node":"^16.18.31","@types/passport":"^1.0.12","base64url":"^3.0.1","chai":"^4.3.7","jose2":"npm:jose@^2.0.6","mocha":"^10.2.0","nock":"^13.3.1","prettier":"^2.8.8","readable-mock-req":"^0.2.2","sinon":"^9.2.4","timekeeper":"^2.2.0"},"standard-version":{"scripts":{"postchangelog":"sed -i \'\' -e \'s/### \\\\[/## [/g\' CHANGELOG.md"},"types":[{"type":"feat","section":"Features"},{"type":"fix","section":"Fixes"},{"type":"chore","hidden":true},{"type":"docs","hidden":true},{"type":"style","hidden":true},{"type":"refactor","section":"Refactor","hidden":false},{"type":"perf","section":"Performance","hidden":false},{"type":"test","hidden":true}]}}');

/***/ })

};
;