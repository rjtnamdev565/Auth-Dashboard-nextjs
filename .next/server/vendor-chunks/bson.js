"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bson";
exports.ids = ["vendor-chunks/bson"];
exports.modules = {

/***/ "(ssr)/./node_modules/bson/lib/bson.cjs":
/*!****************************************!*\
  !*** ./node_modules/bson/lib/bson.cjs ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction isAnyArrayBuffer(value) {\n    return [\n        \"[object ArrayBuffer]\",\n        \"[object SharedArrayBuffer]\"\n    ].includes(Object.prototype.toString.call(value));\n}\nfunction isUint8Array(value) {\n    return Object.prototype.toString.call(value) === \"[object Uint8Array]\";\n}\nfunction isRegExp(d) {\n    return Object.prototype.toString.call(d) === \"[object RegExp]\";\n}\nfunction isMap(d) {\n    return Object.prototype.toString.call(d) === \"[object Map]\";\n}\nfunction isDate(d) {\n    return Object.prototype.toString.call(d) === \"[object Date]\";\n}\nconst BSON_MAJOR_VERSION = 5;\nconst BSON_INT32_MAX = 0x7fffffff;\nconst BSON_INT32_MIN = -0x80000000;\nconst BSON_INT64_MAX = Math.pow(2, 63) - 1;\nconst BSON_INT64_MIN = -Math.pow(2, 63);\nconst JS_INT_MAX = Math.pow(2, 53);\nconst JS_INT_MIN = -Math.pow(2, 53);\nconst BSON_DATA_NUMBER = 1;\nconst BSON_DATA_STRING = 2;\nconst BSON_DATA_OBJECT = 3;\nconst BSON_DATA_ARRAY = 4;\nconst BSON_DATA_BINARY = 5;\nconst BSON_DATA_UNDEFINED = 6;\nconst BSON_DATA_OID = 7;\nconst BSON_DATA_BOOLEAN = 8;\nconst BSON_DATA_DATE = 9;\nconst BSON_DATA_NULL = 10;\nconst BSON_DATA_REGEXP = 11;\nconst BSON_DATA_DBPOINTER = 12;\nconst BSON_DATA_CODE = 13;\nconst BSON_DATA_SYMBOL = 14;\nconst BSON_DATA_CODE_W_SCOPE = 15;\nconst BSON_DATA_INT = 16;\nconst BSON_DATA_TIMESTAMP = 17;\nconst BSON_DATA_LONG = 18;\nconst BSON_DATA_DECIMAL128 = 19;\nconst BSON_DATA_MIN_KEY = 0xff;\nconst BSON_DATA_MAX_KEY = 0x7f;\nconst BSON_BINARY_SUBTYPE_DEFAULT = 0;\nconst BSON_BINARY_SUBTYPE_UUID_NEW = 4;\nconst BSONType = Object.freeze({\n    double: 1,\n    string: 2,\n    object: 3,\n    array: 4,\n    binData: 5,\n    undefined: 6,\n    objectId: 7,\n    bool: 8,\n    date: 9,\n    null: 10,\n    regex: 11,\n    dbPointer: 12,\n    javascript: 13,\n    symbol: 14,\n    javascriptWithScope: 15,\n    int: 16,\n    timestamp: 17,\n    long: 18,\n    decimal: 19,\n    minKey: -1,\n    maxKey: 127\n});\nclass BSONError extends Error {\n    get bsonError() {\n        return true;\n    }\n    get name() {\n        return \"BSONError\";\n    }\n    constructor(message){\n        super(message);\n    }\n    static isBSONError(value) {\n        return value != null && typeof value === \"object\" && \"bsonError\" in value && value.bsonError === true && \"name\" in value && \"message\" in value && \"stack\" in value;\n    }\n}\nclass BSONVersionError extends BSONError {\n    get name() {\n        return \"BSONVersionError\";\n    }\n    constructor(){\n        super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.0 or later`);\n    }\n}\nclass BSONRuntimeError extends BSONError {\n    get name() {\n        return \"BSONRuntimeError\";\n    }\n    constructor(message){\n        super(message);\n    }\n}\nfunction nodejsMathRandomBytes(byteLength) {\n    return nodeJsByteUtils.fromNumberArray(Array.from({\n        length: byteLength\n    }, ()=>Math.floor(Math.random() * 256)));\n}\nconst nodejsRandomBytes = (()=>{\n    try {\n        return (__webpack_require__(/*! crypto */ \"crypto\").randomBytes);\n    } catch  {\n        return nodejsMathRandomBytes;\n    }\n})();\nconst nodeJsByteUtils = {\n    toLocalBufferType (potentialBuffer) {\n        if (Buffer.isBuffer(potentialBuffer)) {\n            return potentialBuffer;\n        }\n        if (ArrayBuffer.isView(potentialBuffer)) {\n            return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);\n        }\n        const stringTag = potentialBuffer?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialBuffer);\n        if (stringTag === \"ArrayBuffer\" || stringTag === \"SharedArrayBuffer\" || stringTag === \"[object ArrayBuffer]\" || stringTag === \"[object SharedArrayBuffer]\") {\n            return Buffer.from(potentialBuffer);\n        }\n        throw new BSONError(`Cannot create Buffer from ${String(potentialBuffer)}`);\n    },\n    allocate (size) {\n        return Buffer.alloc(size);\n    },\n    equals (a, b) {\n        return nodeJsByteUtils.toLocalBufferType(a).equals(b);\n    },\n    fromNumberArray (array) {\n        return Buffer.from(array);\n    },\n    fromBase64 (base64) {\n        return Buffer.from(base64, \"base64\");\n    },\n    toBase64 (buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString(\"base64\");\n    },\n    fromISO88591 (codePoints) {\n        return Buffer.from(codePoints, \"binary\");\n    },\n    toISO88591 (buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString(\"binary\");\n    },\n    fromHex (hex) {\n        return Buffer.from(hex, \"hex\");\n    },\n    toHex (buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString(\"hex\");\n    },\n    fromUTF8 (text) {\n        return Buffer.from(text, \"utf8\");\n    },\n    toUTF8 (buffer, start, end) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString(\"utf8\", start, end);\n    },\n    utf8ByteLength (input) {\n        return Buffer.byteLength(input, \"utf8\");\n    },\n    encodeUTF8Into (buffer, source, byteOffset) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).write(source, byteOffset, undefined, \"utf8\");\n    },\n    randomBytes: nodejsRandomBytes\n};\nfunction isReactNative() {\n    const { navigator } = globalThis;\n    return typeof navigator === \"object\" && navigator.product === \"ReactNative\";\n}\nfunction webMathRandomBytes(byteLength) {\n    if (byteLength < 0) {\n        throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);\n    }\n    return webByteUtils.fromNumberArray(Array.from({\n        length: byteLength\n    }, ()=>Math.floor(Math.random() * 256)));\n}\nconst webRandomBytes = (()=>{\n    const { crypto } = globalThis;\n    if (crypto != null && typeof crypto.getRandomValues === \"function\") {\n        return (byteLength)=>{\n            return crypto.getRandomValues(webByteUtils.allocate(byteLength));\n        };\n    } else {\n        if (isReactNative()) {\n            const { console } = globalThis;\n            console?.warn?.(\"BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.\");\n        }\n        return webMathRandomBytes;\n    }\n})();\nconst HEX_DIGIT = /(\\d|[a-f])/i;\nconst webByteUtils = {\n    toLocalBufferType (potentialUint8array) {\n        const stringTag = potentialUint8array?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialUint8array);\n        if (stringTag === \"Uint8Array\") {\n            return potentialUint8array;\n        }\n        if (ArrayBuffer.isView(potentialUint8array)) {\n            return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));\n        }\n        if (stringTag === \"ArrayBuffer\" || stringTag === \"SharedArrayBuffer\" || stringTag === \"[object ArrayBuffer]\" || stringTag === \"[object SharedArrayBuffer]\") {\n            return new Uint8Array(potentialUint8array);\n        }\n        throw new BSONError(`Cannot make a Uint8Array from ${String(potentialUint8array)}`);\n    },\n    allocate (size) {\n        if (typeof size !== \"number\") {\n            throw new TypeError(`The \"size\" argument must be of type number. Received ${String(size)}`);\n        }\n        return new Uint8Array(size);\n    },\n    equals (a, b) {\n        if (a.byteLength !== b.byteLength) {\n            return false;\n        }\n        for(let i = 0; i < a.byteLength; i++){\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    },\n    fromNumberArray (array) {\n        return Uint8Array.from(array);\n    },\n    fromBase64 (base64) {\n        return Uint8Array.from(atob(base64), (c)=>c.charCodeAt(0));\n    },\n    toBase64 (uint8array) {\n        return btoa(webByteUtils.toISO88591(uint8array));\n    },\n    fromISO88591 (codePoints) {\n        return Uint8Array.from(codePoints, (c)=>c.charCodeAt(0) & 0xff);\n    },\n    toISO88591 (uint8array) {\n        return Array.from(Uint16Array.from(uint8array), (b)=>String.fromCharCode(b)).join(\"\");\n    },\n    fromHex (hex) {\n        const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);\n        const buffer = [];\n        for(let i = 0; i < evenLengthHex.length; i += 2){\n            const firstDigit = evenLengthHex[i];\n            const secondDigit = evenLengthHex[i + 1];\n            if (!HEX_DIGIT.test(firstDigit)) {\n                break;\n            }\n            if (!HEX_DIGIT.test(secondDigit)) {\n                break;\n            }\n            const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);\n            buffer.push(hexDigit);\n        }\n        return Uint8Array.from(buffer);\n    },\n    toHex (uint8array) {\n        return Array.from(uint8array, (byte)=>byte.toString(16).padStart(2, \"0\")).join(\"\");\n    },\n    fromUTF8 (text) {\n        return new TextEncoder().encode(text);\n    },\n    toUTF8 (uint8array, start, end) {\n        return new TextDecoder(\"utf8\", {\n            fatal: false\n        }).decode(uint8array.slice(start, end));\n    },\n    utf8ByteLength (input) {\n        return webByteUtils.fromUTF8(input).byteLength;\n    },\n    encodeUTF8Into (buffer, source, byteOffset) {\n        const bytes = webByteUtils.fromUTF8(source);\n        buffer.set(bytes, byteOffset);\n        return bytes.byteLength;\n    },\n    randomBytes: webRandomBytes\n};\nconst hasGlobalBuffer = typeof Buffer === \"function\" && Buffer.prototype?._isBuffer !== true;\nconst ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;\nclass BSONDataView extends DataView {\n    static fromUint8Array(input) {\n        return new DataView(input.buffer, input.byteOffset, input.byteLength);\n    }\n}\nclass BSONValue {\n    get [Symbol.for(\"@@mdb.bson.version\")]() {\n        return BSON_MAJOR_VERSION;\n    }\n}\nclass Binary extends BSONValue {\n    get _bsontype() {\n        return \"Binary\";\n    }\n    constructor(buffer, subType){\n        super();\n        if (!(buffer == null) && !(typeof buffer === \"string\") && !ArrayBuffer.isView(buffer) && !(buffer instanceof ArrayBuffer) && !Array.isArray(buffer)) {\n            throw new BSONError(\"Binary can only be constructed from string, Buffer, TypedArray, or Array<number>\");\n        }\n        this.sub_type = subType ?? Binary.BSON_BINARY_SUBTYPE_DEFAULT;\n        if (buffer == null) {\n            this.buffer = ByteUtils.allocate(Binary.BUFFER_SIZE);\n            this.position = 0;\n        } else {\n            if (typeof buffer === \"string\") {\n                this.buffer = ByteUtils.fromISO88591(buffer);\n            } else if (Array.isArray(buffer)) {\n                this.buffer = ByteUtils.fromNumberArray(buffer);\n            } else {\n                this.buffer = ByteUtils.toLocalBufferType(buffer);\n            }\n            this.position = this.buffer.byteLength;\n        }\n    }\n    put(byteValue) {\n        if (typeof byteValue === \"string\" && byteValue.length !== 1) {\n            throw new BSONError(\"only accepts single character String\");\n        } else if (typeof byteValue !== \"number\" && byteValue.length !== 1) throw new BSONError(\"only accepts single character Uint8Array or Array\");\n        let decodedByte;\n        if (typeof byteValue === \"string\") {\n            decodedByte = byteValue.charCodeAt(0);\n        } else if (typeof byteValue === \"number\") {\n            decodedByte = byteValue;\n        } else {\n            decodedByte = byteValue[0];\n        }\n        if (decodedByte < 0 || decodedByte > 255) {\n            throw new BSONError(\"only accepts number in a valid unsigned byte range 0-255\");\n        }\n        if (this.buffer.byteLength > this.position) {\n            this.buffer[this.position++] = decodedByte;\n        } else {\n            const newSpace = ByteUtils.allocate(Binary.BUFFER_SIZE + this.buffer.length);\n            newSpace.set(this.buffer, 0);\n            this.buffer = newSpace;\n            this.buffer[this.position++] = decodedByte;\n        }\n    }\n    write(sequence, offset) {\n        offset = typeof offset === \"number\" ? offset : this.position;\n        if (this.buffer.byteLength < offset + sequence.length) {\n            const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);\n            newSpace.set(this.buffer, 0);\n            this.buffer = newSpace;\n        }\n        if (ArrayBuffer.isView(sequence)) {\n            this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);\n            this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;\n        } else if (typeof sequence === \"string\") {\n            const bytes = ByteUtils.fromISO88591(sequence);\n            this.buffer.set(bytes, offset);\n            this.position = offset + sequence.length > this.position ? offset + sequence.length : this.position;\n        }\n    }\n    read(position, length) {\n        length = length && length > 0 ? length : this.position;\n        return this.buffer.slice(position, position + length);\n    }\n    value(asRaw) {\n        asRaw = !!asRaw;\n        if (asRaw && this.buffer.length === this.position) {\n            return this.buffer;\n        }\n        if (asRaw) {\n            return this.buffer.slice(0, this.position);\n        }\n        return ByteUtils.toISO88591(this.buffer.subarray(0, this.position));\n    }\n    length() {\n        return this.position;\n    }\n    toJSON() {\n        return ByteUtils.toBase64(this.buffer);\n    }\n    toString(encoding) {\n        if (encoding === \"hex\") return ByteUtils.toHex(this.buffer);\n        if (encoding === \"base64\") return ByteUtils.toBase64(this.buffer);\n        if (encoding === \"utf8\" || encoding === \"utf-8\") return ByteUtils.toUTF8(this.buffer, 0, this.buffer.byteLength);\n        return ByteUtils.toUTF8(this.buffer, 0, this.buffer.byteLength);\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        const base64String = ByteUtils.toBase64(this.buffer);\n        const subType = Number(this.sub_type).toString(16);\n        if (options.legacy) {\n            return {\n                $binary: base64String,\n                $type: subType.length === 1 ? \"0\" + subType : subType\n            };\n        }\n        return {\n            $binary: {\n                base64: base64String,\n                subType: subType.length === 1 ? \"0\" + subType : subType\n            }\n        };\n    }\n    toUUID() {\n        if (this.sub_type === Binary.SUBTYPE_UUID) {\n            return new UUID(this.buffer.slice(0, this.position));\n        }\n        throw new BSONError(`Binary sub_type \"${this.sub_type}\" is not supported for converting to UUID. Only \"${Binary.SUBTYPE_UUID}\" is currently supported.`);\n    }\n    static createFromHexString(hex, subType) {\n        return new Binary(ByteUtils.fromHex(hex), subType);\n    }\n    static createFromBase64(base64, subType) {\n        return new Binary(ByteUtils.fromBase64(base64), subType);\n    }\n    static fromExtendedJSON(doc, options) {\n        options = options || {};\n        let data;\n        let type;\n        if (\"$binary\" in doc) {\n            if (options.legacy && typeof doc.$binary === \"string\" && \"$type\" in doc) {\n                type = doc.$type ? parseInt(doc.$type, 16) : 0;\n                data = ByteUtils.fromBase64(doc.$binary);\n            } else {\n                if (typeof doc.$binary !== \"string\") {\n                    type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;\n                    data = ByteUtils.fromBase64(doc.$binary.base64);\n                }\n            }\n        } else if (\"$uuid\" in doc) {\n            type = 4;\n            data = UUID.bytesFromString(doc.$uuid);\n        }\n        if (!data) {\n            throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);\n        }\n        return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return this.inspect();\n    }\n    inspect() {\n        const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));\n        return `Binary.createFromBase64(\"${base64}\", ${this.sub_type})`;\n    }\n}\nBinary.BSON_BINARY_SUBTYPE_DEFAULT = 0;\nBinary.BUFFER_SIZE = 256;\nBinary.SUBTYPE_DEFAULT = 0;\nBinary.SUBTYPE_FUNCTION = 1;\nBinary.SUBTYPE_BYTE_ARRAY = 2;\nBinary.SUBTYPE_UUID_OLD = 3;\nBinary.SUBTYPE_UUID = 4;\nBinary.SUBTYPE_MD5 = 5;\nBinary.SUBTYPE_ENCRYPTED = 6;\nBinary.SUBTYPE_COLUMN = 7;\nBinary.SUBTYPE_USER_DEFINED = 128;\nconst UUID_BYTE_LENGTH = 16;\nconst UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;\nconst UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;\nclass UUID extends Binary {\n    constructor(input){\n        let bytes;\n        if (input == null) {\n            bytes = UUID.generate();\n        } else if (input instanceof UUID) {\n            bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));\n        } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {\n            bytes = ByteUtils.toLocalBufferType(input);\n        } else if (typeof input === \"string\") {\n            bytes = UUID.bytesFromString(input);\n        } else {\n            throw new BSONError(\"Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).\");\n        }\n        super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);\n    }\n    get id() {\n        return this.buffer;\n    }\n    set id(value) {\n        this.buffer = value;\n    }\n    toHexString(includeDashes = true) {\n        if (includeDashes) {\n            return [\n                ByteUtils.toHex(this.buffer.subarray(0, 4)),\n                ByteUtils.toHex(this.buffer.subarray(4, 6)),\n                ByteUtils.toHex(this.buffer.subarray(6, 8)),\n                ByteUtils.toHex(this.buffer.subarray(8, 10)),\n                ByteUtils.toHex(this.buffer.subarray(10, 16))\n            ].join(\"-\");\n        }\n        return ByteUtils.toHex(this.buffer);\n    }\n    toString(encoding) {\n        if (encoding === \"hex\") return ByteUtils.toHex(this.id);\n        if (encoding === \"base64\") return ByteUtils.toBase64(this.id);\n        return this.toHexString();\n    }\n    toJSON() {\n        return this.toHexString();\n    }\n    equals(otherId) {\n        if (!otherId) {\n            return false;\n        }\n        if (otherId instanceof UUID) {\n            return ByteUtils.equals(otherId.id, this.id);\n        }\n        try {\n            return ByteUtils.equals(new UUID(otherId).id, this.id);\n        } catch  {\n            return false;\n        }\n    }\n    toBinary() {\n        return new Binary(this.id, Binary.SUBTYPE_UUID);\n    }\n    static generate() {\n        const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);\n        bytes[6] = bytes[6] & 0x0f | 0x40;\n        bytes[8] = bytes[8] & 0x3f | 0x80;\n        return bytes;\n    }\n    static isValid(input) {\n        if (!input) {\n            return false;\n        }\n        if (typeof input === \"string\") {\n            return UUID.isValidUUIDString(input);\n        }\n        if (isUint8Array(input)) {\n            return input.byteLength === UUID_BYTE_LENGTH;\n        }\n        return input._bsontype === \"Binary\" && input.sub_type === this.SUBTYPE_UUID && input.buffer.byteLength === 16;\n    }\n    static createFromHexString(hexString) {\n        const buffer = UUID.bytesFromString(hexString);\n        return new UUID(buffer);\n    }\n    static createFromBase64(base64) {\n        return new UUID(ByteUtils.fromBase64(base64));\n    }\n    static bytesFromString(representation) {\n        if (!UUID.isValidUUIDString(representation)) {\n            throw new BSONError(\"UUID string representation must be 32 hex digits or canonical hyphenated representation\");\n        }\n        return ByteUtils.fromHex(representation.replace(/-/g, \"\"));\n    }\n    static isValidUUIDString(representation) {\n        return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new UUID(\"${this.toHexString()}\")`;\n    }\n}\nUUID.cacheHexString = false;\nclass Code extends BSONValue {\n    get _bsontype() {\n        return \"Code\";\n    }\n    constructor(code, scope){\n        super();\n        this.code = code.toString();\n        this.scope = scope ?? null;\n    }\n    toJSON() {\n        if (this.scope != null) {\n            return {\n                code: this.code,\n                scope: this.scope\n            };\n        }\n        return {\n            code: this.code\n        };\n    }\n    toExtendedJSON() {\n        if (this.scope) {\n            return {\n                $code: this.code,\n                $scope: this.scope\n            };\n        }\n        return {\n            $code: this.code\n        };\n    }\n    static fromExtendedJSON(doc) {\n        return new Code(doc.$code, doc.$scope);\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return this.inspect();\n    }\n    inspect() {\n        const codeJson = this.toJSON();\n        return `new Code(\"${String(codeJson.code)}\"${codeJson.scope != null ? `, ${JSON.stringify(codeJson.scope)}` : \"\"})`;\n    }\n}\nfunction isDBRefLike(value) {\n    return value != null && typeof value === \"object\" && \"$id\" in value && value.$id != null && \"$ref\" in value && typeof value.$ref === \"string\" && (!(\"$db\" in value) || \"$db\" in value && typeof value.$db === \"string\");\n}\nclass DBRef extends BSONValue {\n    get _bsontype() {\n        return \"DBRef\";\n    }\n    constructor(collection, oid, db, fields){\n        super();\n        const parts = collection.split(\".\");\n        if (parts.length === 2) {\n            db = parts.shift();\n            collection = parts.shift();\n        }\n        this.collection = collection;\n        this.oid = oid;\n        this.db = db;\n        this.fields = fields || {};\n    }\n    get namespace() {\n        return this.collection;\n    }\n    set namespace(value) {\n        this.collection = value;\n    }\n    toJSON() {\n        const o = Object.assign({\n            $ref: this.collection,\n            $id: this.oid\n        }, this.fields);\n        if (this.db != null) o.$db = this.db;\n        return o;\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        let o = {\n            $ref: this.collection,\n            $id: this.oid\n        };\n        if (options.legacy) {\n            return o;\n        }\n        if (this.db) o.$db = this.db;\n        o = Object.assign(o, this.fields);\n        return o;\n    }\n    static fromExtendedJSON(doc) {\n        const copy = Object.assign({}, doc);\n        delete copy.$ref;\n        delete copy.$id;\n        delete copy.$db;\n        return new DBRef(doc.$ref, doc.$id, doc.$db, copy);\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return this.inspect();\n    }\n    inspect() {\n        const oid = this.oid === undefined || this.oid.toString === undefined ? this.oid : this.oid.toString();\n        return `new DBRef(\"${this.namespace}\", new ObjectId(\"${String(oid)}\")${this.db ? `, \"${this.db}\"` : \"\"})`;\n    }\n}\nlet wasm = undefined;\ntry {\n    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n        0,\n        97,\n        115,\n        109,\n        1,\n        0,\n        0,\n        0,\n        1,\n        13,\n        2,\n        96,\n        0,\n        1,\n        127,\n        96,\n        4,\n        127,\n        127,\n        127,\n        127,\n        1,\n        127,\n        3,\n        7,\n        6,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        6,\n        6,\n        1,\n        127,\n        1,\n        65,\n        0,\n        11,\n        7,\n        50,\n        6,\n        3,\n        109,\n        117,\n        108,\n        0,\n        1,\n        5,\n        100,\n        105,\n        118,\n        95,\n        115,\n        0,\n        2,\n        5,\n        100,\n        105,\n        118,\n        95,\n        117,\n        0,\n        3,\n        5,\n        114,\n        101,\n        109,\n        95,\n        115,\n        0,\n        4,\n        5,\n        114,\n        101,\n        109,\n        95,\n        117,\n        0,\n        5,\n        8,\n        103,\n        101,\n        116,\n        95,\n        104,\n        105,\n        103,\n        104,\n        0,\n        0,\n        10,\n        191,\n        1,\n        6,\n        4,\n        0,\n        35,\n        0,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        126,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        127,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        128,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        129,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        130,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11\n    ])), {}).exports;\n} catch  {}\nconst TWO_PWR_16_DBL = 1 << 16;\nconst TWO_PWR_24_DBL = 1 << 24;\nconst TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nconst TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\nconst TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\nconst INT_CACHE = {};\nconst UINT_CACHE = {};\nconst MAX_INT64_STRING_LENGTH = 20;\nconst DECIMAL_REG_EX = /^(\\+?0|(\\+|-)?[1-9][0-9]*)$/;\nclass Long extends BSONValue {\n    get _bsontype() {\n        return \"Long\";\n    }\n    get __isLong__() {\n        return true;\n    }\n    constructor(low = 0, high, unsigned){\n        super();\n        if (typeof low === \"bigint\") {\n            Object.assign(this, Long.fromBigInt(low, !!high));\n        } else if (typeof low === \"string\") {\n            Object.assign(this, Long.fromString(low, !!high));\n        } else {\n            this.low = low | 0;\n            this.high = high | 0;\n            this.unsigned = !!unsigned;\n        }\n    }\n    static fromBits(lowBits, highBits, unsigned) {\n        return new Long(lowBits, highBits, unsigned);\n    }\n    static fromInt(value, unsigned) {\n        let obj, cachedObj, cache;\n        if (unsigned) {\n            value >>>= 0;\n            if (cache = 0 <= value && value < 256) {\n                cachedObj = UINT_CACHE[value];\n                if (cachedObj) return cachedObj;\n            }\n            obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n            if (cache) UINT_CACHE[value] = obj;\n            return obj;\n        } else {\n            value |= 0;\n            if (cache = -128 <= value && value < 128) {\n                cachedObj = INT_CACHE[value];\n                if (cachedObj) return cachedObj;\n            }\n            obj = Long.fromBits(value, value < 0 ? -1 : 0, false);\n            if (cache) INT_CACHE[value] = obj;\n            return obj;\n        }\n    }\n    static fromNumber(value, unsigned) {\n        if (isNaN(value)) return unsigned ? Long.UZERO : Long.ZERO;\n        if (unsigned) {\n            if (value < 0) return Long.UZERO;\n            if (value >= TWO_PWR_64_DBL) return Long.MAX_UNSIGNED_VALUE;\n        } else {\n            if (value <= -TWO_PWR_63_DBL) return Long.MIN_VALUE;\n            if (value + 1 >= TWO_PWR_63_DBL) return Long.MAX_VALUE;\n        }\n        if (value < 0) return Long.fromNumber(-value, unsigned).neg();\n        return Long.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n    }\n    static fromBigInt(value, unsigned) {\n        return Long.fromString(value.toString(), unsigned);\n    }\n    static fromString(str, unsigned, radix) {\n        if (str.length === 0) throw new BSONError(\"empty string\");\n        if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\") return Long.ZERO;\n        if (typeof unsigned === \"number\") {\n            radix = unsigned, unsigned = false;\n        } else {\n            unsigned = !!unsigned;\n        }\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix) throw new BSONError(\"radix\");\n        let p;\n        if ((p = str.indexOf(\"-\")) > 0) throw new BSONError(\"interior hyphen\");\n        else if (p === 0) {\n            return Long.fromString(str.substring(1), unsigned, radix).neg();\n        }\n        const radixToPower = Long.fromNumber(Math.pow(radix, 8));\n        let result = Long.ZERO;\n        for(let i = 0; i < str.length; i += 8){\n            const size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n            if (size < 8) {\n                const power = Long.fromNumber(Math.pow(radix, size));\n                result = result.mul(power).add(Long.fromNumber(value));\n            } else {\n                result = result.mul(radixToPower);\n                result = result.add(Long.fromNumber(value));\n            }\n        }\n        result.unsigned = unsigned;\n        return result;\n    }\n    static fromBytes(bytes, unsigned, le) {\n        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n    }\n    static fromBytesLE(bytes, unsigned) {\n        return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);\n    }\n    static fromBytesBE(bytes, unsigned) {\n        return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);\n    }\n    static isLong(value) {\n        return value != null && typeof value === \"object\" && \"__isLong__\" in value && value.__isLong__ === true;\n    }\n    static fromValue(val, unsigned) {\n        if (typeof val === \"number\") return Long.fromNumber(val, unsigned);\n        if (typeof val === \"string\") return Long.fromString(val, unsigned);\n        return Long.fromBits(val.low, val.high, typeof unsigned === \"boolean\" ? unsigned : val.unsigned);\n    }\n    add(addend) {\n        if (!Long.isLong(addend)) addend = Long.fromValue(addend);\n        const a48 = this.high >>> 16;\n        const a32 = this.high & 0xffff;\n        const a16 = this.low >>> 16;\n        const a00 = this.low & 0xffff;\n        const b48 = addend.high >>> 16;\n        const b32 = addend.high & 0xffff;\n        const b16 = addend.low >>> 16;\n        const b00 = addend.low & 0xffff;\n        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 + b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xffff;\n        c16 += a16 + b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c32 += a32 + b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c48 += a48 + b48;\n        c48 &= 0xffff;\n        return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    }\n    and(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n    }\n    compare(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        if (this.eq(other)) return 0;\n        const thisNeg = this.isNegative(), otherNeg = other.isNegative();\n        if (thisNeg && !otherNeg) return -1;\n        if (!thisNeg && otherNeg) return 1;\n        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;\n        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n    }\n    comp(other) {\n        return this.compare(other);\n    }\n    divide(divisor) {\n        if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor);\n        if (divisor.isZero()) throw new BSONError(\"division by zero\");\n        if (wasm) {\n            if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {\n                return this;\n            }\n            const low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        if (this.isZero()) return this.unsigned ? Long.UZERO : Long.ZERO;\n        let approx, rem, res;\n        if (!this.unsigned) {\n            if (this.eq(Long.MIN_VALUE)) {\n                if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE)) return Long.MIN_VALUE;\n                else if (divisor.eq(Long.MIN_VALUE)) return Long.ONE;\n                else {\n                    const halfThis = this.shr(1);\n                    approx = halfThis.div(divisor).shl(1);\n                    if (approx.eq(Long.ZERO)) {\n                        return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;\n                    } else {\n                        rem = this.sub(divisor.mul(approx));\n                        res = approx.add(rem.div(divisor));\n                        return res;\n                    }\n                }\n            } else if (divisor.eq(Long.MIN_VALUE)) return this.unsigned ? Long.UZERO : Long.ZERO;\n            if (this.isNegative()) {\n                if (divisor.isNegative()) return this.neg().div(divisor.neg());\n                return this.neg().div(divisor).neg();\n            } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();\n            res = Long.ZERO;\n        } else {\n            if (!divisor.unsigned) divisor = divisor.toUnsigned();\n            if (divisor.gt(this)) return Long.UZERO;\n            if (divisor.gt(this.shru(1))) return Long.UONE;\n            res = Long.UZERO;\n        }\n        rem = this;\n        while(rem.gte(divisor)){\n            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n            const log2 = Math.ceil(Math.log(approx) / Math.LN2);\n            const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n            let approxRes = Long.fromNumber(approx);\n            let approxRem = approxRes.mul(divisor);\n            while(approxRem.isNegative() || approxRem.gt(rem)){\n                approx -= delta;\n                approxRes = Long.fromNumber(approx, this.unsigned);\n                approxRem = approxRes.mul(divisor);\n            }\n            if (approxRes.isZero()) approxRes = Long.ONE;\n            res = res.add(approxRes);\n            rem = rem.sub(approxRem);\n        }\n        return res;\n    }\n    div(divisor) {\n        return this.divide(divisor);\n    }\n    equals(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n        return this.high === other.high && this.low === other.low;\n    }\n    eq(other) {\n        return this.equals(other);\n    }\n    getHighBits() {\n        return this.high;\n    }\n    getHighBitsUnsigned() {\n        return this.high >>> 0;\n    }\n    getLowBits() {\n        return this.low;\n    }\n    getLowBitsUnsigned() {\n        return this.low >>> 0;\n    }\n    getNumBitsAbs() {\n        if (this.isNegative()) {\n            return this.eq(Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n        }\n        const val = this.high !== 0 ? this.high : this.low;\n        let bit;\n        for(bit = 31; bit > 0; bit--)if ((val & 1 << bit) !== 0) break;\n        return this.high !== 0 ? bit + 33 : bit + 1;\n    }\n    greaterThan(other) {\n        return this.comp(other) > 0;\n    }\n    gt(other) {\n        return this.greaterThan(other);\n    }\n    greaterThanOrEqual(other) {\n        return this.comp(other) >= 0;\n    }\n    gte(other) {\n        return this.greaterThanOrEqual(other);\n    }\n    ge(other) {\n        return this.greaterThanOrEqual(other);\n    }\n    isEven() {\n        return (this.low & 1) === 0;\n    }\n    isNegative() {\n        return !this.unsigned && this.high < 0;\n    }\n    isOdd() {\n        return (this.low & 1) === 1;\n    }\n    isPositive() {\n        return this.unsigned || this.high >= 0;\n    }\n    isZero() {\n        return this.high === 0 && this.low === 0;\n    }\n    lessThan(other) {\n        return this.comp(other) < 0;\n    }\n    lt(other) {\n        return this.lessThan(other);\n    }\n    lessThanOrEqual(other) {\n        return this.comp(other) <= 0;\n    }\n    lte(other) {\n        return this.lessThanOrEqual(other);\n    }\n    modulo(divisor) {\n        if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor);\n        if (wasm) {\n            const low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        return this.sub(this.div(divisor).mul(divisor));\n    }\n    mod(divisor) {\n        return this.modulo(divisor);\n    }\n    rem(divisor) {\n        return this.modulo(divisor);\n    }\n    multiply(multiplier) {\n        if (this.isZero()) return Long.ZERO;\n        if (!Long.isLong(multiplier)) multiplier = Long.fromValue(multiplier);\n        if (wasm) {\n            const low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        if (multiplier.isZero()) return Long.ZERO;\n        if (this.eq(Long.MIN_VALUE)) return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n        if (multiplier.eq(Long.MIN_VALUE)) return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n        if (this.isNegative()) {\n            if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());\n            else return this.neg().mul(multiplier).neg();\n        } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();\n        if (this.lt(Long.TWO_PWR_24) && multiplier.lt(Long.TWO_PWR_24)) return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n        const a48 = this.high >>> 16;\n        const a32 = this.high & 0xffff;\n        const a16 = this.low >>> 16;\n        const a00 = this.low & 0xffff;\n        const b48 = multiplier.high >>> 16;\n        const b32 = multiplier.high & 0xffff;\n        const b16 = multiplier.low >>> 16;\n        const b00 = multiplier.low & 0xffff;\n        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 * b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xffff;\n        c16 += a16 * b00;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c16 += a00 * b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c32 += a32 * b00;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c32 += a16 * b16;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c32 += a00 * b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n        c48 &= 0xffff;\n        return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    }\n    mul(multiplier) {\n        return this.multiply(multiplier);\n    }\n    negate() {\n        if (!this.unsigned && this.eq(Long.MIN_VALUE)) return Long.MIN_VALUE;\n        return this.not().add(Long.ONE);\n    }\n    neg() {\n        return this.negate();\n    }\n    not() {\n        return Long.fromBits(~this.low, ~this.high, this.unsigned);\n    }\n    notEquals(other) {\n        return !this.equals(other);\n    }\n    neq(other) {\n        return this.notEquals(other);\n    }\n    ne(other) {\n        return this.notEquals(other);\n    }\n    or(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n    }\n    shiftLeft(numBits) {\n        if (Long.isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        else if (numBits < 32) return Long.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);\n        else return Long.fromBits(0, this.low << numBits - 32, this.unsigned);\n    }\n    shl(numBits) {\n        return this.shiftLeft(numBits);\n    }\n    shiftRight(numBits) {\n        if (Long.isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        else if (numBits < 32) return Long.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);\n        else return Long.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n    }\n    shr(numBits) {\n        return this.shiftRight(numBits);\n    }\n    shiftRightUnsigned(numBits) {\n        if (Long.isLong(numBits)) numBits = numBits.toInt();\n        numBits &= 63;\n        if (numBits === 0) return this;\n        else {\n            const high = this.high;\n            if (numBits < 32) {\n                const low = this.low;\n                return Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);\n            } else if (numBits === 32) return Long.fromBits(high, 0, this.unsigned);\n            else return Long.fromBits(high >>> numBits - 32, 0, this.unsigned);\n        }\n    }\n    shr_u(numBits) {\n        return this.shiftRightUnsigned(numBits);\n    }\n    shru(numBits) {\n        return this.shiftRightUnsigned(numBits);\n    }\n    subtract(subtrahend) {\n        if (!Long.isLong(subtrahend)) subtrahend = Long.fromValue(subtrahend);\n        return this.add(subtrahend.neg());\n    }\n    sub(subtrahend) {\n        return this.subtract(subtrahend);\n    }\n    toInt() {\n        return this.unsigned ? this.low >>> 0 : this.low;\n    }\n    toNumber() {\n        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    }\n    toBigInt() {\n        return BigInt(this.toString());\n    }\n    toBytes(le) {\n        return le ? this.toBytesLE() : this.toBytesBE();\n    }\n    toBytesLE() {\n        const hi = this.high, lo = this.low;\n        return [\n            lo & 0xff,\n            lo >>> 8 & 0xff,\n            lo >>> 16 & 0xff,\n            lo >>> 24,\n            hi & 0xff,\n            hi >>> 8 & 0xff,\n            hi >>> 16 & 0xff,\n            hi >>> 24\n        ];\n    }\n    toBytesBE() {\n        const hi = this.high, lo = this.low;\n        return [\n            hi >>> 24,\n            hi >>> 16 & 0xff,\n            hi >>> 8 & 0xff,\n            hi & 0xff,\n            lo >>> 24,\n            lo >>> 16 & 0xff,\n            lo >>> 8 & 0xff,\n            lo & 0xff\n        ];\n    }\n    toSigned() {\n        if (!this.unsigned) return this;\n        return Long.fromBits(this.low, this.high, false);\n    }\n    toString(radix) {\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix) throw new BSONError(\"radix\");\n        if (this.isZero()) return \"0\";\n        if (this.isNegative()) {\n            if (this.eq(Long.MIN_VALUE)) {\n                const radixLong = Long.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n                return div.toString(radix) + rem1.toInt().toString(radix);\n            } else return \"-\" + this.neg().toString(radix);\n        }\n        const radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);\n        let rem = this;\n        let result = \"\";\n        while(true){\n            const remDiv = rem.div(radixToPower);\n            const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;\n            let digits = intval.toString(radix);\n            rem = remDiv;\n            if (rem.isZero()) {\n                return digits + result;\n            } else {\n                while(digits.length < 6)digits = \"0\" + digits;\n                result = \"\" + digits + result;\n            }\n        }\n    }\n    toUnsigned() {\n        if (this.unsigned) return this;\n        return Long.fromBits(this.low, this.high, true);\n    }\n    xor(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n    }\n    eqz() {\n        return this.isZero();\n    }\n    le(other) {\n        return this.lessThanOrEqual(other);\n    }\n    toExtendedJSON(options) {\n        if (options && options.relaxed) return this.toNumber();\n        return {\n            $numberLong: this.toString()\n        };\n    }\n    static fromExtendedJSON(doc, options) {\n        const { useBigInt64 = false, relaxed = true } = {\n            ...options\n        };\n        if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {\n            throw new BSONError(\"$numberLong string is too long\");\n        }\n        if (!DECIMAL_REG_EX.test(doc.$numberLong)) {\n            throw new BSONError(`$numberLong string \"${doc.$numberLong}\" is in an invalid format`);\n        }\n        if (useBigInt64) {\n            const bigIntResult = BigInt(doc.$numberLong);\n            return BigInt.asIntN(64, bigIntResult);\n        }\n        const longResult = Long.fromString(doc.$numberLong);\n        if (relaxed) {\n            return longResult.toNumber();\n        }\n        return longResult;\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new Long(\"${this.toString()}\"${this.unsigned ? \", true\" : \"\"})`;\n    }\n}\nLong.TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);\nLong.MAX_UNSIGNED_VALUE = Long.fromBits(0xffffffff | 0, 0xffffffff | 0, true);\nLong.ZERO = Long.fromInt(0);\nLong.UZERO = Long.fromInt(0, true);\nLong.ONE = Long.fromInt(1);\nLong.UONE = Long.fromInt(1, true);\nLong.NEG_ONE = Long.fromInt(-1);\nLong.MAX_VALUE = Long.fromBits(0xffffffff | 0, 0x7fffffff | 0, false);\nLong.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0, false);\nconst PARSE_STRING_REGEXP = /^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$/;\nconst PARSE_INF_REGEXP = /^(\\+|-)?(Infinity|inf)$/i;\nconst PARSE_NAN_REGEXP = /^(\\+|-)?NaN$/i;\nconst EXPONENT_MAX = 6111;\nconst EXPONENT_MIN = -6176;\nconst EXPONENT_BIAS = 6176;\nconst MAX_DIGITS = 34;\nconst NAN_BUFFER = ByteUtils.fromNumberArray([\n    0x7c,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00\n].reverse());\nconst INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([\n    0xf8,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00\n].reverse());\nconst INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([\n    0x78,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00\n].reverse());\nconst EXPONENT_REGEX = /^([-+])?(\\d+)?$/;\nconst COMBINATION_MASK = 0x1f;\nconst EXPONENT_MASK = 0x3fff;\nconst COMBINATION_INFINITY = 30;\nconst COMBINATION_NAN = 31;\nfunction isDigit(value) {\n    return !isNaN(parseInt(value, 10));\n}\nfunction divideu128(value) {\n    const DIVISOR = Long.fromNumber(1000 * 1000 * 1000);\n    let _rem = Long.fromNumber(0);\n    if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {\n        return {\n            quotient: value,\n            rem: _rem\n        };\n    }\n    for(let i = 0; i <= 3; i++){\n        _rem = _rem.shiftLeft(32);\n        _rem = _rem.add(new Long(value.parts[i], 0));\n        value.parts[i] = _rem.div(DIVISOR).low;\n        _rem = _rem.modulo(DIVISOR);\n    }\n    return {\n        quotient: value,\n        rem: _rem\n    };\n}\nfunction multiply64x2(left, right) {\n    if (!left && !right) {\n        return {\n            high: Long.fromNumber(0),\n            low: Long.fromNumber(0)\n        };\n    }\n    const leftHigh = left.shiftRightUnsigned(32);\n    const leftLow = new Long(left.getLowBits(), 0);\n    const rightHigh = right.shiftRightUnsigned(32);\n    const rightLow = new Long(right.getLowBits(), 0);\n    let productHigh = leftHigh.multiply(rightHigh);\n    let productMid = leftHigh.multiply(rightLow);\n    const productMid2 = leftLow.multiply(rightHigh);\n    let productLow = leftLow.multiply(rightLow);\n    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n    productMid = new Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));\n    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n    productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));\n    return {\n        high: productHigh,\n        low: productLow\n    };\n}\nfunction lessThan(left, right) {\n    const uhleft = left.high >>> 0;\n    const uhright = right.high >>> 0;\n    if (uhleft < uhright) {\n        return true;\n    } else if (uhleft === uhright) {\n        const ulleft = left.low >>> 0;\n        const ulright = right.low >>> 0;\n        if (ulleft < ulright) return true;\n    }\n    return false;\n}\nfunction invalidErr(string, message) {\n    throw new BSONError(`\"${string}\" is not a valid Decimal128 string - ${message}`);\n}\nclass Decimal128 extends BSONValue {\n    get _bsontype() {\n        return \"Decimal128\";\n    }\n    constructor(bytes){\n        super();\n        if (typeof bytes === \"string\") {\n            this.bytes = Decimal128.fromString(bytes).bytes;\n        } else if (isUint8Array(bytes)) {\n            if (bytes.byteLength !== 16) {\n                throw new BSONError(\"Decimal128 must take a Buffer of 16 bytes\");\n            }\n            this.bytes = bytes;\n        } else {\n            throw new BSONError(\"Decimal128 must take a Buffer or string\");\n        }\n    }\n    static fromString(representation) {\n        return Decimal128._fromString(representation, {\n            allowRounding: false\n        });\n    }\n    static fromStringWithRounding(representation) {\n        return Decimal128._fromString(representation, {\n            allowRounding: true\n        });\n    }\n    static _fromString(representation, options) {\n        let isNegative = false;\n        let sawSign = false;\n        let sawRadix = false;\n        let foundNonZero = false;\n        let significantDigits = 0;\n        let nDigitsRead = 0;\n        let nDigits = 0;\n        let radixPosition = 0;\n        let firstNonZero = 0;\n        const digits = [\n            0\n        ];\n        let nDigitsStored = 0;\n        let digitsInsert = 0;\n        let lastDigit = 0;\n        let exponent = 0;\n        let significandHigh = new Long(0, 0);\n        let significandLow = new Long(0, 0);\n        let biasedExponent = 0;\n        let index = 0;\n        if (representation.length >= 7000) {\n            throw new BSONError(\"\" + representation + \" not a valid Decimal128 string\");\n        }\n        const stringMatch = representation.match(PARSE_STRING_REGEXP);\n        const infMatch = representation.match(PARSE_INF_REGEXP);\n        const nanMatch = representation.match(PARSE_NAN_REGEXP);\n        if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {\n            throw new BSONError(\"\" + representation + \" not a valid Decimal128 string\");\n        }\n        if (stringMatch) {\n            const unsignedNumber = stringMatch[2];\n            const e = stringMatch[4];\n            const expSign = stringMatch[5];\n            const expNumber = stringMatch[6];\n            if (e && expNumber === undefined) invalidErr(representation, \"missing exponent power\");\n            if (e && unsignedNumber === undefined) invalidErr(representation, \"missing exponent base\");\n            if (e === undefined && (expSign || expNumber)) {\n                invalidErr(representation, \"missing e before exponent\");\n            }\n        }\n        if (representation[index] === \"+\" || representation[index] === \"-\") {\n            sawSign = true;\n            isNegative = representation[index++] === \"-\";\n        }\n        if (!isDigit(representation[index]) && representation[index] !== \".\") {\n            if (representation[index] === \"i\" || representation[index] === \"I\") {\n                return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);\n            } else if (representation[index] === \"N\") {\n                return new Decimal128(NAN_BUFFER);\n            }\n        }\n        while(isDigit(representation[index]) || representation[index] === \".\"){\n            if (representation[index] === \".\") {\n                if (sawRadix) invalidErr(representation, \"contains multiple periods\");\n                sawRadix = true;\n                index = index + 1;\n                continue;\n            }\n            if (nDigitsStored < MAX_DIGITS) {\n                if (representation[index] !== \"0\" || foundNonZero) {\n                    if (!foundNonZero) {\n                        firstNonZero = nDigitsRead;\n                    }\n                    foundNonZero = true;\n                    digits[digitsInsert++] = parseInt(representation[index], 10);\n                    nDigitsStored = nDigitsStored + 1;\n                }\n            }\n            if (foundNonZero) nDigits = nDigits + 1;\n            if (sawRadix) radixPosition = radixPosition + 1;\n            nDigitsRead = nDigitsRead + 1;\n            index = index + 1;\n        }\n        if (sawRadix && !nDigitsRead) throw new BSONError(\"\" + representation + \" not a valid Decimal128 string\");\n        if (representation[index] === \"e\" || representation[index] === \"E\") {\n            const match = representation.substr(++index).match(EXPONENT_REGEX);\n            if (!match || !match[2]) return new Decimal128(NAN_BUFFER);\n            exponent = parseInt(match[0], 10);\n            index = index + match[0].length;\n        }\n        if (representation[index]) return new Decimal128(NAN_BUFFER);\n        if (!nDigitsStored) {\n            digits[0] = 0;\n            nDigits = 1;\n            nDigitsStored = 1;\n            significantDigits = 0;\n        } else {\n            lastDigit = nDigitsStored - 1;\n            significantDigits = nDigits;\n            if (significantDigits !== 1) {\n                while(representation[firstNonZero + significantDigits - 1 + Number(sawSign) + Number(sawRadix)] === \"0\"){\n                    significantDigits = significantDigits - 1;\n                }\n            }\n        }\n        if (exponent <= radixPosition && radixPosition > exponent + (1 << 14)) {\n            exponent = EXPONENT_MIN;\n        } else {\n            exponent = exponent - radixPosition;\n        }\n        while(exponent > EXPONENT_MAX){\n            lastDigit = lastDigit + 1;\n            if (lastDigit >= MAX_DIGITS) {\n                if (significantDigits === 0) {\n                    exponent = EXPONENT_MAX;\n                    break;\n                }\n                invalidErr(representation, \"overflow\");\n            }\n            exponent = exponent - 1;\n        }\n        if (options.allowRounding) {\n            while(exponent < EXPONENT_MIN || nDigitsStored < nDigits){\n                if (lastDigit === 0 && significantDigits < nDigitsStored) {\n                    exponent = EXPONENT_MIN;\n                    significantDigits = 0;\n                    break;\n                }\n                if (nDigitsStored < nDigits) {\n                    nDigits = nDigits - 1;\n                } else {\n                    lastDigit = lastDigit - 1;\n                }\n                if (exponent < EXPONENT_MAX) {\n                    exponent = exponent + 1;\n                } else {\n                    const digitsString = digits.join(\"\");\n                    if (digitsString.match(/^0+$/)) {\n                        exponent = EXPONENT_MAX;\n                        break;\n                    }\n                    invalidErr(representation, \"overflow\");\n                }\n            }\n            if (lastDigit + 1 < significantDigits) {\n                let endOfString = nDigitsRead;\n                if (sawRadix) {\n                    firstNonZero = firstNonZero + 1;\n                    endOfString = endOfString + 1;\n                }\n                if (sawSign) {\n                    firstNonZero = firstNonZero + 1;\n                    endOfString = endOfString + 1;\n                }\n                const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);\n                let roundBit = 0;\n                if (roundDigit >= 5) {\n                    roundBit = 1;\n                    if (roundDigit === 5) {\n                        roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;\n                        for(let i = firstNonZero + lastDigit + 2; i < endOfString; i++){\n                            if (parseInt(representation[i], 10)) {\n                                roundBit = 1;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (roundBit) {\n                    let dIdx = lastDigit;\n                    for(; dIdx >= 0; dIdx--){\n                        if (++digits[dIdx] > 9) {\n                            digits[dIdx] = 0;\n                            if (dIdx === 0) {\n                                if (exponent < EXPONENT_MAX) {\n                                    exponent = exponent + 1;\n                                    digits[dIdx] = 1;\n                                } else {\n                                    return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);\n                                }\n                            }\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n        } else {\n            while(exponent < EXPONENT_MIN || nDigitsStored < nDigits){\n                if (lastDigit === 0) {\n                    if (significantDigits === 0) {\n                        exponent = EXPONENT_MIN;\n                        break;\n                    }\n                    invalidErr(representation, \"exponent underflow\");\n                }\n                if (nDigitsStored < nDigits) {\n                    if (representation[nDigits - 1 + Number(sawSign) + Number(sawRadix)] !== \"0\" && significantDigits !== 0) {\n                        invalidErr(representation, \"inexact rounding\");\n                    }\n                    nDigits = nDigits - 1;\n                } else {\n                    if (digits[lastDigit] !== 0) {\n                        invalidErr(representation, \"inexact rounding\");\n                    }\n                    lastDigit = lastDigit - 1;\n                }\n                if (exponent < EXPONENT_MAX) {\n                    exponent = exponent + 1;\n                } else {\n                    invalidErr(representation, \"overflow\");\n                }\n            }\n            if (lastDigit + 1 < significantDigits) {\n                if (sawRadix) {\n                    firstNonZero = firstNonZero + 1;\n                }\n                if (sawSign) {\n                    firstNonZero = firstNonZero + 1;\n                }\n                const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);\n                if (roundDigit !== 0) {\n                    invalidErr(representation, \"inexact rounding\");\n                }\n            }\n        }\n        significandHigh = Long.fromNumber(0);\n        significandLow = Long.fromNumber(0);\n        if (significantDigits === 0) {\n            significandHigh = Long.fromNumber(0);\n            significandLow = Long.fromNumber(0);\n        } else if (lastDigit < 17) {\n            let dIdx = 0;\n            significandLow = Long.fromNumber(digits[dIdx++]);\n            significandHigh = new Long(0, 0);\n            for(; dIdx <= lastDigit; dIdx++){\n                significandLow = significandLow.multiply(Long.fromNumber(10));\n                significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n            }\n        } else {\n            let dIdx = 0;\n            significandHigh = Long.fromNumber(digits[dIdx++]);\n            for(; dIdx <= lastDigit - 17; dIdx++){\n                significandHigh = significandHigh.multiply(Long.fromNumber(10));\n                significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));\n            }\n            significandLow = Long.fromNumber(digits[dIdx++]);\n            for(; dIdx <= lastDigit; dIdx++){\n                significandLow = significandLow.multiply(Long.fromNumber(10));\n                significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n            }\n        }\n        const significand = multiply64x2(significandHigh, Long.fromString(\"100000000000000000\"));\n        significand.low = significand.low.add(significandLow);\n        if (lessThan(significand.low, significandLow)) {\n            significand.high = significand.high.add(Long.fromNumber(1));\n        }\n        biasedExponent = exponent + EXPONENT_BIAS;\n        const dec = {\n            low: Long.fromNumber(0),\n            high: Long.fromNumber(0)\n        };\n        if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {\n            dec.high = dec.high.or(Long.fromNumber(0x3).shiftLeft(61));\n            dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47)));\n            dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)));\n        } else {\n            dec.high = dec.high.or(Long.fromNumber(biasedExponent & 0x3fff).shiftLeft(49));\n            dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff)));\n        }\n        dec.low = significand.low;\n        if (isNegative) {\n            dec.high = dec.high.or(Long.fromString(\"9223372036854775808\"));\n        }\n        const buffer = ByteUtils.allocate(16);\n        index = 0;\n        buffer[index++] = dec.low.low & 0xff;\n        buffer[index++] = dec.low.low >> 8 & 0xff;\n        buffer[index++] = dec.low.low >> 16 & 0xff;\n        buffer[index++] = dec.low.low >> 24 & 0xff;\n        buffer[index++] = dec.low.high & 0xff;\n        buffer[index++] = dec.low.high >> 8 & 0xff;\n        buffer[index++] = dec.low.high >> 16 & 0xff;\n        buffer[index++] = dec.low.high >> 24 & 0xff;\n        buffer[index++] = dec.high.low & 0xff;\n        buffer[index++] = dec.high.low >> 8 & 0xff;\n        buffer[index++] = dec.high.low >> 16 & 0xff;\n        buffer[index++] = dec.high.low >> 24 & 0xff;\n        buffer[index++] = dec.high.high & 0xff;\n        buffer[index++] = dec.high.high >> 8 & 0xff;\n        buffer[index++] = dec.high.high >> 16 & 0xff;\n        buffer[index++] = dec.high.high >> 24 & 0xff;\n        return new Decimal128(buffer);\n    }\n    toString() {\n        let biased_exponent;\n        let significand_digits = 0;\n        const significand = new Array(36);\n        for(let i = 0; i < significand.length; i++)significand[i] = 0;\n        let index = 0;\n        let is_zero = false;\n        let significand_msb;\n        let significand128 = {\n            parts: [\n                0,\n                0,\n                0,\n                0\n            ]\n        };\n        let j, k;\n        const string = [];\n        index = 0;\n        const buffer = this.bytes;\n        const low = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n        const midl = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n        const midh = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n        const high = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n        index = 0;\n        const dec = {\n            low: new Long(low, midl),\n            high: new Long(midh, high)\n        };\n        if (dec.high.lessThan(Long.ZERO)) {\n            string.push(\"-\");\n        }\n        const combination = high >> 26 & COMBINATION_MASK;\n        if (combination >> 3 === 3) {\n            if (combination === COMBINATION_INFINITY) {\n                return string.join(\"\") + \"Infinity\";\n            } else if (combination === COMBINATION_NAN) {\n                return \"NaN\";\n            } else {\n                biased_exponent = high >> 15 & EXPONENT_MASK;\n                significand_msb = 0x08 + (high >> 14 & 0x01);\n            }\n        } else {\n            significand_msb = high >> 14 & 0x07;\n            biased_exponent = high >> 17 & EXPONENT_MASK;\n        }\n        const exponent = biased_exponent - EXPONENT_BIAS;\n        significand128.parts[0] = (high & 0x3fff) + ((significand_msb & 0xf) << 14);\n        significand128.parts[1] = midh;\n        significand128.parts[2] = midl;\n        significand128.parts[3] = low;\n        if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {\n            is_zero = true;\n        } else {\n            for(k = 3; k >= 0; k--){\n                let least_digits = 0;\n                const result = divideu128(significand128);\n                significand128 = result.quotient;\n                least_digits = result.rem.low;\n                if (!least_digits) continue;\n                for(j = 8; j >= 0; j--){\n                    significand[k * 9 + j] = least_digits % 10;\n                    least_digits = Math.floor(least_digits / 10);\n                }\n            }\n        }\n        if (is_zero) {\n            significand_digits = 1;\n            significand[index] = 0;\n        } else {\n            significand_digits = 36;\n            while(!significand[index]){\n                significand_digits = significand_digits - 1;\n                index = index + 1;\n            }\n        }\n        const scientific_exponent = significand_digits - 1 + exponent;\n        if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {\n            if (significand_digits > 34) {\n                string.push(`${0}`);\n                if (exponent > 0) string.push(`E+${exponent}`);\n                else if (exponent < 0) string.push(`E${exponent}`);\n                return string.join(\"\");\n            }\n            string.push(`${significand[index++]}`);\n            significand_digits = significand_digits - 1;\n            if (significand_digits) {\n                string.push(\".\");\n            }\n            for(let i = 0; i < significand_digits; i++){\n                string.push(`${significand[index++]}`);\n            }\n            string.push(\"E\");\n            if (scientific_exponent > 0) {\n                string.push(`+${scientific_exponent}`);\n            } else {\n                string.push(`${scientific_exponent}`);\n            }\n        } else {\n            if (exponent >= 0) {\n                for(let i = 0; i < significand_digits; i++){\n                    string.push(`${significand[index++]}`);\n                }\n            } else {\n                let radix_position = significand_digits + exponent;\n                if (radix_position > 0) {\n                    for(let i = 0; i < radix_position; i++){\n                        string.push(`${significand[index++]}`);\n                    }\n                } else {\n                    string.push(\"0\");\n                }\n                string.push(\".\");\n                while(radix_position++ < 0){\n                    string.push(\"0\");\n                }\n                for(let i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++){\n                    string.push(`${significand[index++]}`);\n                }\n            }\n        }\n        return string.join(\"\");\n    }\n    toJSON() {\n        return {\n            $numberDecimal: this.toString()\n        };\n    }\n    toExtendedJSON() {\n        return {\n            $numberDecimal: this.toString()\n        };\n    }\n    static fromExtendedJSON(doc) {\n        return Decimal128.fromString(doc.$numberDecimal);\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new Decimal128(\"${this.toString()}\")`;\n    }\n}\nclass Double extends BSONValue {\n    get _bsontype() {\n        return \"Double\";\n    }\n    constructor(value){\n        super();\n        if (value instanceof Number) {\n            value = value.valueOf();\n        }\n        this.value = +value;\n    }\n    valueOf() {\n        return this.value;\n    }\n    toJSON() {\n        return this.value;\n    }\n    toString(radix) {\n        return this.value.toString(radix);\n    }\n    toExtendedJSON(options) {\n        if (options && (options.legacy || options.relaxed && isFinite(this.value))) {\n            return this.value;\n        }\n        if (Object.is(Math.sign(this.value), -0)) {\n            return {\n                $numberDouble: \"-0.0\"\n            };\n        }\n        return {\n            $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()\n        };\n    }\n    static fromExtendedJSON(doc, options) {\n        const doubleValue = parseFloat(doc.$numberDouble);\n        return options && options.relaxed ? doubleValue : new Double(doubleValue);\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return this.inspect();\n    }\n    inspect() {\n        const eJSON = this.toExtendedJSON();\n        return `new Double(${eJSON.$numberDouble})`;\n    }\n}\nclass Int32 extends BSONValue {\n    get _bsontype() {\n        return \"Int32\";\n    }\n    constructor(value){\n        super();\n        if (value instanceof Number) {\n            value = value.valueOf();\n        }\n        this.value = +value | 0;\n    }\n    valueOf() {\n        return this.value;\n    }\n    toString(radix) {\n        return this.value.toString(radix);\n    }\n    toJSON() {\n        return this.value;\n    }\n    toExtendedJSON(options) {\n        if (options && (options.relaxed || options.legacy)) return this.value;\n        return {\n            $numberInt: this.value.toString()\n        };\n    }\n    static fromExtendedJSON(doc, options) {\n        return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt);\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new Int32(${this.valueOf()})`;\n    }\n}\nclass MaxKey extends BSONValue {\n    get _bsontype() {\n        return \"MaxKey\";\n    }\n    toExtendedJSON() {\n        return {\n            $maxKey: 1\n        };\n    }\n    static fromExtendedJSON() {\n        return new MaxKey();\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return this.inspect();\n    }\n    inspect() {\n        return \"new MaxKey()\";\n    }\n}\nclass MinKey extends BSONValue {\n    get _bsontype() {\n        return \"MinKey\";\n    }\n    toExtendedJSON() {\n        return {\n            $minKey: 1\n        };\n    }\n    static fromExtendedJSON() {\n        return new MinKey();\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return this.inspect();\n    }\n    inspect() {\n        return \"new MinKey()\";\n    }\n}\nconst checkForHexRegExp = new RegExp(\"^[0-9a-fA-F]{24}$\");\nlet PROCESS_UNIQUE = null;\nconst kId = Symbol(\"id\");\nclass ObjectId extends BSONValue {\n    get _bsontype() {\n        return \"ObjectId\";\n    }\n    constructor(inputId){\n        super();\n        let workingId;\n        if (typeof inputId === \"object\" && inputId && \"id\" in inputId) {\n            if (typeof inputId.id !== \"string\" && !ArrayBuffer.isView(inputId.id)) {\n                throw new BSONError(\"Argument passed in must have an id that is of type string or Buffer\");\n            }\n            if (\"toHexString\" in inputId && typeof inputId.toHexString === \"function\") {\n                workingId = ByteUtils.fromHex(inputId.toHexString());\n            } else {\n                workingId = inputId.id;\n            }\n        } else {\n            workingId = inputId;\n        }\n        if (workingId == null || typeof workingId === \"number\") {\n            this[kId] = ObjectId.generate(typeof workingId === \"number\" ? workingId : undefined);\n        } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {\n            this[kId] = ByteUtils.toLocalBufferType(workingId);\n        } else if (typeof workingId === \"string\") {\n            if (workingId.length === 12) {\n                const bytes = ByteUtils.fromUTF8(workingId);\n                if (bytes.byteLength === 12) {\n                    this[kId] = bytes;\n                } else {\n                    throw new BSONError(\"Argument passed in must be a string of 12 bytes\");\n                }\n            } else if (workingId.length === 24 && checkForHexRegExp.test(workingId)) {\n                this[kId] = ByteUtils.fromHex(workingId);\n            } else {\n                throw new BSONError(\"Argument passed in must be a string of 12 bytes or a string of 24 hex characters or an integer\");\n            }\n        } else {\n            throw new BSONError(\"Argument passed in does not match the accepted types\");\n        }\n        if (ObjectId.cacheHexString) {\n            this.__id = ByteUtils.toHex(this.id);\n        }\n    }\n    get id() {\n        return this[kId];\n    }\n    set id(value) {\n        this[kId] = value;\n        if (ObjectId.cacheHexString) {\n            this.__id = ByteUtils.toHex(value);\n        }\n    }\n    toHexString() {\n        if (ObjectId.cacheHexString && this.__id) {\n            return this.__id;\n        }\n        const hexString = ByteUtils.toHex(this.id);\n        if (ObjectId.cacheHexString && !this.__id) {\n            this.__id = hexString;\n        }\n        return hexString;\n    }\n    static getInc() {\n        return ObjectId.index = (ObjectId.index + 1) % 0xffffff;\n    }\n    static generate(time) {\n        if (\"number\" !== typeof time) {\n            time = Math.floor(Date.now() / 1000);\n        }\n        const inc = ObjectId.getInc();\n        const buffer = ByteUtils.allocate(12);\n        BSONDataView.fromUint8Array(buffer).setUint32(0, time, false);\n        if (PROCESS_UNIQUE === null) {\n            PROCESS_UNIQUE = ByteUtils.randomBytes(5);\n        }\n        buffer[4] = PROCESS_UNIQUE[0];\n        buffer[5] = PROCESS_UNIQUE[1];\n        buffer[6] = PROCESS_UNIQUE[2];\n        buffer[7] = PROCESS_UNIQUE[3];\n        buffer[8] = PROCESS_UNIQUE[4];\n        buffer[11] = inc & 0xff;\n        buffer[10] = inc >> 8 & 0xff;\n        buffer[9] = inc >> 16 & 0xff;\n        return buffer;\n    }\n    toString(encoding) {\n        if (encoding === \"base64\") return ByteUtils.toBase64(this.id);\n        if (encoding === \"hex\") return this.toHexString();\n        return this.toHexString();\n    }\n    toJSON() {\n        return this.toHexString();\n    }\n    equals(otherId) {\n        if (otherId === undefined || otherId === null) {\n            return false;\n        }\n        if (otherId instanceof ObjectId) {\n            return this[kId][11] === otherId[kId][11] && ByteUtils.equals(this[kId], otherId[kId]);\n        }\n        if (typeof otherId === \"string\" && ObjectId.isValid(otherId) && otherId.length === 12 && isUint8Array(this.id)) {\n            return ByteUtils.equals(this.id, ByteUtils.fromISO88591(otherId));\n        }\n        if (typeof otherId === \"string\" && ObjectId.isValid(otherId) && otherId.length === 24) {\n            return otherId.toLowerCase() === this.toHexString();\n        }\n        if (typeof otherId === \"string\" && ObjectId.isValid(otherId) && otherId.length === 12) {\n            return ByteUtils.equals(ByteUtils.fromUTF8(otherId), this.id);\n        }\n        if (typeof otherId === \"object\" && \"toHexString\" in otherId && typeof otherId.toHexString === \"function\") {\n            const otherIdString = otherId.toHexString();\n            const thisIdString = this.toHexString().toLowerCase();\n            return typeof otherIdString === \"string\" && otherIdString.toLowerCase() === thisIdString;\n        }\n        return false;\n    }\n    getTimestamp() {\n        const timestamp = new Date();\n        const time = BSONDataView.fromUint8Array(this.id).getUint32(0, false);\n        timestamp.setTime(Math.floor(time) * 1000);\n        return timestamp;\n    }\n    static createPk() {\n        return new ObjectId();\n    }\n    static createFromTime(time) {\n        const buffer = ByteUtils.fromNumberArray([\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n        ]);\n        BSONDataView.fromUint8Array(buffer).setUint32(0, time, false);\n        return new ObjectId(buffer);\n    }\n    static createFromHexString(hexString) {\n        if (hexString?.length !== 24) {\n            throw new BSONError(\"hex string must be 24 characters\");\n        }\n        return new ObjectId(ByteUtils.fromHex(hexString));\n    }\n    static createFromBase64(base64) {\n        if (base64?.length !== 16) {\n            throw new BSONError(\"base64 string must be 16 characters\");\n        }\n        return new ObjectId(ByteUtils.fromBase64(base64));\n    }\n    static isValid(id) {\n        if (id == null) return false;\n        try {\n            new ObjectId(id);\n            return true;\n        } catch  {\n            return false;\n        }\n    }\n    toExtendedJSON() {\n        if (this.toHexString) return {\n            $oid: this.toHexString()\n        };\n        return {\n            $oid: this.toString(\"hex\")\n        };\n    }\n    static fromExtendedJSON(doc) {\n        return new ObjectId(doc.$oid);\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new ObjectId(\"${this.toHexString()}\")`;\n    }\n}\nObjectId.index = Math.floor(Math.random() * 0xffffff);\nfunction internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) {\n    let totalLength = 4 + 1;\n    if (Array.isArray(object)) {\n        for(let i = 0; i < object.length; i++){\n            totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);\n        }\n    } else {\n        if (typeof object?.toBSON === \"function\") {\n            object = object.toBSON();\n        }\n        for (const key of Object.keys(object)){\n            totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);\n        }\n    }\n    return totalLength;\n}\nfunction calculateElement(name, value, serializeFunctions = false, isArray = false, ignoreUndefined = false) {\n    if (typeof value?.toBSON === \"function\") {\n        value = value.toBSON();\n    }\n    switch(typeof value){\n        case \"string\":\n            return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;\n        case \"number\":\n            if (Math.floor(value) === value && value >= JS_INT_MIN && value <= JS_INT_MAX) {\n                if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);\n                } else {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n                }\n            } else {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            }\n        case \"undefined\":\n            if (isArray || !ignoreUndefined) return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;\n            return 0;\n        case \"boolean\":\n            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);\n        case \"object\":\n            if (value != null && typeof value._bsontype === \"string\" && value[Symbol.for(\"@@mdb.bson.version\")] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            } else if (value == null || value._bsontype === \"MinKey\" || value._bsontype === \"MaxKey\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;\n            } else if (value._bsontype === \"ObjectId\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);\n            } else if (value instanceof Date || isDate(value)) {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || isAnyArrayBuffer(value)) {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength;\n            } else if (value._bsontype === \"Long\" || value._bsontype === \"Double\" || value._bsontype === \"Timestamp\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            } else if (value._bsontype === \"Decimal128\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);\n            } else if (value._bsontype === \"Code\") {\n                if (value.scope != null && Object.keys(value.scope).length > 0) {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1 + internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);\n                } else {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1;\n                }\n            } else if (value._bsontype === \"Binary\") {\n                const binary = value;\n                if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);\n                } else {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1);\n                }\n            } else if (value._bsontype === \"Symbol\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + ByteUtils.utf8ByteLength(value.value) + 4 + 1 + 1;\n            } else if (value._bsontype === \"DBRef\") {\n                const ordered_values = Object.assign({\n                    $ref: value.collection,\n                    $id: value.oid\n                }, value.fields);\n                if (value.db != null) {\n                    ordered_values[\"$db\"] = value.db;\n                }\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);\n            } else if (value instanceof RegExp || isRegExp(value)) {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.source) + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;\n            } else if (value._bsontype === \"BSONRegExp\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.pattern) + 1 + ByteUtils.utf8ByteLength(value.options) + 1;\n            } else {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;\n            }\n        case \"function\":\n            if (serializeFunctions) {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.toString()) + 1;\n            }\n    }\n    return 0;\n}\nfunction alphabetize(str) {\n    return str.split(\"\").sort().join(\"\");\n}\nclass BSONRegExp extends BSONValue {\n    get _bsontype() {\n        return \"BSONRegExp\";\n    }\n    constructor(pattern, options){\n        super();\n        this.pattern = pattern;\n        this.options = alphabetize(options ?? \"\");\n        if (this.pattern.indexOf(\"\\x00\") !== -1) {\n            throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);\n        }\n        if (this.options.indexOf(\"\\x00\") !== -1) {\n            throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);\n        }\n        for(let i = 0; i < this.options.length; i++){\n            if (!(this.options[i] === \"i\" || this.options[i] === \"m\" || this.options[i] === \"x\" || this.options[i] === \"l\" || this.options[i] === \"s\" || this.options[i] === \"u\")) {\n                throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`);\n            }\n        }\n    }\n    static parseOptions(options) {\n        return options ? options.split(\"\").sort().join(\"\") : \"\";\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        if (options.legacy) {\n            return {\n                $regex: this.pattern,\n                $options: this.options\n            };\n        }\n        return {\n            $regularExpression: {\n                pattern: this.pattern,\n                options: this.options\n            }\n        };\n    }\n    static fromExtendedJSON(doc) {\n        if (\"$regex\" in doc) {\n            if (typeof doc.$regex !== \"string\") {\n                if (doc.$regex._bsontype === \"BSONRegExp\") {\n                    return doc;\n                }\n            } else {\n                return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options));\n            }\n        }\n        if (\"$regularExpression\" in doc) {\n            return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options));\n        }\n        throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new BSONRegExp(${JSON.stringify(this.pattern)}, ${JSON.stringify(this.options)})`;\n    }\n}\nclass BSONSymbol extends BSONValue {\n    get _bsontype() {\n        return \"BSONSymbol\";\n    }\n    constructor(value){\n        super();\n        this.value = value;\n    }\n    valueOf() {\n        return this.value;\n    }\n    toString() {\n        return this.value;\n    }\n    inspect() {\n        return `new BSONSymbol(\"${this.value}\")`;\n    }\n    toJSON() {\n        return this.value;\n    }\n    toExtendedJSON() {\n        return {\n            $symbol: this.value\n        };\n    }\n    static fromExtendedJSON(doc) {\n        return new BSONSymbol(doc.$symbol);\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return this.inspect();\n    }\n}\nconst LongWithoutOverridesClass = Long;\nclass Timestamp extends LongWithoutOverridesClass {\n    get _bsontype() {\n        return \"Timestamp\";\n    }\n    constructor(low){\n        if (low == null) {\n            super(0, 0, true);\n        } else if (typeof low === \"bigint\") {\n            super(low, true);\n        } else if (Long.isLong(low)) {\n            super(low.low, low.high, true);\n        } else if (typeof low === \"object\" && \"t\" in low && \"i\" in low) {\n            if (typeof low.t !== \"number\" && (typeof low.t !== \"object\" || low.t._bsontype !== \"Int32\")) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide t as a number\");\n            }\n            if (typeof low.i !== \"number\" && (typeof low.i !== \"object\" || low.i._bsontype !== \"Int32\")) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide i as a number\");\n            }\n            const t = Number(low.t);\n            const i = Number(low.i);\n            if (t < 0 || Number.isNaN(t)) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide a positive t\");\n            }\n            if (i < 0 || Number.isNaN(i)) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide a positive i\");\n            }\n            if (t > 4294967295) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide t equal or less than uint32 max\");\n            }\n            if (i > 4294967295) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide i equal or less than uint32 max\");\n            }\n            super(i, t, true);\n        } else {\n            throw new BSONError(\"A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }\");\n        }\n    }\n    toJSON() {\n        return {\n            $timestamp: this.toString()\n        };\n    }\n    static fromInt(value) {\n        return new Timestamp(Long.fromInt(value, true));\n    }\n    static fromNumber(value) {\n        return new Timestamp(Long.fromNumber(value, true));\n    }\n    static fromBits(lowBits, highBits) {\n        return new Timestamp({\n            i: lowBits,\n            t: highBits\n        });\n    }\n    static fromString(str, optRadix) {\n        return new Timestamp(Long.fromString(str, true, optRadix));\n    }\n    toExtendedJSON() {\n        return {\n            $timestamp: {\n                t: this.high >>> 0,\n                i: this.low >>> 0\n            }\n        };\n    }\n    static fromExtendedJSON(doc) {\n        const i = Long.isLong(doc.$timestamp.i) ? doc.$timestamp.i.getLowBitsUnsigned() : doc.$timestamp.i;\n        const t = Long.isLong(doc.$timestamp.t) ? doc.$timestamp.t.getLowBitsUnsigned() : doc.$timestamp.t;\n        return new Timestamp({\n            t,\n            i\n        });\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new Timestamp({ t: ${this.getHighBits()}, i: ${this.getLowBits()} })`;\n    }\n}\nTimestamp.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;\nconst FIRST_BIT = 0x80;\nconst FIRST_TWO_BITS = 0xc0;\nconst FIRST_THREE_BITS = 0xe0;\nconst FIRST_FOUR_BITS = 0xf0;\nconst FIRST_FIVE_BITS = 0xf8;\nconst TWO_BIT_CHAR = 0xc0;\nconst THREE_BIT_CHAR = 0xe0;\nconst FOUR_BIT_CHAR = 0xf0;\nconst CONTINUING_CHAR = 0x80;\nfunction validateUtf8(bytes, start, end) {\n    let continuation = 0;\n    for(let i = start; i < end; i += 1){\n        const byte = bytes[i];\n        if (continuation) {\n            if ((byte & FIRST_TWO_BITS) !== CONTINUING_CHAR) {\n                return false;\n            }\n            continuation -= 1;\n        } else if (byte & FIRST_BIT) {\n            if ((byte & FIRST_THREE_BITS) === TWO_BIT_CHAR) {\n                continuation = 1;\n            } else if ((byte & FIRST_FOUR_BITS) === THREE_BIT_CHAR) {\n                continuation = 2;\n            } else if ((byte & FIRST_FIVE_BITS) === FOUR_BIT_CHAR) {\n                continuation = 3;\n            } else {\n                return false;\n            }\n        }\n    }\n    return !continuation;\n}\nconst JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);\nconst JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);\nfunction internalDeserialize(buffer, options, isArray) {\n    options = options == null ? {} : options;\n    const index = options && options.index ? options.index : 0;\n    const size = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n    if (size < 5) {\n        throw new BSONError(`bson size must be >= 5, is ${size}`);\n    }\n    if (options.allowObjectSmallerThanBufferSize && buffer.length < size) {\n        throw new BSONError(`buffer length ${buffer.length} must be >= bson size ${size}`);\n    }\n    if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) {\n        throw new BSONError(`buffer length ${buffer.length} must === bson size ${size}`);\n    }\n    if (size + index > buffer.byteLength) {\n        throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer.byteLength})`);\n    }\n    if (buffer[index + size - 1] !== 0) {\n        throw new BSONError(\"One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00\");\n    }\n    return deserializeObject(buffer, index, options, isArray);\n}\nconst allowedDBRefKeys = /^\\$ref$|^\\$id$|^\\$db$/;\nfunction deserializeObject(buffer, index, options, isArray = false) {\n    const fieldsAsRaw = options[\"fieldsAsRaw\"] == null ? null : options[\"fieldsAsRaw\"];\n    const raw = options[\"raw\"] == null ? false : options[\"raw\"];\n    const bsonRegExp = typeof options[\"bsonRegExp\"] === \"boolean\" ? options[\"bsonRegExp\"] : false;\n    const promoteBuffers = options.promoteBuffers ?? false;\n    const promoteLongs = options.promoteLongs ?? true;\n    const promoteValues = options.promoteValues ?? true;\n    const useBigInt64 = options.useBigInt64 ?? false;\n    if (useBigInt64 && !promoteValues) {\n        throw new BSONError(\"Must either request bigint or Long for int64 deserialization\");\n    }\n    if (useBigInt64 && !promoteLongs) {\n        throw new BSONError(\"Must either request bigint or Long for int64 deserialization\");\n    }\n    const validation = options.validation == null ? {\n        utf8: true\n    } : options.validation;\n    let globalUTFValidation = true;\n    let validationSetting;\n    const utf8KeysSet = new Set();\n    const utf8ValidatedKeys = validation.utf8;\n    if (typeof utf8ValidatedKeys === \"boolean\") {\n        validationSetting = utf8ValidatedKeys;\n    } else {\n        globalUTFValidation = false;\n        const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function(key) {\n            return utf8ValidatedKeys[key];\n        });\n        if (utf8ValidationValues.length === 0) {\n            throw new BSONError(\"UTF-8 validation setting cannot be empty\");\n        }\n        if (typeof utf8ValidationValues[0] !== \"boolean\") {\n            throw new BSONError(\"Invalid UTF-8 validation option, must specify boolean values\");\n        }\n        validationSetting = utf8ValidationValues[0];\n        if (!utf8ValidationValues.every((item)=>item === validationSetting)) {\n            throw new BSONError(\"Invalid UTF-8 validation option - keys must be all true or all false\");\n        }\n    }\n    if (!globalUTFValidation) {\n        for (const key of Object.keys(utf8ValidatedKeys)){\n            utf8KeysSet.add(key);\n        }\n    }\n    const startIndex = index;\n    if (buffer.length < 5) throw new BSONError(\"corrupt bson message < 5 bytes long\");\n    const size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n    if (size < 5 || size > buffer.length) throw new BSONError(\"corrupt bson message\");\n    const object = isArray ? [] : {};\n    let arrayIndex = 0;\n    const done = false;\n    let isPossibleDBRef = isArray ? false : null;\n    const dataview = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    while(!done){\n        const elementType = buffer[index++];\n        if (elementType === 0) break;\n        let i = index;\n        while(buffer[i] !== 0x00 && i < buffer.length){\n            i++;\n        }\n        if (i >= buffer.byteLength) throw new BSONError(\"Bad BSON Document: illegal CString\");\n        const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer, index, i);\n        let shouldValidateKey = true;\n        if (globalUTFValidation || utf8KeysSet.has(name)) {\n            shouldValidateKey = validationSetting;\n        } else {\n            shouldValidateKey = !validationSetting;\n        }\n        if (isPossibleDBRef !== false && name[0] === \"$\") {\n            isPossibleDBRef = allowedDBRefKeys.test(name);\n        }\n        let value;\n        index = i + 1;\n        if (elementType === BSON_DATA_STRING) {\n            const stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError(\"bad string length in bson\");\n            }\n            value = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n            index = index + stringSize;\n        } else if (elementType === BSON_DATA_OID) {\n            const oid = ByteUtils.allocate(12);\n            oid.set(buffer.subarray(index, index + 12));\n            value = new ObjectId(oid);\n            index = index + 12;\n        } else if (elementType === BSON_DATA_INT && promoteValues === false) {\n            value = new Int32(buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24);\n        } else if (elementType === BSON_DATA_INT) {\n            value = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n        } else if (elementType === BSON_DATA_NUMBER && promoteValues === false) {\n            value = new Double(dataview.getFloat64(index, true));\n            index = index + 8;\n        } else if (elementType === BSON_DATA_NUMBER) {\n            value = dataview.getFloat64(index, true);\n            index = index + 8;\n        } else if (elementType === BSON_DATA_DATE) {\n            const lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            const highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            value = new Date(new Long(lowBits, highBits).toNumber());\n        } else if (elementType === BSON_DATA_BOOLEAN) {\n            if (buffer[index] !== 0 && buffer[index] !== 1) throw new BSONError(\"illegal boolean type value\");\n            value = buffer[index++] === 1;\n        } else if (elementType === BSON_DATA_OBJECT) {\n            const _index = index;\n            const objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n            if (objectSize <= 0 || objectSize > buffer.length - index) throw new BSONError(\"bad embedded document length in bson\");\n            if (raw) {\n                value = buffer.slice(index, index + objectSize);\n            } else {\n                let objectOptions = options;\n                if (!globalUTFValidation) {\n                    objectOptions = {\n                        ...options,\n                        validation: {\n                            utf8: shouldValidateKey\n                        }\n                    };\n                }\n                value = deserializeObject(buffer, _index, objectOptions, false);\n            }\n            index = index + objectSize;\n        } else if (elementType === BSON_DATA_ARRAY) {\n            const _index = index;\n            const objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n            let arrayOptions = options;\n            const stopIndex = index + objectSize;\n            if (fieldsAsRaw && fieldsAsRaw[name]) {\n                arrayOptions = {\n                    ...options,\n                    raw: true\n                };\n            }\n            if (!globalUTFValidation) {\n                arrayOptions = {\n                    ...arrayOptions,\n                    validation: {\n                        utf8: shouldValidateKey\n                    }\n                };\n            }\n            value = deserializeObject(buffer, _index, arrayOptions, true);\n            index = index + objectSize;\n            if (buffer[index - 1] !== 0) throw new BSONError(\"invalid array terminator byte\");\n            if (index !== stopIndex) throw new BSONError(\"corrupted array bson\");\n        } else if (elementType === BSON_DATA_UNDEFINED) {\n            value = undefined;\n        } else if (elementType === BSON_DATA_NULL) {\n            value = null;\n        } else if (elementType === BSON_DATA_LONG) {\n            const dataview = BSONDataView.fromUint8Array(buffer.subarray(index, index + 8));\n            const lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            const highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            const long = new Long(lowBits, highBits);\n            if (useBigInt64) {\n                value = dataview.getBigInt64(0, true);\n            } else if (promoteLongs && promoteValues === true) {\n                value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;\n            } else {\n                value = long;\n            }\n        } else if (elementType === BSON_DATA_DECIMAL128) {\n            const bytes = ByteUtils.allocate(16);\n            bytes.set(buffer.subarray(index, index + 16), 0);\n            index = index + 16;\n            value = new Decimal128(bytes);\n        } else if (elementType === BSON_DATA_BINARY) {\n            let binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            const totalBinarySize = binarySize;\n            const subType = buffer[index++];\n            if (binarySize < 0) throw new BSONError(\"Negative binary type element size found\");\n            if (binarySize > buffer.byteLength) throw new BSONError(\"Binary type size larger than document size\");\n            if (buffer[\"slice\"] != null) {\n                if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n                    binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n                    if (binarySize < 0) throw new BSONError(\"Negative binary type element size found for subtype 0x02\");\n                    if (binarySize > totalBinarySize - 4) throw new BSONError(\"Binary type with subtype 0x02 contains too long binary size\");\n                    if (binarySize < totalBinarySize - 4) throw new BSONError(\"Binary type with subtype 0x02 contains too short binary size\");\n                }\n                if (promoteBuffers && promoteValues) {\n                    value = ByteUtils.toLocalBufferType(buffer.slice(index, index + binarySize));\n                } else {\n                    value = new Binary(buffer.slice(index, index + binarySize), subType);\n                    if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {\n                        value = value.toUUID();\n                    }\n                }\n            } else {\n                const _buffer = ByteUtils.allocate(binarySize);\n                if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n                    binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n                    if (binarySize < 0) throw new BSONError(\"Negative binary type element size found for subtype 0x02\");\n                    if (binarySize > totalBinarySize - 4) throw new BSONError(\"Binary type with subtype 0x02 contains too long binary size\");\n                    if (binarySize < totalBinarySize - 4) throw new BSONError(\"Binary type with subtype 0x02 contains too short binary size\");\n                }\n                for(i = 0; i < binarySize; i++){\n                    _buffer[i] = buffer[index + i];\n                }\n                if (promoteBuffers && promoteValues) {\n                    value = _buffer;\n                } else {\n                    value = new Binary(buffer.slice(index, index + binarySize), subType);\n                    if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {\n                        value = value.toUUID();\n                    }\n                }\n            }\n            index = index + binarySize;\n        } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {\n            i = index;\n            while(buffer[i] !== 0x00 && i < buffer.length){\n                i++;\n            }\n            if (i >= buffer.length) throw new BSONError(\"Bad BSON Document: illegal CString\");\n            const source = ByteUtils.toUTF8(buffer, index, i);\n            index = i + 1;\n            i = index;\n            while(buffer[i] !== 0x00 && i < buffer.length){\n                i++;\n            }\n            if (i >= buffer.length) throw new BSONError(\"Bad BSON Document: illegal CString\");\n            const regExpOptions = ByteUtils.toUTF8(buffer, index, i);\n            index = i + 1;\n            const optionsArray = new Array(regExpOptions.length);\n            for(i = 0; i < regExpOptions.length; i++){\n                switch(regExpOptions[i]){\n                    case \"m\":\n                        optionsArray[i] = \"m\";\n                        break;\n                    case \"s\":\n                        optionsArray[i] = \"g\";\n                        break;\n                    case \"i\":\n                        optionsArray[i] = \"i\";\n                        break;\n                }\n            }\n            value = new RegExp(source, optionsArray.join(\"\"));\n        } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {\n            i = index;\n            while(buffer[i] !== 0x00 && i < buffer.length){\n                i++;\n            }\n            if (i >= buffer.length) throw new BSONError(\"Bad BSON Document: illegal CString\");\n            const source = ByteUtils.toUTF8(buffer, index, i);\n            index = i + 1;\n            i = index;\n            while(buffer[i] !== 0x00 && i < buffer.length){\n                i++;\n            }\n            if (i >= buffer.length) throw new BSONError(\"Bad BSON Document: illegal CString\");\n            const regExpOptions = ByteUtils.toUTF8(buffer, index, i);\n            index = i + 1;\n            value = new BSONRegExp(source, regExpOptions);\n        } else if (elementType === BSON_DATA_SYMBOL) {\n            const stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError(\"bad string length in bson\");\n            }\n            const symbol = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n            value = promoteValues ? symbol : new BSONSymbol(symbol);\n            index = index + stringSize;\n        } else if (elementType === BSON_DATA_TIMESTAMP) {\n            const i = buffer[index++] + buffer[index++] * (1 << 8) + buffer[index++] * (1 << 16) + buffer[index++] * (1 << 24);\n            const t = buffer[index++] + buffer[index++] * (1 << 8) + buffer[index++] * (1 << 16) + buffer[index++] * (1 << 24);\n            value = new Timestamp({\n                i,\n                t\n            });\n        } else if (elementType === BSON_DATA_MIN_KEY) {\n            value = new MinKey();\n        } else if (elementType === BSON_DATA_MAX_KEY) {\n            value = new MaxKey();\n        } else if (elementType === BSON_DATA_CODE) {\n            const stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError(\"bad string length in bson\");\n            }\n            const functionString = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n            value = new Code(functionString);\n            index = index + stringSize;\n        } else if (elementType === BSON_DATA_CODE_W_SCOPE) {\n            const totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            if (totalSize < 4 + 4 + 4 + 1) {\n                throw new BSONError(\"code_w_scope total size shorter minimum expected length\");\n            }\n            const stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError(\"bad string length in bson\");\n            }\n            const functionString = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n            index = index + stringSize;\n            const _index = index;\n            const objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n            const scopeObject = deserializeObject(buffer, _index, options, false);\n            index = index + objectSize;\n            if (totalSize < 4 + 4 + objectSize + stringSize) {\n                throw new BSONError(\"code_w_scope total size is too short, truncating scope\");\n            }\n            if (totalSize > 4 + 4 + objectSize + stringSize) {\n                throw new BSONError(\"code_w_scope total size is too long, clips outer document\");\n            }\n            value = new Code(functionString, scopeObject);\n        } else if (elementType === BSON_DATA_DBPOINTER) {\n            const stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new BSONError(\"bad string length in bson\");\n            if (validation != null && validation.utf8) {\n                if (!validateUtf8(buffer, index, index + stringSize - 1)) {\n                    throw new BSONError(\"Invalid UTF-8 string in BSON document\");\n                }\n            }\n            const namespace = ByteUtils.toUTF8(buffer, index, index + stringSize - 1);\n            index = index + stringSize;\n            const oidBuffer = ByteUtils.allocate(12);\n            oidBuffer.set(buffer.subarray(index, index + 12), 0);\n            const oid = new ObjectId(oidBuffer);\n            index = index + 12;\n            value = new DBRef(namespace, oid);\n        } else {\n            throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname \"${name}\"`);\n        }\n        if (name === \"__proto__\") {\n            Object.defineProperty(object, name, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        } else {\n            object[name] = value;\n        }\n    }\n    if (size !== index - startIndex) {\n        if (isArray) throw new BSONError(\"corrupt array bson\");\n        throw new BSONError(\"corrupt object bson\");\n    }\n    if (!isPossibleDBRef) return object;\n    if (isDBRefLike(object)) {\n        const copy = Object.assign({}, object);\n        delete copy.$ref;\n        delete copy.$id;\n        delete copy.$db;\n        return new DBRef(object.$ref, object.$id, object.$db, copy);\n    }\n    return object;\n}\nfunction getValidatedString(buffer, start, end, shouldValidateUtf8) {\n    const value = ByteUtils.toUTF8(buffer, start, end);\n    if (shouldValidateUtf8) {\n        for(let i = 0; i < value.length; i++){\n            if (value.charCodeAt(i) === 0xfffd) {\n                if (!validateUtf8(buffer, start, end)) {\n                    throw new BSONError(\"Invalid UTF-8 string in BSON document\");\n                }\n                break;\n            }\n        }\n    }\n    return value;\n}\nconst regexp = /\\x00/;\nconst ignoreKeys = new Set([\n    \"$db\",\n    \"$ref\",\n    \"$id\",\n    \"$clusterTime\"\n]);\nfunction serializeString(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_STRING;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes + 1;\n    buffer[index - 1] = 0;\n    const size = ByteUtils.encodeUTF8Into(buffer, value, index + 4);\n    buffer[index + 3] = size + 1 >> 24 & 0xff;\n    buffer[index + 2] = size + 1 >> 16 & 0xff;\n    buffer[index + 1] = size + 1 >> 8 & 0xff;\n    buffer[index] = size + 1 & 0xff;\n    index = index + 4 + size;\n    buffer[index++] = 0;\n    return index;\n}\nconst NUMBER_SPACE = new DataView(new ArrayBuffer(8), 0, 8);\nconst FOUR_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 4);\nconst EIGHT_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 8);\nfunction serializeNumber(buffer, key, value, index) {\n    const isNegativeZero = Object.is(value, -0);\n    const type = !isNegativeZero && Number.isSafeInteger(value) && value <= BSON_INT32_MAX && value >= BSON_INT32_MIN ? BSON_DATA_INT : BSON_DATA_NUMBER;\n    if (type === BSON_DATA_INT) {\n        NUMBER_SPACE.setInt32(0, value, true);\n    } else {\n        NUMBER_SPACE.setFloat64(0, value, true);\n    }\n    const bytes = type === BSON_DATA_INT ? FOUR_BYTE_VIEW_ON_NUMBER : EIGHT_BYTE_VIEW_ON_NUMBER;\n    buffer[index++] = type;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0x00;\n    buffer.set(bytes, index);\n    index += bytes.byteLength;\n    return index;\n}\nfunction serializeBigInt(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_LONG;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index += numberOfWrittenBytes;\n    buffer[index++] = 0;\n    NUMBER_SPACE.setBigInt64(0, value, true);\n    buffer.set(EIGHT_BYTE_VIEW_ON_NUMBER, index);\n    index += EIGHT_BYTE_VIEW_ON_NUMBER.byteLength;\n    return index;\n}\nfunction serializeNull(buffer, key, _, index) {\n    buffer[index++] = BSON_DATA_NULL;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeBoolean(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BOOLEAN;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    buffer[index++] = value ? 1 : 0;\n    return index;\n}\nfunction serializeDate(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_DATE;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const dateInMilis = Long.fromNumber(value.getTime());\n    const lowBits = dateInMilis.getLowBits();\n    const highBits = dateInMilis.getHighBits();\n    buffer[index++] = lowBits & 0xff;\n    buffer[index++] = lowBits >> 8 & 0xff;\n    buffer[index++] = lowBits >> 16 & 0xff;\n    buffer[index++] = lowBits >> 24 & 0xff;\n    buffer[index++] = highBits & 0xff;\n    buffer[index++] = highBits >> 8 & 0xff;\n    buffer[index++] = highBits >> 16 & 0xff;\n    buffer[index++] = highBits >> 24 & 0xff;\n    return index;\n}\nfunction serializeRegExp(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_REGEXP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    if (value.source && value.source.match(regexp) != null) {\n        throw new BSONError(\"value \" + value.source + \" must not contain null bytes\");\n    }\n    index = index + ByteUtils.encodeUTF8Into(buffer, value.source, index);\n    buffer[index++] = 0x00;\n    if (value.ignoreCase) buffer[index++] = 0x69;\n    if (value.global) buffer[index++] = 0x73;\n    if (value.multiline) buffer[index++] = 0x6d;\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeBSONRegExp(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_REGEXP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    if (value.pattern.match(regexp) != null) {\n        throw new BSONError(\"pattern \" + value.pattern + \" must not contain null bytes\");\n    }\n    index = index + ByteUtils.encodeUTF8Into(buffer, value.pattern, index);\n    buffer[index++] = 0x00;\n    const sortedOptions = value.options.split(\"\").sort().join(\"\");\n    index = index + ByteUtils.encodeUTF8Into(buffer, sortedOptions, index);\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeMinMax(buffer, key, value, index) {\n    if (value === null) {\n        buffer[index++] = BSON_DATA_NULL;\n    } else if (value._bsontype === \"MinKey\") {\n        buffer[index++] = BSON_DATA_MIN_KEY;\n    } else {\n        buffer[index++] = BSON_DATA_MAX_KEY;\n    }\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeObjectId(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_OID;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    if (isUint8Array(value.id)) {\n        buffer.set(value.id.subarray(0, 12), index);\n    } else {\n        throw new BSONError(\"object [\" + JSON.stringify(value) + \"] is not a valid ObjectId\");\n    }\n    return index + 12;\n}\nfunction serializeBuffer(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BINARY;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const size = value.length;\n    buffer[index++] = size & 0xff;\n    buffer[index++] = size >> 8 & 0xff;\n    buffer[index++] = size >> 16 & 0xff;\n    buffer[index++] = size >> 24 & 0xff;\n    buffer[index++] = BSON_BINARY_SUBTYPE_DEFAULT;\n    buffer.set(value, index);\n    index = index + size;\n    return index;\n}\nfunction serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) {\n    if (path.has(value)) {\n        throw new BSONError(\"Cannot convert circular structure to BSON\");\n    }\n    path.add(value);\n    buffer[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n    path.delete(value);\n    return endIndex;\n}\nfunction serializeDecimal128(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_DECIMAL128;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    buffer.set(value.bytes.subarray(0, 16), index);\n    return index + 16;\n}\nfunction serializeLong(buffer, key, value, index) {\n    buffer[index++] = value._bsontype === \"Long\" ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const lowBits = value.getLowBits();\n    const highBits = value.getHighBits();\n    buffer[index++] = lowBits & 0xff;\n    buffer[index++] = lowBits >> 8 & 0xff;\n    buffer[index++] = lowBits >> 16 & 0xff;\n    buffer[index++] = lowBits >> 24 & 0xff;\n    buffer[index++] = highBits & 0xff;\n    buffer[index++] = highBits >> 8 & 0xff;\n    buffer[index++] = highBits >> 16 & 0xff;\n    buffer[index++] = highBits >> 24 & 0xff;\n    return index;\n}\nfunction serializeInt32(buffer, key, value, index) {\n    value = value.valueOf();\n    buffer[index++] = BSON_DATA_INT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    buffer[index++] = value & 0xff;\n    buffer[index++] = value >> 8 & 0xff;\n    buffer[index++] = value >> 16 & 0xff;\n    buffer[index++] = value >> 24 & 0xff;\n    return index;\n}\nfunction serializeDouble(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_NUMBER;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    NUMBER_SPACE.setFloat64(0, value.value, true);\n    buffer.set(EIGHT_BYTE_VIEW_ON_NUMBER, index);\n    index = index + 8;\n    return index;\n}\nfunction serializeFunction(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_CODE;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const functionString = value.toString();\n    const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n    buffer[index] = size & 0xff;\n    buffer[index + 1] = size >> 8 & 0xff;\n    buffer[index + 2] = size >> 16 & 0xff;\n    buffer[index + 3] = size >> 24 & 0xff;\n    index = index + 4 + size - 1;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeCode(buffer, key, value, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path) {\n    if (value.scope && typeof value.scope === \"object\") {\n        buffer[index++] = BSON_DATA_CODE_W_SCOPE;\n        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n        index = index + numberOfWrittenBytes;\n        buffer[index++] = 0;\n        let startIndex = index;\n        const functionString = value.code;\n        index = index + 4;\n        const codeSize = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n        buffer[index] = codeSize & 0xff;\n        buffer[index + 1] = codeSize >> 8 & 0xff;\n        buffer[index + 2] = codeSize >> 16 & 0xff;\n        buffer[index + 3] = codeSize >> 24 & 0xff;\n        buffer[index + 4 + codeSize - 1] = 0;\n        index = index + codeSize + 4;\n        const endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n        index = endIndex - 1;\n        const totalSize = endIndex - startIndex;\n        buffer[startIndex++] = totalSize & 0xff;\n        buffer[startIndex++] = totalSize >> 8 & 0xff;\n        buffer[startIndex++] = totalSize >> 16 & 0xff;\n        buffer[startIndex++] = totalSize >> 24 & 0xff;\n        buffer[index++] = 0;\n    } else {\n        buffer[index++] = BSON_DATA_CODE;\n        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n        index = index + numberOfWrittenBytes;\n        buffer[index++] = 0;\n        const functionString = value.code.toString();\n        const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n        buffer[index] = size & 0xff;\n        buffer[index + 1] = size >> 8 & 0xff;\n        buffer[index + 2] = size >> 16 & 0xff;\n        buffer[index + 3] = size >> 24 & 0xff;\n        index = index + 4 + size - 1;\n        buffer[index++] = 0;\n    }\n    return index;\n}\nfunction serializeBinary(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BINARY;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const data = value.buffer;\n    let size = value.position;\n    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) size = size + 4;\n    buffer[index++] = size & 0xff;\n    buffer[index++] = size >> 8 & 0xff;\n    buffer[index++] = size >> 16 & 0xff;\n    buffer[index++] = size >> 24 & 0xff;\n    buffer[index++] = value.sub_type;\n    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n        size = size - 4;\n        buffer[index++] = size & 0xff;\n        buffer[index++] = size >> 8 & 0xff;\n        buffer[index++] = size >> 16 & 0xff;\n        buffer[index++] = size >> 24 & 0xff;\n    }\n    buffer.set(data, index);\n    index = index + value.position;\n    return index;\n}\nfunction serializeSymbol(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_SYMBOL;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const size = ByteUtils.encodeUTF8Into(buffer, value.value, index + 4) + 1;\n    buffer[index] = size & 0xff;\n    buffer[index + 1] = size >> 8 & 0xff;\n    buffer[index + 2] = size >> 16 & 0xff;\n    buffer[index + 3] = size >> 24 & 0xff;\n    index = index + 4 + size - 1;\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path) {\n    buffer[index++] = BSON_DATA_OBJECT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    let startIndex = index;\n    let output = {\n        $ref: value.collection || value.namespace,\n        $id: value.oid\n    };\n    if (value.db != null) {\n        output.$db = value.db;\n    }\n    output = Object.assign(output, value.fields);\n    const endIndex = serializeInto(buffer, output, false, index, depth + 1, serializeFunctions, true, path);\n    const size = endIndex - startIndex;\n    buffer[startIndex++] = size & 0xff;\n    buffer[startIndex++] = size >> 8 & 0xff;\n    buffer[startIndex++] = size >> 16 & 0xff;\n    buffer[startIndex++] = size >> 24 & 0xff;\n    return endIndex;\n}\nfunction serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {\n    if (path == null) {\n        if (object == null) {\n            buffer[0] = 0x05;\n            buffer[1] = 0x00;\n            buffer[2] = 0x00;\n            buffer[3] = 0x00;\n            buffer[4] = 0x00;\n            return 5;\n        }\n        if (Array.isArray(object)) {\n            throw new BSONError(\"serialize does not support an array as the root input\");\n        }\n        if (typeof object !== \"object\") {\n            throw new BSONError(\"serialize does not support non-object as the root input\");\n        } else if (\"_bsontype\" in object && typeof object._bsontype === \"string\") {\n            throw new BSONError(`BSON types cannot be serialized as a document`);\n        } else if (isDate(object) || isRegExp(object) || isUint8Array(object) || isAnyArrayBuffer(object)) {\n            throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);\n        }\n        path = new Set();\n    }\n    path.add(object);\n    let index = startingIndex + 4;\n    if (Array.isArray(object)) {\n        for(let i = 0; i < object.length; i++){\n            const key = `${i}`;\n            let value = object[i];\n            if (typeof value?.toBSON === \"function\") {\n                value = value.toBSON();\n            }\n            if (typeof value === \"string\") {\n                index = serializeString(buffer, key, value, index);\n            } else if (typeof value === \"number\") {\n                index = serializeNumber(buffer, key, value, index);\n            } else if (typeof value === \"bigint\") {\n                index = serializeBigInt(buffer, key, value, index);\n            } else if (typeof value === \"boolean\") {\n                index = serializeBoolean(buffer, key, value, index);\n            } else if (value instanceof Date || isDate(value)) {\n                index = serializeDate(buffer, key, value, index);\n            } else if (value === undefined) {\n                index = serializeNull(buffer, key, value, index);\n            } else if (value === null) {\n                index = serializeNull(buffer, key, value, index);\n            } else if (isUint8Array(value)) {\n                index = serializeBuffer(buffer, key, value, index);\n            } else if (value instanceof RegExp || isRegExp(value)) {\n                index = serializeRegExp(buffer, key, value, index);\n            } else if (typeof value === \"object\" && value._bsontype == null) {\n                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (typeof value === \"object\" && value[Symbol.for(\"@@mdb.bson.version\")] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            } else if (value._bsontype === \"ObjectId\") {\n                index = serializeObjectId(buffer, key, value, index);\n            } else if (value._bsontype === \"Decimal128\") {\n                index = serializeDecimal128(buffer, key, value, index);\n            } else if (value._bsontype === \"Long\" || value._bsontype === \"Timestamp\") {\n                index = serializeLong(buffer, key, value, index);\n            } else if (value._bsontype === \"Double\") {\n                index = serializeDouble(buffer, key, value, index);\n            } else if (typeof value === \"function\" && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            } else if (value._bsontype === \"Code\") {\n                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (value._bsontype === \"Binary\") {\n                index = serializeBinary(buffer, key, value, index);\n            } else if (value._bsontype === \"BSONSymbol\") {\n                index = serializeSymbol(buffer, key, value, index);\n            } else if (value._bsontype === \"DBRef\") {\n                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n            } else if (value._bsontype === \"BSONRegExp\") {\n                index = serializeBSONRegExp(buffer, key, value, index);\n            } else if (value._bsontype === \"Int32\") {\n                index = serializeInt32(buffer, key, value, index);\n            } else if (value._bsontype === \"MinKey\" || value._bsontype === \"MaxKey\") {\n                index = serializeMinMax(buffer, key, value, index);\n            } else if (typeof value._bsontype !== \"undefined\") {\n                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n            }\n        }\n    } else if (object instanceof Map || isMap(object)) {\n        const iterator = object.entries();\n        let done = false;\n        while(!done){\n            const entry = iterator.next();\n            done = !!entry.done;\n            if (done) continue;\n            const key = entry.value[0];\n            let value = entry.value[1];\n            if (typeof value?.toBSON === \"function\") {\n                value = value.toBSON();\n            }\n            const type = typeof value;\n            if (typeof key === \"string\" && !ignoreKeys.has(key)) {\n                if (key.match(regexp) != null) {\n                    throw new BSONError(\"key \" + key + \" must not contain null bytes\");\n                }\n                if (checkKeys) {\n                    if (\"$\" === key[0]) {\n                        throw new BSONError(\"key \" + key + \" must not start with '$'\");\n                    } else if (~key.indexOf(\".\")) {\n                        throw new BSONError(\"key \" + key + \" must not contain '.'\");\n                    }\n                }\n            }\n            if (type === \"string\") {\n                index = serializeString(buffer, key, value, index);\n            } else if (type === \"number\") {\n                index = serializeNumber(buffer, key, value, index);\n            } else if (type === \"bigint\") {\n                index = serializeBigInt(buffer, key, value, index);\n            } else if (type === \"boolean\") {\n                index = serializeBoolean(buffer, key, value, index);\n            } else if (value instanceof Date || isDate(value)) {\n                index = serializeDate(buffer, key, value, index);\n            } else if (value === null || value === undefined && ignoreUndefined === false) {\n                index = serializeNull(buffer, key, value, index);\n            } else if (isUint8Array(value)) {\n                index = serializeBuffer(buffer, key, value, index);\n            } else if (value instanceof RegExp || isRegExp(value)) {\n                index = serializeRegExp(buffer, key, value, index);\n            } else if (type === \"object\" && value._bsontype == null) {\n                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (typeof value === \"object\" && value[Symbol.for(\"@@mdb.bson.version\")] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            } else if (value._bsontype === \"ObjectId\") {\n                index = serializeObjectId(buffer, key, value, index);\n            } else if (type === \"object\" && value._bsontype === \"Decimal128\") {\n                index = serializeDecimal128(buffer, key, value, index);\n            } else if (value._bsontype === \"Long\" || value._bsontype === \"Timestamp\") {\n                index = serializeLong(buffer, key, value, index);\n            } else if (value._bsontype === \"Double\") {\n                index = serializeDouble(buffer, key, value, index);\n            } else if (value._bsontype === \"Code\") {\n                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (typeof value === \"function\" && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            } else if (value._bsontype === \"Binary\") {\n                index = serializeBinary(buffer, key, value, index);\n            } else if (value._bsontype === \"BSONSymbol\") {\n                index = serializeSymbol(buffer, key, value, index);\n            } else if (value._bsontype === \"DBRef\") {\n                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n            } else if (value._bsontype === \"BSONRegExp\") {\n                index = serializeBSONRegExp(buffer, key, value, index);\n            } else if (value._bsontype === \"Int32\") {\n                index = serializeInt32(buffer, key, value, index);\n            } else if (value._bsontype === \"MinKey\" || value._bsontype === \"MaxKey\") {\n                index = serializeMinMax(buffer, key, value, index);\n            } else if (typeof value._bsontype !== \"undefined\") {\n                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n            }\n        }\n    } else {\n        if (typeof object?.toBSON === \"function\") {\n            object = object.toBSON();\n            if (object != null && typeof object !== \"object\") {\n                throw new BSONError(\"toBSON function did not return an object\");\n            }\n        }\n        for (const key of Object.keys(object)){\n            let value = object[key];\n            if (typeof value?.toBSON === \"function\") {\n                value = value.toBSON();\n            }\n            const type = typeof value;\n            if (typeof key === \"string\" && !ignoreKeys.has(key)) {\n                if (key.match(regexp) != null) {\n                    throw new BSONError(\"key \" + key + \" must not contain null bytes\");\n                }\n                if (checkKeys) {\n                    if (\"$\" === key[0]) {\n                        throw new BSONError(\"key \" + key + \" must not start with '$'\");\n                    } else if (~key.indexOf(\".\")) {\n                        throw new BSONError(\"key \" + key + \" must not contain '.'\");\n                    }\n                }\n            }\n            if (type === \"string\") {\n                index = serializeString(buffer, key, value, index);\n            } else if (type === \"number\") {\n                index = serializeNumber(buffer, key, value, index);\n            } else if (type === \"bigint\") {\n                index = serializeBigInt(buffer, key, value, index);\n            } else if (type === \"boolean\") {\n                index = serializeBoolean(buffer, key, value, index);\n            } else if (value instanceof Date || isDate(value)) {\n                index = serializeDate(buffer, key, value, index);\n            } else if (value === undefined) {\n                if (ignoreUndefined === false) index = serializeNull(buffer, key, value, index);\n            } else if (value === null) {\n                index = serializeNull(buffer, key, value, index);\n            } else if (isUint8Array(value)) {\n                index = serializeBuffer(buffer, key, value, index);\n            } else if (value instanceof RegExp || isRegExp(value)) {\n                index = serializeRegExp(buffer, key, value, index);\n            } else if (type === \"object\" && value._bsontype == null) {\n                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (typeof value === \"object\" && value[Symbol.for(\"@@mdb.bson.version\")] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            } else if (value._bsontype === \"ObjectId\") {\n                index = serializeObjectId(buffer, key, value, index);\n            } else if (type === \"object\" && value._bsontype === \"Decimal128\") {\n                index = serializeDecimal128(buffer, key, value, index);\n            } else if (value._bsontype === \"Long\" || value._bsontype === \"Timestamp\") {\n                index = serializeLong(buffer, key, value, index);\n            } else if (value._bsontype === \"Double\") {\n                index = serializeDouble(buffer, key, value, index);\n            } else if (value._bsontype === \"Code\") {\n                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (typeof value === \"function\" && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            } else if (value._bsontype === \"Binary\") {\n                index = serializeBinary(buffer, key, value, index);\n            } else if (value._bsontype === \"BSONSymbol\") {\n                index = serializeSymbol(buffer, key, value, index);\n            } else if (value._bsontype === \"DBRef\") {\n                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n            } else if (value._bsontype === \"BSONRegExp\") {\n                index = serializeBSONRegExp(buffer, key, value, index);\n            } else if (value._bsontype === \"Int32\") {\n                index = serializeInt32(buffer, key, value, index);\n            } else if (value._bsontype === \"MinKey\" || value._bsontype === \"MaxKey\") {\n                index = serializeMinMax(buffer, key, value, index);\n            } else if (typeof value._bsontype !== \"undefined\") {\n                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n            }\n        }\n    }\n    path.delete(object);\n    buffer[index++] = 0x00;\n    const size = index - startingIndex;\n    buffer[startingIndex++] = size & 0xff;\n    buffer[startingIndex++] = size >> 8 & 0xff;\n    buffer[startingIndex++] = size >> 16 & 0xff;\n    buffer[startingIndex++] = size >> 24 & 0xff;\n    return index;\n}\nfunction isBSONType(value) {\n    return value != null && typeof value === \"object\" && \"_bsontype\" in value && typeof value._bsontype === \"string\";\n}\nconst keysToCodecs = {\n    $oid: ObjectId,\n    $binary: Binary,\n    $uuid: Binary,\n    $symbol: BSONSymbol,\n    $numberInt: Int32,\n    $numberDecimal: Decimal128,\n    $numberDouble: Double,\n    $numberLong: Long,\n    $minKey: MinKey,\n    $maxKey: MaxKey,\n    $regex: BSONRegExp,\n    $regularExpression: BSONRegExp,\n    $timestamp: Timestamp\n};\nfunction deserializeValue(value, options = {}) {\n    if (typeof value === \"number\") {\n        const in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;\n        const in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;\n        if (options.relaxed || options.legacy) {\n            return value;\n        }\n        if (Number.isInteger(value) && !Object.is(value, -0)) {\n            if (in32BitRange) {\n                return new Int32(value);\n            }\n            if (in64BitRange) {\n                if (options.useBigInt64) {\n                    return BigInt(value);\n                }\n                return Long.fromNumber(value);\n            }\n        }\n        return new Double(value);\n    }\n    if (value == null || typeof value !== \"object\") return value;\n    if (value.$undefined) return null;\n    const keys = Object.keys(value).filter((k)=>k.startsWith(\"$\") && value[k] != null);\n    for(let i = 0; i < keys.length; i++){\n        const c = keysToCodecs[keys[i]];\n        if (c) return c.fromExtendedJSON(value, options);\n    }\n    if (value.$date != null) {\n        const d = value.$date;\n        const date = new Date();\n        if (options.legacy) {\n            if (typeof d === \"number\") date.setTime(d);\n            else if (typeof d === \"string\") date.setTime(Date.parse(d));\n            else if (typeof d === \"bigint\") date.setTime(Number(d));\n            else throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);\n        } else {\n            if (typeof d === \"string\") date.setTime(Date.parse(d));\n            else if (Long.isLong(d)) date.setTime(d.toNumber());\n            else if (typeof d === \"number\" && options.relaxed) date.setTime(d);\n            else if (typeof d === \"bigint\") date.setTime(Number(d));\n            else throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);\n        }\n        return date;\n    }\n    if (value.$code != null) {\n        const copy = Object.assign({}, value);\n        if (value.$scope) {\n            copy.$scope = deserializeValue(value.$scope);\n        }\n        return Code.fromExtendedJSON(value);\n    }\n    if (isDBRefLike(value) || value.$dbPointer) {\n        const v = value.$ref ? value : value.$dbPointer;\n        if (v instanceof DBRef) return v;\n        const dollarKeys = Object.keys(v).filter((k)=>k.startsWith(\"$\"));\n        let valid = true;\n        dollarKeys.forEach((k)=>{\n            if ([\n                \"$ref\",\n                \"$id\",\n                \"$db\"\n            ].indexOf(k) === -1) valid = false;\n        });\n        if (valid) return DBRef.fromExtendedJSON(v);\n    }\n    return value;\n}\nfunction serializeArray(array, options) {\n    return array.map((v, index)=>{\n        options.seenObjects.push({\n            propertyName: `index ${index}`,\n            obj: null\n        });\n        try {\n            return serializeValue(v, options);\n        } finally{\n            options.seenObjects.pop();\n        }\n    });\n}\nfunction getISOString(date) {\n    const isoStr = date.toISOString();\n    return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + \"Z\";\n}\nfunction serializeValue(value, options) {\n    if (value instanceof Map || isMap(value)) {\n        const obj = Object.create(null);\n        for (const [k, v] of value){\n            if (typeof k !== \"string\") {\n                throw new BSONError(\"Can only serialize maps with string keys\");\n            }\n            obj[k] = v;\n        }\n        return serializeValue(obj, options);\n    }\n    if ((typeof value === \"object\" || typeof value === \"function\") && value !== null) {\n        const index = options.seenObjects.findIndex((entry)=>entry.obj === value);\n        if (index !== -1) {\n            const props = options.seenObjects.map((entry)=>entry.propertyName);\n            const leadingPart = props.slice(0, index).map((prop)=>`${prop} -> `).join(\"\");\n            const alreadySeen = props[index];\n            const circularPart = \" -> \" + props.slice(index + 1, props.length - 1).map((prop)=>`${prop} -> `).join(\"\");\n            const current = props[props.length - 1];\n            const leadingSpace = \" \".repeat(leadingPart.length + alreadySeen.length / 2);\n            const dashes = \"-\".repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);\n            throw new BSONError(\"Converting circular structure to EJSON:\\n\" + `    ${leadingPart}${alreadySeen}${circularPart}${current}\\n` + `    ${leadingSpace}\\\\${dashes}/`);\n        }\n        options.seenObjects[options.seenObjects.length - 1].obj = value;\n    }\n    if (Array.isArray(value)) return serializeArray(value, options);\n    if (value === undefined) return null;\n    if (value instanceof Date || isDate(value)) {\n        const dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 253402318800000;\n        if (options.legacy) {\n            return options.relaxed && inRange ? {\n                $date: value.getTime()\n            } : {\n                $date: getISOString(value)\n            };\n        }\n        return options.relaxed && inRange ? {\n            $date: getISOString(value)\n        } : {\n            $date: {\n                $numberLong: value.getTime().toString()\n            }\n        };\n    }\n    if (typeof value === \"number\" && (!options.relaxed || !isFinite(value))) {\n        if (Number.isInteger(value) && !Object.is(value, -0)) {\n            if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {\n                return {\n                    $numberInt: value.toString()\n                };\n            }\n            if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {\n                return {\n                    $numberLong: value.toString()\n                };\n            }\n        }\n        return {\n            $numberDouble: Object.is(value, -0) ? \"-0.0\" : value.toString()\n        };\n    }\n    if (typeof value === \"bigint\") {\n        if (!options.relaxed) {\n            return {\n                $numberLong: BigInt.asIntN(64, value).toString()\n            };\n        }\n        return Number(BigInt.asIntN(64, value));\n    }\n    if (value instanceof RegExp || isRegExp(value)) {\n        let flags = value.flags;\n        if (flags === undefined) {\n            const match = value.toString().match(/[gimuy]*$/);\n            if (match) {\n                flags = match[0];\n            }\n        }\n        const rx = new BSONRegExp(value.source, flags);\n        return rx.toExtendedJSON(options);\n    }\n    if (value != null && typeof value === \"object\") return serializeDocument(value, options);\n    return value;\n}\nconst BSON_TYPE_MAPPINGS = {\n    Binary: (o)=>new Binary(o.value(), o.sub_type),\n    Code: (o)=>new Code(o.code, o.scope),\n    DBRef: (o)=>new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields),\n    Decimal128: (o)=>new Decimal128(o.bytes),\n    Double: (o)=>new Double(o.value),\n    Int32: (o)=>new Int32(o.value),\n    Long: (o)=>Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_),\n    MaxKey: ()=>new MaxKey(),\n    MinKey: ()=>new MinKey(),\n    ObjectId: (o)=>new ObjectId(o),\n    BSONRegExp: (o)=>new BSONRegExp(o.pattern, o.options),\n    BSONSymbol: (o)=>new BSONSymbol(o.value),\n    Timestamp: (o)=>Timestamp.fromBits(o.low, o.high)\n};\nfunction serializeDocument(doc, options) {\n    if (doc == null || typeof doc !== \"object\") throw new BSONError(\"not an object instance\");\n    const bsontype = doc._bsontype;\n    if (typeof bsontype === \"undefined\") {\n        const _doc = {};\n        for (const name of Object.keys(doc)){\n            options.seenObjects.push({\n                propertyName: name,\n                obj: null\n            });\n            try {\n                const value = serializeValue(doc[name], options);\n                if (name === \"__proto__\") {\n                    Object.defineProperty(_doc, name, {\n                        value,\n                        writable: true,\n                        enumerable: true,\n                        configurable: true\n                    });\n                } else {\n                    _doc[name] = value;\n                }\n            } finally{\n                options.seenObjects.pop();\n            }\n        }\n        return _doc;\n    } else if (doc != null && typeof doc === \"object\" && typeof doc._bsontype === \"string\" && doc[Symbol.for(\"@@mdb.bson.version\")] !== BSON_MAJOR_VERSION) {\n        throw new BSONVersionError();\n    } else if (isBSONType(doc)) {\n        let outDoc = doc;\n        if (typeof outDoc.toExtendedJSON !== \"function\") {\n            const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];\n            if (!mapper) {\n                throw new BSONError(\"Unrecognized or invalid _bsontype: \" + doc._bsontype);\n            }\n            outDoc = mapper(outDoc);\n        }\n        if (bsontype === \"Code\" && outDoc.scope) {\n            outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));\n        } else if (bsontype === \"DBRef\" && outDoc.oid) {\n            outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));\n        }\n        return outDoc.toExtendedJSON(options);\n    } else {\n        throw new BSONError(\"_bsontype must be a string, but was: \" + typeof bsontype);\n    }\n}\nfunction parse(text, options) {\n    const ejsonOptions = {\n        useBigInt64: options?.useBigInt64 ?? false,\n        relaxed: options?.relaxed ?? true,\n        legacy: options?.legacy ?? false\n    };\n    return JSON.parse(text, (key, value)=>{\n        if (key.indexOf(\"\\x00\") !== -1) {\n            throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`);\n        }\n        return deserializeValue(value, ejsonOptions);\n    });\n}\nfunction stringify(value, replacer, space, options) {\n    if (space != null && typeof space === \"object\") {\n        options = space;\n        space = 0;\n    }\n    if (replacer != null && typeof replacer === \"object\" && !Array.isArray(replacer)) {\n        options = replacer;\n        replacer = undefined;\n        space = 0;\n    }\n    const serializeOptions = Object.assign({\n        relaxed: true,\n        legacy: false\n    }, options, {\n        seenObjects: [\n            {\n                propertyName: \"(root)\",\n                obj: null\n            }\n        ]\n    });\n    const doc = serializeValue(value, serializeOptions);\n    return JSON.stringify(doc, replacer, space);\n}\nfunction EJSONserialize(value, options) {\n    options = options || {};\n    return JSON.parse(stringify(value, options));\n}\nfunction EJSONdeserialize(ejson, options) {\n    options = options || {};\n    return parse(JSON.stringify(ejson), options);\n}\nconst EJSON = Object.create(null);\nEJSON.parse = parse;\nEJSON.stringify = stringify;\nEJSON.serialize = EJSONserialize;\nEJSON.deserialize = EJSONdeserialize;\nObject.freeze(EJSON);\nconst MAXSIZE = 1024 * 1024 * 17;\nlet buffer = ByteUtils.allocate(MAXSIZE);\nfunction setInternalBufferSize(size) {\n    if (buffer.length < size) {\n        buffer = ByteUtils.allocate(size);\n    }\n}\nfunction serialize(object, options = {}) {\n    const checkKeys = typeof options.checkKeys === \"boolean\" ? options.checkKeys : false;\n    const serializeFunctions = typeof options.serializeFunctions === \"boolean\" ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === \"boolean\" ? options.ignoreUndefined : true;\n    const minInternalBufferSize = typeof options.minInternalBufferSize === \"number\" ? options.minInternalBufferSize : MAXSIZE;\n    if (buffer.length < minInternalBufferSize) {\n        buffer = ByteUtils.allocate(minInternalBufferSize);\n    }\n    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);\n    const finishedBuffer = ByteUtils.allocate(serializationIndex);\n    finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);\n    return finishedBuffer;\n}\nfunction serializeWithBufferAndIndex(object, finalBuffer, options = {}) {\n    const checkKeys = typeof options.checkKeys === \"boolean\" ? options.checkKeys : false;\n    const serializeFunctions = typeof options.serializeFunctions === \"boolean\" ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === \"boolean\" ? options.ignoreUndefined : true;\n    const startIndex = typeof options.index === \"number\" ? options.index : 0;\n    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);\n    finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);\n    return startIndex + serializationIndex - 1;\n}\nfunction deserialize(buffer, options = {}) {\n    return internalDeserialize(ByteUtils.toLocalBufferType(buffer), options);\n}\nfunction calculateObjectSize(object, options = {}) {\n    options = options || {};\n    const serializeFunctions = typeof options.serializeFunctions === \"boolean\" ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === \"boolean\" ? options.ignoreUndefined : true;\n    return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);\n}\nfunction deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {\n    const internalOptions = Object.assign({\n        allowObjectSmallerThanBufferSize: true,\n        index: 0\n    }, options);\n    const bufferData = ByteUtils.toLocalBufferType(data);\n    let index = startIndex;\n    for(let i = 0; i < numberOfDocuments; i++){\n        const size = bufferData[index] | bufferData[index + 1] << 8 | bufferData[index + 2] << 16 | bufferData[index + 3] << 24;\n        internalOptions.index = index;\n        documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);\n        index = index + size;\n    }\n    return index;\n}\nvar bson = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    BSONError: BSONError,\n    BSONRegExp: BSONRegExp,\n    BSONRuntimeError: BSONRuntimeError,\n    BSONSymbol: BSONSymbol,\n    BSONType: BSONType,\n    BSONValue: BSONValue,\n    BSONVersionError: BSONVersionError,\n    Binary: Binary,\n    Code: Code,\n    DBRef: DBRef,\n    Decimal128: Decimal128,\n    Double: Double,\n    EJSON: EJSON,\n    Int32: Int32,\n    Long: Long,\n    MaxKey: MaxKey,\n    MinKey: MinKey,\n    ObjectId: ObjectId,\n    Timestamp: Timestamp,\n    UUID: UUID,\n    calculateObjectSize: calculateObjectSize,\n    deserialize: deserialize,\n    deserializeStream: deserializeStream,\n    serialize: serialize,\n    serializeWithBufferAndIndex: serializeWithBufferAndIndex,\n    setInternalBufferSize: setInternalBufferSize\n});\nexports.BSON = bson;\nexports.BSONError = BSONError;\nexports.BSONRegExp = BSONRegExp;\nexports.BSONRuntimeError = BSONRuntimeError;\nexports.BSONSymbol = BSONSymbol;\nexports.BSONType = BSONType;\nexports.BSONValue = BSONValue;\nexports.BSONVersionError = BSONVersionError;\nexports.Binary = Binary;\nexports.Code = Code;\nexports.DBRef = DBRef;\nexports.Decimal128 = Decimal128;\nexports.Double = Double;\nexports.EJSON = EJSON;\nexports.Int32 = Int32;\nexports.Long = Long;\nexports.MaxKey = MaxKey;\nexports.MinKey = MinKey;\nexports.ObjectId = ObjectId;\nexports.Timestamp = Timestamp;\nexports.UUID = UUID;\nexports.calculateObjectSize = calculateObjectSize;\nexports.deserialize = deserialize;\nexports.deserializeStream = deserializeStream;\nexports.serialize = serialize;\nexports.serializeWithBufferAndIndex = serializeWithBufferAndIndex;\nexports.setInternalBufferSize = setInternalBufferSize; //# sourceMappingURL=bson.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RztRQUFHO1FBQUc7UUFBRztRQUFLO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFLO1FBQUs7UUFBSztRQUFHO1FBQUc7UUFBRztRQUFLO1FBQUs7UUFBSztRQUFJO1FBQUs7UUFBRztRQUFHO1FBQUc7UUFBSztRQUFLO1FBQUs7UUFBSTtRQUFLO1FBQUc7UUFBRztRQUFHO1FBQUs7UUFBSztRQUFLO1FBQUk7UUFBSztRQUFHO1FBQUc7UUFBRztRQUFLO1FBQUs7UUFBSztRQUFJO1FBQUs7UUFBRztRQUFHO1FBQUc7UUFBSztRQUFLO1FBQUs7UUFBSTtRQUFLO1FBQUs7UUFBSztRQUFLO1FBQUc7UUFBRztRQUFJO1FBQUs7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFLO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUs7UUFBSztRQUFLO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSztRQUFLO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUs7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUk7UUFBSztRQUFLO1FBQUs7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFLO1FBQUs7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUk7UUFBSztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFLO1FBQUs7UUFBSztRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUs7UUFBSztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUs7UUFB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LGFBQWEsR0FBR2lRO0FBQ2hCalEsWUFBWSxHQUFHVTtBQUNmVixjQUFjLEdBQUdtUTtBQUNqQm5RLGNBQWMsR0FBR3FRO0FBQ2pCclEsZ0JBQWdCLEdBQUcyUTtBQUNuQjNRLGlCQUFpQixHQUFHc1Q7QUFDcEJ0VCxZQUFZLEdBQUc3RDtBQUNmNkQsMkJBQTJCLEdBQUc4ZTtBQUM5QjllLG1CQUFtQixHQUFHc2U7QUFDdEJ0ZSx5QkFBeUIsR0FBRytlO0FBQzVCL2UsaUJBQWlCLEdBQUdxZTtBQUNwQnJlLG1DQUFtQyxHQUFHNGU7QUFDdEM1ZSw2QkFBNkIsR0FBR3dlLHVCQUNoQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWF1dGgtcmVnaXN0ZXIvLi9ub2RlX21vZHVsZXMvYnNvbi9saWIvYnNvbi5janM/M2ZiMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGlzQW55QXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICByZXR1cm4gWydbb2JqZWN0IEFycmF5QnVmZmVyXScsICdbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXSddLmluY2x1ZGVzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFVpbnQ4QXJyYXldJztcbn1cbmZ1bmN0aW9uIGlzUmVnRXhwKGQpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGQpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmZ1bmN0aW9uIGlzTWFwKGQpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGQpID09PSAnW29iamVjdCBNYXBdJztcbn1cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG5jb25zdCBCU09OX01BSk9SX1ZFUlNJT04gPSA1O1xuY29uc3QgQlNPTl9JTlQzMl9NQVggPSAweDdmZmZmZmZmO1xuY29uc3QgQlNPTl9JTlQzMl9NSU4gPSAtMHg4MDAwMDAwMDtcbmNvbnN0IEJTT05fSU5UNjRfTUFYID0gTWF0aC5wb3coMiwgNjMpIC0gMTtcbmNvbnN0IEJTT05fSU5UNjRfTUlOID0gLU1hdGgucG93KDIsIDYzKTtcbmNvbnN0IEpTX0lOVF9NQVggPSBNYXRoLnBvdygyLCA1Myk7XG5jb25zdCBKU19JTlRfTUlOID0gLU1hdGgucG93KDIsIDUzKTtcbmNvbnN0IEJTT05fREFUQV9OVU1CRVIgPSAxO1xuY29uc3QgQlNPTl9EQVRBX1NUUklORyA9IDI7XG5jb25zdCBCU09OX0RBVEFfT0JKRUNUID0gMztcbmNvbnN0IEJTT05fREFUQV9BUlJBWSA9IDQ7XG5jb25zdCBCU09OX0RBVEFfQklOQVJZID0gNTtcbmNvbnN0IEJTT05fREFUQV9VTkRFRklORUQgPSA2O1xuY29uc3QgQlNPTl9EQVRBX09JRCA9IDc7XG5jb25zdCBCU09OX0RBVEFfQk9PTEVBTiA9IDg7XG5jb25zdCBCU09OX0RBVEFfREFURSA9IDk7XG5jb25zdCBCU09OX0RBVEFfTlVMTCA9IDEwO1xuY29uc3QgQlNPTl9EQVRBX1JFR0VYUCA9IDExO1xuY29uc3QgQlNPTl9EQVRBX0RCUE9JTlRFUiA9IDEyO1xuY29uc3QgQlNPTl9EQVRBX0NPREUgPSAxMztcbmNvbnN0IEJTT05fREFUQV9TWU1CT0wgPSAxNDtcbmNvbnN0IEJTT05fREFUQV9DT0RFX1dfU0NPUEUgPSAxNTtcbmNvbnN0IEJTT05fREFUQV9JTlQgPSAxNjtcbmNvbnN0IEJTT05fREFUQV9USU1FU1RBTVAgPSAxNztcbmNvbnN0IEJTT05fREFUQV9MT05HID0gMTg7XG5jb25zdCBCU09OX0RBVEFfREVDSU1BTDEyOCA9IDE5O1xuY29uc3QgQlNPTl9EQVRBX01JTl9LRVkgPSAweGZmO1xuY29uc3QgQlNPTl9EQVRBX01BWF9LRVkgPSAweDdmO1xuY29uc3QgQlNPTl9CSU5BUllfU1VCVFlQRV9ERUZBVUxUID0gMDtcbmNvbnN0IEJTT05fQklOQVJZX1NVQlRZUEVfVVVJRF9ORVcgPSA0O1xuY29uc3QgQlNPTlR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgICBkb3VibGU6IDEsXG4gICAgc3RyaW5nOiAyLFxuICAgIG9iamVjdDogMyxcbiAgICBhcnJheTogNCxcbiAgICBiaW5EYXRhOiA1LFxuICAgIHVuZGVmaW5lZDogNixcbiAgICBvYmplY3RJZDogNyxcbiAgICBib29sOiA4LFxuICAgIGRhdGU6IDksXG4gICAgbnVsbDogMTAsXG4gICAgcmVnZXg6IDExLFxuICAgIGRiUG9pbnRlcjogMTIsXG4gICAgamF2YXNjcmlwdDogMTMsXG4gICAgc3ltYm9sOiAxNCxcbiAgICBqYXZhc2NyaXB0V2l0aFNjb3BlOiAxNSxcbiAgICBpbnQ6IDE2LFxuICAgIHRpbWVzdGFtcDogMTcsXG4gICAgbG9uZzogMTgsXG4gICAgZGVjaW1hbDogMTksXG4gICAgbWluS2V5OiAtMSxcbiAgICBtYXhLZXk6IDEyN1xufSk7XG5cbmNsYXNzIEJTT05FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBnZXQgYnNvbkVycm9yKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnQlNPTkVycm9yJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB9XG4gICAgc3RhdGljIGlzQlNPTkVycm9yKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ2Jzb25FcnJvcicgaW4gdmFsdWUgJiZcbiAgICAgICAgICAgIHZhbHVlLmJzb25FcnJvciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgJ25hbWUnIGluIHZhbHVlICYmXG4gICAgICAgICAgICAnbWVzc2FnZScgaW4gdmFsdWUgJiZcbiAgICAgICAgICAgICdzdGFjaycgaW4gdmFsdWUpO1xuICAgIH1cbn1cbmNsYXNzIEJTT05WZXJzaW9uRXJyb3IgZXh0ZW5kcyBCU09ORXJyb3Ige1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ0JTT05WZXJzaW9uRXJyb3InO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoYFVuc3VwcG9ydGVkIEJTT04gdmVyc2lvbiwgYnNvbiB0eXBlcyBtdXN0IGJlIGZyb20gYnNvbiAke0JTT05fTUFKT1JfVkVSU0lPTn0uMCBvciBsYXRlcmApO1xuICAgIH1cbn1cbmNsYXNzIEJTT05SdW50aW1lRXJyb3IgZXh0ZW5kcyBCU09ORXJyb3Ige1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ0JTT05SdW50aW1lRXJyb3InO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9kZWpzTWF0aFJhbmRvbUJ5dGVzKGJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gbm9kZUpzQnl0ZVV0aWxzLmZyb21OdW1iZXJBcnJheShBcnJheS5mcm9tKHsgbGVuZ3RoOiBieXRlTGVuZ3RoIH0sICgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NikpKTtcbn1cbmNvbnN0IG5vZGVqc1JhbmRvbUJ5dGVzID0gKCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZSgnY3J5cHRvJykucmFuZG9tQnl0ZXM7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIG5vZGVqc01hdGhSYW5kb21CeXRlcztcbiAgICB9XG59KSgpO1xuY29uc3Qgbm9kZUpzQnl0ZVV0aWxzID0ge1xuICAgIHRvTG9jYWxCdWZmZXJUeXBlKHBvdGVudGlhbEJ1ZmZlcikge1xuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHBvdGVudGlhbEJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3RlbnRpYWxCdWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhwb3RlbnRpYWxCdWZmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20ocG90ZW50aWFsQnVmZmVyLmJ1ZmZlciwgcG90ZW50aWFsQnVmZmVyLmJ5dGVPZmZzZXQsIHBvdGVudGlhbEJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJpbmdUYWcgPSBwb3RlbnRpYWxCdWZmZXI/LltTeW1ib2wudG9TdHJpbmdUYWddID8/IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwb3RlbnRpYWxCdWZmZXIpO1xuICAgICAgICBpZiAoc3RyaW5nVGFnID09PSAnQXJyYXlCdWZmZXInIHx8XG4gICAgICAgICAgICBzdHJpbmdUYWcgPT09ICdTaGFyZWRBcnJheUJ1ZmZlcicgfHxcbiAgICAgICAgICAgIHN0cmluZ1RhZyA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyB8fFxuICAgICAgICAgICAgc3RyaW5nVGFnID09PSAnW29iamVjdCBTaGFyZWRBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20ocG90ZW50aWFsQnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBDYW5ub3QgY3JlYXRlIEJ1ZmZlciBmcm9tICR7U3RyaW5nKHBvdGVudGlhbEJ1ZmZlcil9YCk7XG4gICAgfSxcbiAgICBhbGxvY2F0ZShzaXplKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2Moc2l6ZSk7XG4gICAgfSxcbiAgICBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gbm9kZUpzQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGEpLmVxdWFscyhiKTtcbiAgICB9LFxuICAgIGZyb21OdW1iZXJBcnJheShhcnJheSkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyYXkpO1xuICAgIH0sXG4gICAgZnJvbUJhc2U2NChiYXNlNjQpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJhc2U2NCwgJ2Jhc2U2NCcpO1xuICAgIH0sXG4gICAgdG9CYXNlNjQoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBub2RlSnNCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoYnVmZmVyKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfSxcbiAgICBmcm9tSVNPODg1OTEoY29kZVBvaW50cykge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oY29kZVBvaW50cywgJ2JpbmFyeScpO1xuICAgIH0sXG4gICAgdG9JU084ODU5MShidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVKc0J5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIpLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICB9LFxuICAgIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShoZXgsICdoZXgnKTtcbiAgICB9LFxuICAgIHRvSGV4KGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbm9kZUpzQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGJ1ZmZlcikudG9TdHJpbmcoJ2hleCcpO1xuICAgIH0sXG4gICAgZnJvbVVURjgodGV4dCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odGV4dCwgJ3V0ZjgnKTtcbiAgICB9LFxuICAgIHRvVVRGOChidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVKc0J5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIpLnRvU3RyaW5nKCd1dGY4Jywgc3RhcnQsIGVuZCk7XG4gICAgfSxcbiAgICB1dGY4Qnl0ZUxlbmd0aChpbnB1dCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoaW5wdXQsICd1dGY4Jyk7XG4gICAgfSxcbiAgICBlbmNvZGVVVEY4SW50byhidWZmZXIsIHNvdXJjZSwgYnl0ZU9mZnNldCkge1xuICAgICAgICByZXR1cm4gbm9kZUpzQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGJ1ZmZlcikud3JpdGUoc291cmNlLCBieXRlT2Zmc2V0LCB1bmRlZmluZWQsICd1dGY4Jyk7XG4gICAgfSxcbiAgICByYW5kb21CeXRlczogbm9kZWpzUmFuZG9tQnl0ZXNcbn07XG5cbmZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUoKSB7XG4gICAgY29uc3QgeyBuYXZpZ2F0b3IgfSA9IGdsb2JhbFRoaXM7XG4gICAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnO1xufVxuZnVuY3Rpb24gd2ViTWF0aFJhbmRvbUJ5dGVzKGJ5dGVMZW5ndGgpIHtcbiAgICBpZiAoYnl0ZUxlbmd0aCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFRoZSBhcmd1bWVudCAnYnl0ZUxlbmd0aCcgaXMgaW52YWxpZC4gUmVjZWl2ZWQgJHtieXRlTGVuZ3RofWApO1xuICAgIH1cbiAgICByZXR1cm4gd2ViQnl0ZVV0aWxzLmZyb21OdW1iZXJBcnJheShBcnJheS5mcm9tKHsgbGVuZ3RoOiBieXRlTGVuZ3RoIH0sICgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NikpKTtcbn1cbmNvbnN0IHdlYlJhbmRvbUJ5dGVzID0gKCgpID0+IHtcbiAgICBjb25zdCB7IGNyeXB0byB9ID0gZ2xvYmFsVGhpcztcbiAgICBpZiAoY3J5cHRvICE9IG51bGwgJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIChieXRlTGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh3ZWJCeXRlVXRpbHMuYWxsb2NhdGUoYnl0ZUxlbmd0aCkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgICAgICAgY29uc3QgeyBjb25zb2xlIH0gPSBnbG9iYWxUaGlzO1xuICAgICAgICAgICAgY29uc29sZT8ud2Fybj8uKCdCU09OOiBGb3IgUmVhY3QgTmF0aXZlIHBsZWFzZSBwb2x5ZmlsbCBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLCBlLmcuIHVzaW5nOiBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9yZWFjdC1uYXRpdmUtZ2V0LXJhbmRvbS12YWx1ZXMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdlYk1hdGhSYW5kb21CeXRlcztcbiAgICB9XG59KSgpO1xuY29uc3QgSEVYX0RJR0lUID0gLyhcXGR8W2EtZl0pL2k7XG5jb25zdCB3ZWJCeXRlVXRpbHMgPSB7XG4gICAgdG9Mb2NhbEJ1ZmZlclR5cGUocG90ZW50aWFsVWludDhhcnJheSkge1xuICAgICAgICBjb25zdCBzdHJpbmdUYWcgPSBwb3RlbnRpYWxVaW50OGFycmF5Py5bU3ltYm9sLnRvU3RyaW5nVGFnXSA/P1xuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHBvdGVudGlhbFVpbnQ4YXJyYXkpO1xuICAgICAgICBpZiAoc3RyaW5nVGFnID09PSAnVWludDhBcnJheScpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3RlbnRpYWxVaW50OGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocG90ZW50aWFsVWludDhhcnJheSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShwb3RlbnRpYWxVaW50OGFycmF5LmJ1ZmZlci5zbGljZShwb3RlbnRpYWxVaW50OGFycmF5LmJ5dGVPZmZzZXQsIHBvdGVudGlhbFVpbnQ4YXJyYXkuYnl0ZU9mZnNldCArIHBvdGVudGlhbFVpbnQ4YXJyYXkuYnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpbmdUYWcgPT09ICdBcnJheUJ1ZmZlcicgfHxcbiAgICAgICAgICAgIHN0cmluZ1RhZyA9PT0gJ1NoYXJlZEFycmF5QnVmZmVyJyB8fFxuICAgICAgICAgICAgc3RyaW5nVGFnID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nIHx8XG4gICAgICAgICAgICBzdHJpbmdUYWcgPT09ICdbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXScpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShwb3RlbnRpYWxVaW50OGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBDYW5ub3QgbWFrZSBhIFVpbnQ4QXJyYXkgZnJvbSAke1N0cmluZyhwb3RlbnRpYWxVaW50OGFycmF5KX1gKTtcbiAgICB9LFxuICAgIGFsbG9jYXRlKHNpemUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkICR7U3RyaW5nKHNpemUpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICB9LFxuICAgIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZnJvbU51bWJlckFycmF5KGFycmF5KSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYXJyYXkpO1xuICAgIH0sXG4gICAgZnJvbUJhc2U2NChiYXNlNjQpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhdG9iKGJhc2U2NCksIGMgPT4gYy5jaGFyQ29kZUF0KDApKTtcbiAgICB9LFxuICAgIHRvQmFzZTY0KHVpbnQ4YXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGJ0b2Eod2ViQnl0ZVV0aWxzLnRvSVNPODg1OTEodWludDhhcnJheSkpO1xuICAgIH0sXG4gICAgZnJvbUlTTzg4NTkxKGNvZGVQb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb2RlUG9pbnRzLCBjID0+IGMuY2hhckNvZGVBdCgwKSAmIDB4ZmYpO1xuICAgIH0sXG4gICAgdG9JU084ODU5MSh1aW50OGFycmF5KSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKFVpbnQxNkFycmF5LmZyb20odWludDhhcnJheSksIGIgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShiKSkuam9pbignJyk7XG4gICAgfSxcbiAgICBmcm9tSGV4KGhleCkge1xuICAgICAgICBjb25zdCBldmVuTGVuZ3RoSGV4ID0gaGV4Lmxlbmd0aCAlIDIgPT09IDAgPyBoZXggOiBoZXguc2xpY2UoMCwgaGV4Lmxlbmd0aCAtIDEpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVuTGVuZ3RoSGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdERpZ2l0ID0gZXZlbkxlbmd0aEhleFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZERpZ2l0ID0gZXZlbkxlbmd0aEhleFtpICsgMV07XG4gICAgICAgICAgICBpZiAoIUhFWF9ESUdJVC50ZXN0KGZpcnN0RGlnaXQpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUhFWF9ESUdJVC50ZXN0KHNlY29uZERpZ2l0KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGV4RGlnaXQgPSBOdW1iZXIucGFyc2VJbnQoYCR7Zmlyc3REaWdpdH0ke3NlY29uZERpZ2l0fWAsIDE2KTtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGhleERpZ2l0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGJ1ZmZlcik7XG4gICAgfSxcbiAgICB0b0hleCh1aW50OGFycmF5KSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHVpbnQ4YXJyYXksIGJ5dGUgPT4gYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJyk7XG4gICAgfSxcbiAgICBmcm9tVVRGOCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGV4dCk7XG4gICAgfSxcbiAgICB0b1VURjgodWludDhhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCd1dGY4JywgeyBmYXRhbDogZmFsc2UgfSkuZGVjb2RlKHVpbnQ4YXJyYXkuc2xpY2Uoc3RhcnQsIGVuZCkpO1xuICAgIH0sXG4gICAgdXRmOEJ5dGVMZW5ndGgoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHdlYkJ5dGVVdGlscy5mcm9tVVRGOChpbnB1dCkuYnl0ZUxlbmd0aDtcbiAgICB9LFxuICAgIGVuY29kZVVURjhJbnRvKGJ1ZmZlciwgc291cmNlLCBieXRlT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gd2ViQnl0ZVV0aWxzLmZyb21VVEY4KHNvdXJjZSk7XG4gICAgICAgIGJ1ZmZlci5zZXQoYnl0ZXMsIGJ5dGVPZmZzZXQpO1xuICAgICAgICByZXR1cm4gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICB9LFxuICAgIHJhbmRvbUJ5dGVzOiB3ZWJSYW5kb21CeXRlc1xufTtcblxuY29uc3QgaGFzR2xvYmFsQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBCdWZmZXIucHJvdG90eXBlPy5faXNCdWZmZXIgIT09IHRydWU7XG5jb25zdCBCeXRlVXRpbHMgPSBoYXNHbG9iYWxCdWZmZXIgPyBub2RlSnNCeXRlVXRpbHMgOiB3ZWJCeXRlVXRpbHM7XG5jbGFzcyBCU09ORGF0YVZpZXcgZXh0ZW5kcyBEYXRhVmlldyB7XG4gICAgc3RhdGljIGZyb21VaW50OEFycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcoaW5wdXQuYnVmZmVyLCBpbnB1dC5ieXRlT2Zmc2V0LCBpbnB1dC5ieXRlTGVuZ3RoKTtcbiAgICB9XG59XG5cbmNsYXNzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IFtTeW1ib2wuZm9yKCdAQG1kYi5ic29uLnZlcnNpb24nKV0oKSB7XG4gICAgICAgIHJldHVybiBCU09OX01BSk9SX1ZFUlNJT047XG4gICAgfVxufVxuXG5jbGFzcyBCaW5hcnkgZXh0ZW5kcyBCU09OVmFsdWUge1xuICAgIGdldCBfYnNvbnR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnQmluYXJ5JztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBzdWJUeXBlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICghKGJ1ZmZlciA9PSBudWxsKSAmJlxuICAgICAgICAgICAgISh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykgJiZcbiAgICAgICAgICAgICFBcnJheUJ1ZmZlci5pc1ZpZXcoYnVmZmVyKSAmJlxuICAgICAgICAgICAgIShidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgJiZcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JpbmFyeSBjYW4gb25seSBiZSBjb25zdHJ1Y3RlZCBmcm9tIHN0cmluZywgQnVmZmVyLCBUeXBlZEFycmF5LCBvciBBcnJheTxudW1iZXI+Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJfdHlwZSA9IHN1YlR5cGUgPz8gQmluYXJ5LkJTT05fQklOQVJZX1NVQlRZUEVfREVGQVVMVDtcbiAgICAgICAgaWYgKGJ1ZmZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZShCaW5hcnkuQlVGRkVSX1NJWkUpO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ5dGVVdGlscy5mcm9tSVNPODg1OTEoYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYnVmZmVyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gQnl0ZVV0aWxzLmZyb21OdW1iZXJBcnJheShidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHB1dChieXRlVmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBieXRlVmFsdWUgPT09ICdzdHJpbmcnICYmIGJ5dGVWYWx1ZS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ29ubHkgYWNjZXB0cyBzaW5nbGUgY2hhcmFjdGVyIFN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBieXRlVmFsdWUgIT09ICdudW1iZXInICYmIGJ5dGVWYWx1ZS5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdvbmx5IGFjY2VwdHMgc2luZ2xlIGNoYXJhY3RlciBVaW50OEFycmF5IG9yIEFycmF5Jyk7XG4gICAgICAgIGxldCBkZWNvZGVkQnl0ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBieXRlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkZWNvZGVkQnl0ZSA9IGJ5dGVWYWx1ZS5jaGFyQ29kZUF0KDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBieXRlVmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBkZWNvZGVkQnl0ZSA9IGJ5dGVWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlY29kZWRCeXRlID0gYnl0ZVZhbHVlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWNvZGVkQnl0ZSA8IDAgfHwgZGVjb2RlZEJ5dGUgPiAyNTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ29ubHkgYWNjZXB0cyBudW1iZXIgaW4gYSB2YWxpZCB1bnNpZ25lZCBieXRlIHJhbmdlIDAtMjU1Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGggPiB0aGlzLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvc2l0aW9uKytdID0gZGVjb2RlZEJ5dGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTcGFjZSA9IEJ5dGVVdGlscy5hbGxvY2F0ZShCaW5hcnkuQlVGRkVSX1NJWkUgKyB0aGlzLmJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgbmV3U3BhY2Uuc2V0KHRoaXMuYnVmZmVyLCAwKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3U3BhY2U7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvc2l0aW9uKytdID0gZGVjb2RlZEJ5dGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGUoc2VxdWVuY2UsIG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJyA/IG9mZnNldCA6IHRoaXMucG9zaXRpb247XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoIDwgb2Zmc2V0ICsgc2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTcGFjZSA9IEJ5dGVVdGlscy5hbGxvY2F0ZSh0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoICsgc2VxdWVuY2UubGVuZ3RoKTtcbiAgICAgICAgICAgIG5ld1NwYWNlLnNldCh0aGlzLmJ1ZmZlciwgMCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ld1NwYWNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc2VxdWVuY2UpKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5zZXQoQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKHNlcXVlbmNlKSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPVxuICAgICAgICAgICAgICAgIG9mZnNldCArIHNlcXVlbmNlLmJ5dGVMZW5ndGggPiB0aGlzLnBvc2l0aW9uID8gb2Zmc2V0ICsgc2VxdWVuY2UubGVuZ3RoIDogdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2VxdWVuY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IEJ5dGVVdGlscy5mcm9tSVNPODg1OTEoc2VxdWVuY2UpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIuc2V0KGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICsgc2VxdWVuY2UubGVuZ3RoID4gdGhpcy5wb3NpdGlvbiA/IG9mZnNldCArIHNlcXVlbmNlLmxlbmd0aCA6IHRoaXMucG9zaXRpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZChwb3NpdGlvbiwgbGVuZ3RoKSB7XG4gICAgICAgIGxlbmd0aCA9IGxlbmd0aCAmJiBsZW5ndGggPiAwID8gbGVuZ3RoIDogdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIGxlbmd0aCk7XG4gICAgfVxuICAgIHZhbHVlKGFzUmF3KSB7XG4gICAgICAgIGFzUmF3ID0gISFhc1JhdztcbiAgICAgICAgaWYgKGFzUmF3ICYmIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gdGhpcy5wb3NpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhc1Jhdykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNsaWNlKDAsIHRoaXMucG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCeXRlVXRpbHMudG9JU084ODU5MSh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLnBvc2l0aW9uKSk7XG4gICAgfVxuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb247XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy50b0Jhc2U2NCh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHRvU3RyaW5nKGVuY29kaW5nKSB7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2hleCcpXG4gICAgICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLnRvSGV4KHRoaXMuYnVmZmVyKTtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0JylcbiAgICAgICAgICAgIHJldHVybiBCeXRlVXRpbHMudG9CYXNlNjQodGhpcy5idWZmZXIpO1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICd1dGY4JyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi04JylcbiAgICAgICAgICAgIHJldHVybiBCeXRlVXRpbHMudG9VVEY4KHRoaXMuYnVmZmVyLCAwLCB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy50b1VURjgodGhpcy5idWZmZXIsIDAsIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBjb25zdCBiYXNlNjRTdHJpbmcgPSBCeXRlVXRpbHMudG9CYXNlNjQodGhpcy5idWZmZXIpO1xuICAgICAgICBjb25zdCBzdWJUeXBlID0gTnVtYmVyKHRoaXMuc3ViX3R5cGUpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKG9wdGlvbnMubGVnYWN5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICRiaW5hcnk6IGJhc2U2NFN0cmluZyxcbiAgICAgICAgICAgICAgICAkdHlwZTogc3ViVHlwZS5sZW5ndGggPT09IDEgPyAnMCcgKyBzdWJUeXBlIDogc3ViVHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJGJpbmFyeToge1xuICAgICAgICAgICAgICAgIGJhc2U2NDogYmFzZTY0U3RyaW5nLFxuICAgICAgICAgICAgICAgIHN1YlR5cGU6IHN1YlR5cGUubGVuZ3RoID09PSAxID8gJzAnICsgc3ViVHlwZSA6IHN1YlR5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9VVUlEKCkge1xuICAgICAgICBpZiAodGhpcy5zdWJfdHlwZSA9PT0gQmluYXJ5LlNVQlRZUEVfVVVJRCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVVUlEKHRoaXMuYnVmZmVyLnNsaWNlKDAsIHRoaXMucG9zaXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBCaW5hcnkgc3ViX3R5cGUgXCIke3RoaXMuc3ViX3R5cGV9XCIgaXMgbm90IHN1cHBvcnRlZCBmb3IgY29udmVydGluZyB0byBVVUlELiBPbmx5IFwiJHtCaW5hcnkuU1VCVFlQRV9VVUlEfVwiIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuYCk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSGV4U3RyaW5nKGhleCwgc3ViVHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeShCeXRlVXRpbHMuZnJvbUhleChoZXgpLCBzdWJUeXBlKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21CYXNlNjQoYmFzZTY0LCBzdWJUeXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5KEJ5dGVVdGlscy5mcm9tQmFzZTY0KGJhc2U2NCksIHN1YlR5cGUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgaWYgKCckYmluYXJ5JyBpbiBkb2MpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxlZ2FjeSAmJiB0eXBlb2YgZG9jLiRiaW5hcnkgPT09ICdzdHJpbmcnICYmICckdHlwZScgaW4gZG9jKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGRvYy4kdHlwZSA/IHBhcnNlSW50KGRvYy4kdHlwZSwgMTYpIDogMDtcbiAgICAgICAgICAgICAgICBkYXRhID0gQnl0ZVV0aWxzLmZyb21CYXNlNjQoZG9jLiRiaW5hcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2MuJGJpbmFyeSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGRvYy4kYmluYXJ5LnN1YlR5cGUgPyBwYXJzZUludChkb2MuJGJpbmFyeS5zdWJUeXBlLCAxNikgOiAwO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gQnl0ZVV0aWxzLmZyb21CYXNlNjQoZG9jLiRiaW5hcnkuYmFzZTY0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJyR1dWlkJyBpbiBkb2MpIHtcbiAgICAgICAgICAgIHR5cGUgPSA0O1xuICAgICAgICAgICAgZGF0YSA9IFVVSUQuYnl0ZXNGcm9tU3RyaW5nKGRvYy4kdXVpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBVbmV4cGVjdGVkIEJpbmFyeSBFeHRlbmRlZCBKU09OIGZvcm1hdCAke0pTT04uc3RyaW5naWZ5KGRvYyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IEJTT05fQklOQVJZX1NVQlRZUEVfVVVJRF9ORVcgPyBuZXcgVVVJRChkYXRhKSA6IG5ldyBCaW5hcnkoZGF0YSwgdHlwZSk7XG4gICAgfVxuICAgIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpO1xuICAgIH1cbiAgICBpbnNwZWN0KCkge1xuICAgICAgICBjb25zdCBiYXNlNjQgPSBCeXRlVXRpbHMudG9CYXNlNjQodGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgdGhpcy5wb3NpdGlvbikpO1xuICAgICAgICByZXR1cm4gYEJpbmFyeS5jcmVhdGVGcm9tQmFzZTY0KFwiJHtiYXNlNjR9XCIsICR7dGhpcy5zdWJfdHlwZX0pYDtcbiAgICB9XG59XG5CaW5hcnkuQlNPTl9CSU5BUllfU1VCVFlQRV9ERUZBVUxUID0gMDtcbkJpbmFyeS5CVUZGRVJfU0laRSA9IDI1NjtcbkJpbmFyeS5TVUJUWVBFX0RFRkFVTFQgPSAwO1xuQmluYXJ5LlNVQlRZUEVfRlVOQ1RJT04gPSAxO1xuQmluYXJ5LlNVQlRZUEVfQllURV9BUlJBWSA9IDI7XG5CaW5hcnkuU1VCVFlQRV9VVUlEX09MRCA9IDM7XG5CaW5hcnkuU1VCVFlQRV9VVUlEID0gNDtcbkJpbmFyeS5TVUJUWVBFX01ENSA9IDU7XG5CaW5hcnkuU1VCVFlQRV9FTkNSWVBURUQgPSA2O1xuQmluYXJ5LlNVQlRZUEVfQ09MVU1OID0gNztcbkJpbmFyeS5TVUJUWVBFX1VTRVJfREVGSU5FRCA9IDEyODtcbmNvbnN0IFVVSURfQllURV9MRU5HVEggPSAxNjtcbmNvbnN0IFVVSURfV0lUSE9VVF9EQVNIRVMgPSAvXlswLTlBLUZdezMyfSQvaTtcbmNvbnN0IFVVSURfV0lUSF9EQVNIRVMgPSAvXlswLTlBLUZdezh9LVswLTlBLUZdezR9LVswLTlBLUZdezR9LVswLTlBLUZdezR9LVswLTlBLUZdezEyfSQvaTtcbmNsYXNzIFVVSUQgZXh0ZW5kcyBCaW5hcnkge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIGxldCBieXRlcztcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gVVVJRC5nZW5lcmF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgVVVJRCkge1xuICAgICAgICAgICAgYnl0ZXMgPSBCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUobmV3IFVpbnQ4QXJyYXkoaW5wdXQuYnVmZmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGlucHV0KSAmJiBpbnB1dC5ieXRlTGVuZ3RoID09PSBVVUlEX0JZVEVfTEVOR1RIKSB7XG4gICAgICAgICAgICBieXRlcyA9IEJ5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYnl0ZXMgPSBVVUlELmJ5dGVzRnJvbVN0cmluZyhpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdBcmd1bWVudCBwYXNzZWQgaW4gVVVJRCBjb25zdHJ1Y3RvciBtdXN0IGJlIGEgVVVJRCwgYSAxNiBieXRlIEJ1ZmZlciBvciBhIDMyLzM2IGNoYXJhY3RlciBoZXggc3RyaW5nIChkYXNoZXMgZXhjbHVkZWQvaW5jbHVkZWQsIGZvcm1hdDogeHh4eHh4eHgteHh4eC14eHh4LXh4eHgteHh4eHh4eHh4eHh4KS4nKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihieXRlcywgQlNPTl9CSU5BUllfU1VCVFlQRV9VVUlEX05FVyk7XG4gICAgfVxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xuICAgIH1cbiAgICBzZXQgaWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSB2YWx1ZTtcbiAgICB9XG4gICAgdG9IZXhTdHJpbmcoaW5jbHVkZURhc2hlcyA9IHRydWUpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVEYXNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnRvSGV4KHRoaXMuYnVmZmVyLnN1YmFycmF5KDAsIDQpKSxcbiAgICAgICAgICAgICAgICBCeXRlVXRpbHMudG9IZXgodGhpcy5idWZmZXIuc3ViYXJyYXkoNCwgNikpLFxuICAgICAgICAgICAgICAgIEJ5dGVVdGlscy50b0hleCh0aGlzLmJ1ZmZlci5zdWJhcnJheSg2LCA4KSksXG4gICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnRvSGV4KHRoaXMuYnVmZmVyLnN1YmFycmF5KDgsIDEwKSksXG4gICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnRvSGV4KHRoaXMuYnVmZmVyLnN1YmFycmF5KDEwLCAxNikpXG4gICAgICAgICAgICBdLmpvaW4oJy0nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLnRvSGV4KHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnaGV4JylcbiAgICAgICAgICAgIHJldHVybiBCeXRlVXRpbHMudG9IZXgodGhpcy5pZCk7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpXG4gICAgICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLnRvQmFzZTY0KHRoaXMuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcy50b0hleFN0cmluZygpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcklkKSB7XG4gICAgICAgIGlmICghb3RoZXJJZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlcklkIGluc3RhbmNlb2YgVVVJRCkge1xuICAgICAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy5lcXVhbHMob3RoZXJJZC5pZCwgdGhpcy5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBCeXRlVXRpbHMuZXF1YWxzKG5ldyBVVUlEKG90aGVySWQpLmlkLCB0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9CaW5hcnkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5KHRoaXMuaWQsIEJpbmFyeS5TVUJUWVBFX1VVSUQpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2VuZXJhdGUoKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gQnl0ZVV0aWxzLnJhbmRvbUJ5dGVzKFVVSURfQllURV9MRU5HVEgpO1xuICAgICAgICBieXRlc1s2XSA9IChieXRlc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgICAgICAgYnl0ZXNbOF0gPSAoYnl0ZXNbOF0gJiAweDNmKSB8IDB4ODA7XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gICAgc3RhdGljIGlzVmFsaWQoaW5wdXQpIHtcbiAgICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gVVVJRC5pc1ZhbGlkVVVJRFN0cmluZyhpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVWludDhBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5ieXRlTGVuZ3RoID09PSBVVUlEX0JZVEVfTEVOR1RIO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoaW5wdXQuX2Jzb250eXBlID09PSAnQmluYXJ5JyAmJlxuICAgICAgICAgICAgaW5wdXQuc3ViX3R5cGUgPT09IHRoaXMuU1VCVFlQRV9VVUlEICYmXG4gICAgICAgICAgICBpbnB1dC5idWZmZXIuYnl0ZUxlbmd0aCA9PT0gMTYpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRnJvbUhleFN0cmluZyhoZXhTdHJpbmcpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gVVVJRC5ieXRlc0Zyb21TdHJpbmcoaGV4U3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVVUlEKGJ1ZmZlcik7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tQmFzZTY0KGJhc2U2NCkge1xuICAgICAgICByZXR1cm4gbmV3IFVVSUQoQnl0ZVV0aWxzLmZyb21CYXNlNjQoYmFzZTY0KSk7XG4gICAgfVxuICAgIHN0YXRpYyBieXRlc0Zyb21TdHJpbmcocmVwcmVzZW50YXRpb24pIHtcbiAgICAgICAgaWYgKCFVVUlELmlzVmFsaWRVVUlEU3RyaW5nKHJlcHJlc2VudGF0aW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVVVJRCBzdHJpbmcgcmVwcmVzZW50YXRpb24gbXVzdCBiZSAzMiBoZXggZGlnaXRzIG9yIGNhbm9uaWNhbCBoeXBoZW5hdGVkIHJlcHJlc2VudGF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy5mcm9tSGV4KHJlcHJlc2VudGF0aW9uLnJlcGxhY2UoLy0vZywgJycpKTtcbiAgICB9XG4gICAgc3RhdGljIGlzVmFsaWRVVUlEU3RyaW5nKHJlcHJlc2VudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBVVUlEX1dJVEhPVVRfREFTSEVTLnRlc3QocmVwcmVzZW50YXRpb24pIHx8IFVVSURfV0lUSF9EQVNIRVMudGVzdChyZXByZXNlbnRhdGlvbik7XG4gICAgfVxuICAgIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpO1xuICAgIH1cbiAgICBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4gYG5ldyBVVUlEKFwiJHt0aGlzLnRvSGV4U3RyaW5nKCl9XCIpYDtcbiAgICB9XG59XG5VVUlELmNhY2hlSGV4U3RyaW5nID0gZmFsc2U7XG5cbmNsYXNzIENvZGUgZXh0ZW5kcyBCU09OVmFsdWUge1xuICAgIGdldCBfYnNvbnR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnQ29kZSc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGNvZGUsIHNjb3BlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGUudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlID8/IG51bGw7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY29kZTogdGhpcy5jb2RlLCBzY29wZTogdGhpcy5zY29wZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNvZGU6IHRoaXMuY29kZSB9O1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7ICRjb2RlOiB0aGlzLmNvZGUsICRzY29wZTogdGhpcy5zY29wZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICRjb2RlOiB0aGlzLmNvZGUgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29kZShkb2MuJGNvZGUsIGRvYy4kc2NvcGUpO1xuICAgIH1cbiAgICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3BlY3QoKTtcbiAgICB9XG4gICAgaW5zcGVjdCgpIHtcbiAgICAgICAgY29uc3QgY29kZUpzb24gPSB0aGlzLnRvSlNPTigpO1xuICAgICAgICByZXR1cm4gYG5ldyBDb2RlKFwiJHtTdHJpbmcoY29kZUpzb24uY29kZSl9XCIke2NvZGVKc29uLnNjb3BlICE9IG51bGwgPyBgLCAke0pTT04uc3RyaW5naWZ5KGNvZGVKc29uLnNjb3BlKX1gIDogJyd9KWA7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0RCUmVmTGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICckaWQnIGluIHZhbHVlICYmXG4gICAgICAgIHZhbHVlLiRpZCAhPSBudWxsICYmXG4gICAgICAgICckcmVmJyBpbiB2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUuJHJlZiA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgKCEoJyRkYicgaW4gdmFsdWUpIHx8ICgnJGRiJyBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuJGRiID09PSAnc3RyaW5nJykpKTtcbn1cbmNsYXNzIERCUmVmIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0RCUmVmJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoY29sbGVjdGlvbiwgb2lkLCBkYiwgZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gY29sbGVjdGlvbi5zcGxpdCgnLicpO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBkYiA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgICAgICB0aGlzLm9pZCA9IG9pZDtcbiAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcyB8fCB7fTtcbiAgICB9XG4gICAgZ2V0IG5hbWVzcGFjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbjtcbiAgICB9XG4gICAgc2V0IG5hbWVzcGFjZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb24gPSB2YWx1ZTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBvID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAkcmVmOiB0aGlzLmNvbGxlY3Rpb24sXG4gICAgICAgICAgICAkaWQ6IHRoaXMub2lkXG4gICAgICAgIH0sIHRoaXMuZmllbGRzKTtcbiAgICAgICAgaWYgKHRoaXMuZGIgIT0gbnVsbClcbiAgICAgICAgICAgIG8uJGRiID0gdGhpcy5kYjtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGxldCBvID0ge1xuICAgICAgICAgICAgJHJlZjogdGhpcy5jb2xsZWN0aW9uLFxuICAgICAgICAgICAgJGlkOiB0aGlzLm9pZFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5sZWdhY3kpIHtcbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRiKVxuICAgICAgICAgICAgby4kZGIgPSB0aGlzLmRiO1xuICAgICAgICBvID0gT2JqZWN0LmFzc2lnbihvLCB0aGlzLmZpZWxkcyk7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MpIHtcbiAgICAgICAgY29uc3QgY29weSA9IE9iamVjdC5hc3NpZ24oe30sIGRvYyk7XG4gICAgICAgIGRlbGV0ZSBjb3B5LiRyZWY7XG4gICAgICAgIGRlbGV0ZSBjb3B5LiRpZDtcbiAgICAgICAgZGVsZXRlIGNvcHkuJGRiO1xuICAgICAgICByZXR1cm4gbmV3IERCUmVmKGRvYy4kcmVmLCBkb2MuJGlkLCBkb2MuJGRiLCBjb3B5KTtcbiAgICB9XG4gICAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCk7XG4gICAgfVxuICAgIGluc3BlY3QoKSB7XG4gICAgICAgIGNvbnN0IG9pZCA9IHRoaXMub2lkID09PSB1bmRlZmluZWQgfHwgdGhpcy5vaWQudG9TdHJpbmcgPT09IHVuZGVmaW5lZCA/IHRoaXMub2lkIDogdGhpcy5vaWQudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIGBuZXcgREJSZWYoXCIke3RoaXMubmFtZXNwYWNlfVwiLCBuZXcgT2JqZWN0SWQoXCIke1N0cmluZyhvaWQpfVwiKSR7dGhpcy5kYiA/IGAsIFwiJHt0aGlzLmRifVwiYCA6ICcnfSlgO1xuICAgIH1cbn1cblxubGV0IHdhc20gPSB1bmRlZmluZWQ7XG50cnkge1xuICAgIHdhc20gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCAxMywgMiwgOTYsIDAsIDEsIDEyNywgOTYsIDQsIDEyNywgMTI3LCAxMjcsIDEyNywgMSwgMTI3LCAzLCA3LCA2LCAwLCAxLCAxLCAxLCAxLCAxLCA2LCA2LCAxLCAxMjcsIDEsIDY1LCAwLCAxMSwgNywgNTAsIDYsIDMsIDEwOSwgMTE3LCAxMDgsIDAsIDEsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTUsIDAsIDIsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTcsIDAsIDMsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTUsIDAsIDQsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTcsIDAsIDUsIDgsIDEwMywgMTAxLCAxMTYsIDk1LCAxMDQsIDEwNSwgMTAzLCAxMDQsIDAsIDAsIDEwLCAxOTEsIDEsIDYsIDQsIDAsIDM1LCAwLCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI2LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjcsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI5LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMzAsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTFdKSksIHt9KS5leHBvcnRzO1xufVxuY2F0Y2gge1xufVxuY29uc3QgVFdPX1BXUl8xNl9EQkwgPSAxIDw8IDE2O1xuY29uc3QgVFdPX1BXUl8yNF9EQkwgPSAxIDw8IDI0O1xuY29uc3QgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xuY29uc3QgVFdPX1BXUl82NF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMzJfREJMO1xuY29uc3QgVFdPX1BXUl82M19EQkwgPSBUV09fUFdSXzY0X0RCTCAvIDI7XG5jb25zdCBJTlRfQ0FDSEUgPSB7fTtcbmNvbnN0IFVJTlRfQ0FDSEUgPSB7fTtcbmNvbnN0IE1BWF9JTlQ2NF9TVFJJTkdfTEVOR1RIID0gMjA7XG5jb25zdCBERUNJTUFMX1JFR19FWCA9IC9eKFxcKz8wfChcXCt8LSk/WzEtOV1bMC05XSopJC87XG5jbGFzcyBMb25nIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0xvbmcnO1xuICAgIH1cbiAgICBnZXQgX19pc0xvbmdfXygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGxvdyA9IDAsIGhpZ2gsIHVuc2lnbmVkKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICh0eXBlb2YgbG93ID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBMb25nLmZyb21CaWdJbnQobG93LCAhIWhpZ2gpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbG93ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBMb25nLmZyb21TdHJpbmcobG93LCAhIWhpZ2gpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG93ID0gbG93IHwgMDtcbiAgICAgICAgICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwO1xuICAgICAgICAgICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCkge1xuICAgICAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7XG4gICAgICAgIGxldCBvYmosIGNhY2hlZE9iaiwgY2FjaGU7XG4gICAgICAgIGlmICh1bnNpZ25lZCkge1xuICAgICAgICAgICAgdmFsdWUgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKChjYWNoZSA9IDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iaiA9IExvbmcuZnJvbUJpdHModmFsdWUsICh2YWx1ZSB8IDApIDwgMCA/IC0xIDogMCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoY2FjaGUpXG4gICAgICAgICAgICAgICAgVUlOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgfD0gMDtcbiAgICAgICAgICAgIGlmICgoY2FjaGUgPSAtMTI4IDw9IHZhbHVlICYmIHZhbHVlIDwgMTI4KSkge1xuICAgICAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iaiA9IExvbmcuZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGNhY2hlKVxuICAgICAgICAgICAgICAgIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCkge1xuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIHVuc2lnbmVkID8gTG9uZy5VWkVSTyA6IExvbmcuWkVSTztcbiAgICAgICAgaWYgKHVuc2lnbmVkKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLlVaRVJPO1xuICAgICAgICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLk1BWF9VTlNJR05FRF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuTUlOX1ZBTFVFO1xuICAgICAgICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTClcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5NQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgMClcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwgfCAwLCAodmFsdWUgLyBUV09fUFdSXzMyX0RCTCkgfCAwLCB1bnNpZ25lZCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmlnSW50KHZhbHVlLCB1bnNpZ25lZCkge1xuICAgICAgICByZXR1cm4gTG9uZy5mcm9tU3RyaW5nKHZhbHVlLnRvU3RyaW5nKCksIHVuc2lnbmVkKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcoc3RyLCB1bnNpZ25lZCwgcmFkaXgpIHtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdlbXB0eSBzdHJpbmcnKTtcbiAgICAgICAgaWYgKHN0ciA9PT0gJ05hTicgfHwgc3RyID09PSAnSW5maW5pdHknIHx8IHN0ciA9PT0gJytJbmZpbml0eScgfHwgc3RyID09PSAnLUluZmluaXR5JylcbiAgICAgICAgICAgIHJldHVybiBMb25nLlpFUk87XG4gICAgICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAocmFkaXggPSB1bnNpZ25lZCksICh1bnNpZ25lZCA9IGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVuc2lnbmVkID0gISF1bnNpZ25lZDtcbiAgICAgICAgfVxuICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xuICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdyYWRpeCcpO1xuICAgICAgICBsZXQgcDtcbiAgICAgICAgaWYgKChwID0gc3RyLmluZGV4T2YoJy0nKSkgPiAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignaW50ZXJpb3IgaHlwaGVuJyk7XG4gICAgICAgIGVsc2UgaWYgKHAgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYWRpeFRvUG93ZXIgPSBMb25nLmZyb21OdW1iZXIoTWF0aC5wb3cocmFkaXgsIDgpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IExvbmcuWkVSTztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcbiAgICAgICAgICAgIGlmIChzaXplIDwgOCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvd2VyID0gTG9uZy5mcm9tTnVtYmVyKE1hdGgucG93KHJhZGl4LCBzaXplKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKExvbmcuZnJvbU51bWJlcih2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChyYWRpeFRvUG93ZXIpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoTG9uZy5mcm9tTnVtYmVyKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnVuc2lnbmVkID0gdW5zaWduZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZXMsIHVuc2lnbmVkLCBsZSkge1xuICAgICAgICByZXR1cm4gbGUgPyBMb25nLmZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkgOiBMb25nLmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb25nKGJ5dGVzWzBdIHwgKGJ5dGVzWzFdIDw8IDgpIHwgKGJ5dGVzWzJdIDw8IDE2KSB8IChieXRlc1szXSA8PCAyNCksIGJ5dGVzWzRdIHwgKGJ5dGVzWzVdIDw8IDgpIHwgKGJ5dGVzWzZdIDw8IDE2KSB8IChieXRlc1s3XSA8PCAyNCksIHVuc2lnbmVkKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCkge1xuICAgICAgICByZXR1cm4gbmV3IExvbmcoKGJ5dGVzWzRdIDw8IDI0KSB8IChieXRlc1s1XSA8PCAxNikgfCAoYnl0ZXNbNl0gPDwgOCkgfCBieXRlc1s3XSwgKGJ5dGVzWzBdIDw8IDI0KSB8IChieXRlc1sxXSA8PCAxNikgfCAoYnl0ZXNbMl0gPDwgOCkgfCBieXRlc1szXSwgdW5zaWduZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNMb25nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ19faXNMb25nX18nIGluIHZhbHVlICYmXG4gICAgICAgICAgICB2YWx1ZS5fX2lzTG9uZ19fID09PSB0cnVlKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21OdW1iZXIodmFsLCB1bnNpZ25lZCk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICdib29sZWFuJyA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgYWRkKGFkZGVuZCkge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKGFkZGVuZCkpXG4gICAgICAgICAgICBhZGRlbmQgPSBMb25nLmZyb21WYWx1ZShhZGRlbmQpO1xuICAgICAgICBjb25zdCBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xuICAgICAgICBjb25zdCBhMzIgPSB0aGlzLmhpZ2ggJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGExNiA9IHRoaXMubG93ID4+PiAxNjtcbiAgICAgICAgY29uc3QgYTAwID0gdGhpcy5sb3cgJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjtcbiAgICAgICAgY29uc3QgYjMyID0gYWRkZW5kLmhpZ2ggJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGIxNiA9IGFkZGVuZC5sb3cgPj4+IDE2O1xuICAgICAgICBjb25zdCBiMDAgPSBhZGRlbmQubG93ICYgMHhmZmZmO1xuICAgICAgICBsZXQgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcbiAgICAgICAgYzAwICs9IGEwMCArIGIwMDtcbiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7XG4gICAgICAgIGMwMCAmPSAweGZmZmY7XG4gICAgICAgIGMxNiArPSBhMTYgKyBiMTY7XG4gICAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xuICAgICAgICBjMTYgJj0gMHhmZmZmO1xuICAgICAgICBjMzIgKz0gYTMyICsgYjMyO1xuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICAgICAgYzMyICY9IDB4ZmZmZjtcbiAgICAgICAgYzQ4ICs9IGE0OCArIGI0ODtcbiAgICAgICAgYzQ4ICY9IDB4ZmZmZjtcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgYW5kKG90aGVyKSB7XG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcob3RoZXIpKVxuICAgICAgICAgICAgb3RoZXIgPSBMb25nLmZyb21WYWx1ZShvdGhlcik7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHRoaXMubG93ICYgb3RoZXIubG93LCB0aGlzLmhpZ2ggJiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgY29tcGFyZShvdGhlcikge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKG90aGVyKSlcbiAgICAgICAgICAgIG90aGVyID0gTG9uZy5mcm9tVmFsdWUob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy5lcShvdGhlcikpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgY29uc3QgdGhpc05lZyA9IHRoaXMuaXNOZWdhdGl2ZSgpLCBvdGhlck5lZyA9IG90aGVyLmlzTmVnYXRpdmUoKTtcbiAgICAgICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViKG90aGVyKS5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7XG4gICAgICAgIHJldHVybiBvdGhlci5oaWdoID4+PiAwID4gdGhpcy5oaWdoID4+PiAwIHx8XG4gICAgICAgICAgICAob3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIG90aGVyLmxvdyA+Pj4gMCA+IHRoaXMubG93ID4+PiAwKVxuICAgICAgICAgICAgPyAtMVxuICAgICAgICAgICAgOiAxO1xuICAgIH1cbiAgICBjb21wKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUob3RoZXIpO1xuICAgIH1cbiAgICBkaXZpZGUoZGl2aXNvcikge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKGRpdmlzb3IpKVxuICAgICAgICAgICAgZGl2aXNvciA9IExvbmcuZnJvbVZhbHVlKGRpdmlzb3IpO1xuICAgICAgICBpZiAoZGl2aXNvci5pc1plcm8oKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKTtcbiAgICAgICAgaWYgKHdhc20pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaGlnaCA9PT0gLTB4ODAwMDAwMDAgJiZcbiAgICAgICAgICAgICAgICBkaXZpc29yLmxvdyA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICBkaXZpc29yLmhpZ2ggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20uZGl2X3UgOiB3YXNtLmRpdl9zKSh0aGlzLmxvdywgdGhpcy5oaWdoLCBkaXZpc29yLmxvdywgZGl2aXNvci5oaWdoKTtcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gTG9uZy5VWkVSTyA6IExvbmcuWkVSTztcbiAgICAgICAgbGV0IGFwcHJveCwgcmVtLCByZXM7XG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXEoTG9uZy5NSU5fVkFMVUUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpdmlzb3IuZXEoTG9uZy5PTkUpIHx8IGRpdmlzb3IuZXEoTG9uZy5ORUdfT05FKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuTUlOX1ZBTFVFO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTG9uZy5NSU5fVkFMVUUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5PTkU7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbGZUaGlzID0gdGhpcy5zaHIoMSk7XG4gICAgICAgICAgICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcHByb3guZXEoTG9uZy5aRVJPKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gTG9uZy5PTkUgOiBMb25nLk5FR19PTkU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW0gPSB0aGlzLnN1YihkaXZpc29yLm11bChhcHByb3gpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdihkaXZpc29yKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShMb25nLk1JTl9WQUxVRSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBMb25nLlVaRVJPIDogTG9uZy5aRVJPO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvci5uZWcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IpLm5lZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpO1xuICAgICAgICAgICAgcmVzID0gTG9uZy5aRVJPO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFkaXZpc29yLnVuc2lnbmVkKVxuICAgICAgICAgICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTtcbiAgICAgICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLlVaRVJPO1xuICAgICAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcy5zaHJ1KDEpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5VT05FO1xuICAgICAgICAgICAgcmVzID0gTG9uZy5VWkVSTztcbiAgICAgICAgfVxuICAgICAgICByZW0gPSB0aGlzO1xuICAgICAgICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkge1xuICAgICAgICAgICAgYXBwcm94ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyZW0udG9OdW1iZXIoKSAvIGRpdmlzb3IudG9OdW1iZXIoKSkpO1xuICAgICAgICAgICAgY29uc3QgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpO1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBsb2cyIDw9IDQ4ID8gMSA6IE1hdGgucG93KDIsIGxvZzIgLSA0OCk7XG4gICAgICAgICAgICBsZXQgYXBwcm94UmVzID0gTG9uZy5mcm9tTnVtYmVyKGFwcHJveCk7XG4gICAgICAgICAgICBsZXQgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcbiAgICAgICAgICAgIHdoaWxlIChhcHByb3hSZW0uaXNOZWdhdGl2ZSgpIHx8IGFwcHJveFJlbS5ndChyZW0pKSB7XG4gICAgICAgICAgICAgICAgYXBwcm94IC09IGRlbHRhO1xuICAgICAgICAgICAgICAgIGFwcHJveFJlcyA9IExvbmcuZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpO1xuICAgICAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXBwcm94UmVzLmlzWmVybygpKVxuICAgICAgICAgICAgICAgIGFwcHJveFJlcyA9IExvbmcuT05FO1xuICAgICAgICAgICAgcmVzID0gcmVzLmFkZChhcHByb3hSZXMpO1xuICAgICAgICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGRpdihkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZShkaXZpc29yKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcob3RoZXIpKVxuICAgICAgICAgICAgb3RoZXIgPSBMb25nLmZyb21WYWx1ZShvdGhlcik7XG4gICAgICAgIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPj4+IDMxID09PSAxICYmIG90aGVyLmhpZ2ggPj4+IDMxID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhvdGhlcik7XG4gICAgfVxuICAgIGdldEhpZ2hCaXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oaWdoO1xuICAgIH1cbiAgICBnZXRIaWdoQml0c1Vuc2lnbmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID4+PiAwO1xuICAgIH1cbiAgICBnZXRMb3dCaXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb3c7XG4gICAgfVxuICAgIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG93ID4+PiAwO1xuICAgIH1cbiAgICBnZXROdW1CaXRzQWJzKCkge1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxKExvbmcuTUlOX1ZBTFVFKSA/IDY0IDogdGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsID0gdGhpcy5oaWdoICE9PSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7XG4gICAgICAgIGxldCBiaXQ7XG4gICAgICAgIGZvciAoYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKVxuICAgICAgICAgICAgaWYgKCh2YWwgJiAoMSA8PCBiaXQpKSAhPT0gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAhPT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcbiAgICB9XG4gICAgZ3JlYXRlclRoYW4ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPiAwO1xuICAgIH1cbiAgICBndChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmVhdGVyVGhhbihvdGhlcik7XG4gICAgfVxuICAgIGdyZWF0ZXJUaGFuT3JFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA+PSAwO1xuICAgIH1cbiAgICBndGUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKTtcbiAgICB9XG4gICAgZ2Uob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKTtcbiAgICB9XG4gICAgaXNFdmVuKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDA7XG4gICAgfVxuICAgIGlzTmVnYXRpdmUoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPCAwO1xuICAgIH1cbiAgICBpc09kZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAxO1xuICAgIH1cbiAgICBpc1Bvc2l0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDtcbiAgICB9XG4gICAgaXNaZXJvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xuICAgIH1cbiAgICBsZXNzVGhhbihvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA8IDA7XG4gICAgfVxuICAgIGx0KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlc3NUaGFuKG90aGVyKTtcbiAgICB9XG4gICAgbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpIDw9IDA7XG4gICAgfVxuICAgIGx0ZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5sZXNzVGhhbk9yRXF1YWwob3RoZXIpO1xuICAgIH1cbiAgICBtb2R1bG8oZGl2aXNvcikge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKGRpdmlzb3IpKVxuICAgICAgICAgICAgZGl2aXNvciA9IExvbmcuZnJvbVZhbHVlKGRpdmlzb3IpO1xuICAgICAgICBpZiAod2FzbSkge1xuICAgICAgICAgICAgY29uc3QgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtLnJlbV91IDogd2FzbS5yZW1fcykodGhpcy5sb3csIHRoaXMuaGlnaCwgZGl2aXNvci5sb3csIGRpdmlzb3IuaGlnaCk7XG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XG4gICAgfVxuICAgIG1vZChkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZHVsbyhkaXZpc29yKTtcbiAgICB9XG4gICAgcmVtKGRpdmlzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kdWxvKGRpdmlzb3IpO1xuICAgIH1cbiAgICBtdWx0aXBseShtdWx0aXBsaWVyKSB7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybygpKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuWkVSTztcbiAgICAgICAgaWYgKCFMb25nLmlzTG9uZyhtdWx0aXBsaWVyKSlcbiAgICAgICAgICAgIG11bHRpcGxpZXIgPSBMb25nLmZyb21WYWx1ZShtdWx0aXBsaWVyKTtcbiAgICAgICAgaWYgKHdhc20pIHtcbiAgICAgICAgICAgIGNvbnN0IGxvdyA9IHdhc20ubXVsKHRoaXMubG93LCB0aGlzLmhpZ2gsIG11bHRpcGxpZXIubG93LCBtdWx0aXBsaWVyLmhpZ2gpO1xuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtdWx0aXBsaWVyLmlzWmVybygpKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuWkVSTztcbiAgICAgICAgaWYgKHRoaXMuZXEoTG9uZy5NSU5fVkFMVUUpKVxuICAgICAgICAgICAgcmV0dXJuIG11bHRpcGxpZXIuaXNPZGQoKSA/IExvbmcuTUlOX1ZBTFVFIDogTG9uZy5aRVJPO1xuICAgICAgICBpZiAobXVsdGlwbGllci5lcShMb25nLk1JTl9WQUxVRSkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc09kZCgpID8gTG9uZy5NSU5fVkFMVUUgOiBMb25nLlpFUk87XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7XG4gICAgICAgIGlmICh0aGlzLmx0KExvbmcuVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChMb25nLlRXT19QV1JfMjQpKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpO1xuICAgICAgICBjb25zdCBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xuICAgICAgICBjb25zdCBhMzIgPSB0aGlzLmhpZ2ggJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGExNiA9IHRoaXMubG93ID4+PiAxNjtcbiAgICAgICAgY29uc3QgYTAwID0gdGhpcy5sb3cgJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7XG4gICAgICAgIGNvbnN0IGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xuICAgICAgICBjb25zdCBiMDAgPSBtdWx0aXBsaWVyLmxvdyAmIDB4ZmZmZjtcbiAgICAgICAgbGV0IGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XG4gICAgICAgIGMwMCArPSBhMDAgKiBiMDA7XG4gICAgICAgIGMxNiArPSBjMDAgPj4+IDE2O1xuICAgICAgICBjMDAgJj0gMHhmZmZmO1xuICAgICAgICBjMTYgKz0gYTE2ICogYjAwO1xuICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICAgICAgYzE2ICY9IDB4ZmZmZjtcbiAgICAgICAgYzE2ICs9IGEwMCAqIGIxNjtcbiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XG4gICAgICAgIGMxNiAmPSAweGZmZmY7XG4gICAgICAgIGMzMiArPSBhMzIgKiBiMDA7XG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgICAgICBjMzIgJj0gMHhmZmZmO1xuICAgICAgICBjMzIgKz0gYTE2ICogYjE2O1xuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICAgICAgYzMyICY9IDB4ZmZmZjtcbiAgICAgICAgYzMyICs9IGEwMCAqIGIzMjtcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgICAgIGMzMiAmPSAweGZmZmY7XG4gICAgICAgIGM0OCArPSBhNDggKiBiMDAgKyBhMzIgKiBiMTYgKyBhMTYgKiBiMzIgKyBhMDAgKiBiNDg7XG4gICAgICAgIGM0OCAmPSAweGZmZmY7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICAgIG11bChtdWx0aXBsaWVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KG11bHRpcGxpZXIpO1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxKExvbmcuTUlOX1ZBTFVFKSlcbiAgICAgICAgICAgIHJldHVybiBMb25nLk1JTl9WQUxVRTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm90KCkuYWRkKExvbmcuT05FKTtcbiAgICB9XG4gICAgbmVnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGUoKTtcbiAgICB9XG4gICAgbm90KCkge1xuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgICBub3RFcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmVxdWFscyhvdGhlcik7XG4gICAgfVxuICAgIG5lcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3RFcXVhbHMob3RoZXIpO1xuICAgIH1cbiAgICBuZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3RFcXVhbHMob3RoZXIpO1xuICAgIH1cbiAgICBvcihvdGhlcikge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKG90aGVyKSlcbiAgICAgICAgICAgIG90aGVyID0gTG9uZy5mcm9tVmFsdWUob3RoZXIpO1xuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh0aGlzLmxvdyB8IG90aGVyLmxvdywgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICAgIHNoaWZ0TGVmdChudW1CaXRzKSB7XG4gICAgICAgIGlmIChMb25nLmlzTG9uZyhudW1CaXRzKSlcbiAgICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbnVtQml0cykpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgKG51bUJpdHMgLSAzMiksIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgICBzaGwobnVtQml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGlmdExlZnQobnVtQml0cyk7XG4gICAgfVxuICAgIHNoaWZ0UmlnaHQobnVtQml0cykge1xuICAgICAgICBpZiAoTG9uZy5pc0xvbmcobnVtQml0cykpXG4gICAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgICAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKCh0aGlzLmxvdyA+Pj4gbnVtQml0cykgfCAodGhpcy5oaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgdGhpcy5oaWdoID4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh0aGlzLmhpZ2ggPj4gKG51bUJpdHMgLSAzMiksIHRoaXMuaGlnaCA+PSAwID8gMCA6IC0xLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgc2hyKG51bUJpdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hpZnRSaWdodChudW1CaXRzKTtcbiAgICB9XG4gICAgc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHtcbiAgICAgICAgaWYgKExvbmcuaXNMb25nKG51bUJpdHMpKVxuICAgICAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICAgICAgbnVtQml0cyAmPSA2MztcbiAgICAgICAgaWYgKG51bUJpdHMgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBoaWdoID0gdGhpcy5oaWdoO1xuICAgICAgICAgICAgaWYgKG51bUJpdHMgPCAzMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvdyA9IHRoaXMubG93O1xuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKChsb3cgPj4+IG51bUJpdHMpIHwgKGhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCBoaWdoID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG51bUJpdHMgPT09IDMyKVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKGhpZ2gsIDAsIHRoaXMudW5zaWduZWQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKGhpZ2ggPj4+IChudW1CaXRzIC0gMzIpLCAwLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaHJfdShudW1CaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoaWZ0UmlnaHRVbnNpZ25lZChudW1CaXRzKTtcbiAgICB9XG4gICAgc2hydShudW1CaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoaWZ0UmlnaHRVbnNpZ25lZChudW1CaXRzKTtcbiAgICB9XG4gICAgc3VidHJhY3Qoc3VidHJhaGVuZCkge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKHN1YnRyYWhlbmQpKVxuICAgICAgICAgICAgc3VidHJhaGVuZCA9IExvbmcuZnJvbVZhbHVlKHN1YnRyYWhlbmQpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7XG4gICAgfVxuICAgIHN1YihzdWJ0cmFoZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnRyYWN0KHN1YnRyYWhlbmQpO1xuICAgIH1cbiAgICB0b0ludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93O1xuICAgIH1cbiAgICB0b051bWJlcigpIHtcbiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQpXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XG4gICAgfVxuICAgIHRvQmlnSW50KCkge1xuICAgICAgICByZXR1cm4gQmlnSW50KHRoaXMudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHRvQnl0ZXMobGUpIHtcbiAgICAgICAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7XG4gICAgfVxuICAgIHRvQnl0ZXNMRSgpIHtcbiAgICAgICAgY29uc3QgaGkgPSB0aGlzLmhpZ2gsIGxvID0gdGhpcy5sb3c7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBsbyAmIDB4ZmYsXG4gICAgICAgICAgICAobG8gPj4+IDgpICYgMHhmZixcbiAgICAgICAgICAgIChsbyA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgICAgIGxvID4+PiAyNCxcbiAgICAgICAgICAgIGhpICYgMHhmZixcbiAgICAgICAgICAgIChoaSA+Pj4gOCkgJiAweGZmLFxuICAgICAgICAgICAgKGhpID4+PiAxNikgJiAweGZmLFxuICAgICAgICAgICAgaGkgPj4+IDI0XG4gICAgICAgIF07XG4gICAgfVxuICAgIHRvQnl0ZXNCRSgpIHtcbiAgICAgICAgY29uc3QgaGkgPSB0aGlzLmhpZ2gsIGxvID0gdGhpcy5sb3c7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBoaSA+Pj4gMjQsXG4gICAgICAgICAgICAoaGkgPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgICAgICAoaGkgPj4+IDgpICYgMHhmZixcbiAgICAgICAgICAgIGhpICYgMHhmZixcbiAgICAgICAgICAgIGxvID4+PiAyNCxcbiAgICAgICAgICAgIChsbyA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgICAgIChsbyA+Pj4gOCkgJiAweGZmLFxuICAgICAgICAgICAgbG8gJiAweGZmXG4gICAgICAgIF07XG4gICAgfVxuICAgIHRvU2lnbmVkKCkge1xuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgZmFsc2UpO1xuICAgIH1cbiAgICB0b1N0cmluZyhyYWRpeCkge1xuICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xuICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdyYWRpeCcpO1xuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSlcbiAgICAgICAgICAgIHJldHVybiAnMCc7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXEoTG9uZy5NSU5fVkFMVUUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFkaXhMb25nID0gTG9uZy5mcm9tTnVtYmVyKHJhZGl4KSwgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSwgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpdi50b1N0cmluZyhyYWRpeCkgKyByZW0xLnRvSW50KCkudG9TdHJpbmcocmFkaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiAnLScgKyB0aGlzLm5lZygpLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYWRpeFRvUG93ZXIgPSBMb25nLmZyb21OdW1iZXIoTWF0aC5wb3cocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgbGV0IHJlbSA9IHRoaXM7XG4gICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKTtcbiAgICAgICAgICAgIGNvbnN0IGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwO1xuICAgICAgICAgICAgbGV0IGRpZ2l0cyA9IGludHZhbC50b1N0cmluZyhyYWRpeCk7XG4gICAgICAgICAgICByZW0gPSByZW1EaXY7XG4gICAgICAgICAgICBpZiAocmVtLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlIChkaWdpdHMubGVuZ3RoIDwgNilcbiAgICAgICAgICAgICAgICAgICAgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICcnICsgZGlnaXRzICsgcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRvVW5zaWduZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnVuc2lnbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpO1xuICAgIH1cbiAgICB4b3Iob3RoZXIpIHtcbiAgICAgICAgaWYgKCFMb25nLmlzTG9uZyhvdGhlcikpXG4gICAgICAgICAgICBvdGhlciA9IExvbmcuZnJvbVZhbHVlKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModGhpcy5sb3cgXiBvdGhlci5sb3csIHRoaXMuaGlnaCBeIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgICBlcXooKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzWmVybygpO1xuICAgIH1cbiAgICBsZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5sZXNzVGhhbk9yRXF1YWwob3RoZXIpO1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTihvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVsYXhlZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvTnVtYmVyKCk7XG4gICAgICAgIHJldHVybiB7ICRudW1iZXJMb25nOiB0aGlzLnRvU3RyaW5nKCkgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgdXNlQmlnSW50NjQgPSBmYWxzZSwgcmVsYXhlZCA9IHRydWUgfSA9IHsgLi4ub3B0aW9ucyB9O1xuICAgICAgICBpZiAoZG9jLiRudW1iZXJMb25nLmxlbmd0aCA+IE1BWF9JTlQ2NF9TVFJJTkdfTEVOR1RIKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCckbnVtYmVyTG9uZyBzdHJpbmcgaXMgdG9vIGxvbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIURFQ0lNQUxfUkVHX0VYLnRlc3QoZG9jLiRudW1iZXJMb25nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgJG51bWJlckxvbmcgc3RyaW5nIFwiJHtkb2MuJG51bWJlckxvbmd9XCIgaXMgaW4gYW4gaW52YWxpZCBmb3JtYXRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlQmlnSW50NjQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpZ0ludFJlc3VsdCA9IEJpZ0ludChkb2MuJG51bWJlckxvbmcpO1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludC5hc0ludE4oNjQsIGJpZ0ludFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9uZ1Jlc3VsdCA9IExvbmcuZnJvbVN0cmluZyhkb2MuJG51bWJlckxvbmcpO1xuICAgICAgICBpZiAocmVsYXhlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvbmdSZXN1bHQudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9uZ1Jlc3VsdDtcbiAgICB9XG4gICAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCk7XG4gICAgfVxuICAgIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiBgbmV3IExvbmcoXCIke3RoaXMudG9TdHJpbmcoKX1cIiR7dGhpcy51bnNpZ25lZCA/ICcsIHRydWUnIDogJyd9KWA7XG4gICAgfVxufVxuTG9uZy5UV09fUFdSXzI0ID0gTG9uZy5mcm9tSW50KFRXT19QV1JfMjRfREJMKTtcbkxvbmcuTUFYX1VOU0lHTkVEX1ZBTFVFID0gTG9uZy5mcm9tQml0cygweGZmZmZmZmZmIHwgMCwgMHhmZmZmZmZmZiB8IDAsIHRydWUpO1xuTG9uZy5aRVJPID0gTG9uZy5mcm9tSW50KDApO1xuTG9uZy5VWkVSTyA9IExvbmcuZnJvbUludCgwLCB0cnVlKTtcbkxvbmcuT05FID0gTG9uZy5mcm9tSW50KDEpO1xuTG9uZy5VT05FID0gTG9uZy5mcm9tSW50KDEsIHRydWUpO1xuTG9uZy5ORUdfT05FID0gTG9uZy5mcm9tSW50KC0xKTtcbkxvbmcuTUFYX1ZBTFVFID0gTG9uZy5mcm9tQml0cygweGZmZmZmZmZmIHwgMCwgMHg3ZmZmZmZmZiB8IDAsIGZhbHNlKTtcbkxvbmcuTUlOX1ZBTFVFID0gTG9uZy5mcm9tQml0cygwLCAweDgwMDAwMDAwIHwgMCwgZmFsc2UpO1xuXG5jb25zdCBQQVJTRV9TVFJJTkdfUkVHRVhQID0gL14oXFwrfC0pPyhcXGQrfChcXGQqXFwuXFxkKikpPyhFfGUpPyhbLStdKT8oXFxkKyk/JC87XG5jb25zdCBQQVJTRV9JTkZfUkVHRVhQID0gL14oXFwrfC0pPyhJbmZpbml0eXxpbmYpJC9pO1xuY29uc3QgUEFSU0VfTkFOX1JFR0VYUCA9IC9eKFxcK3wtKT9OYU4kL2k7XG5jb25zdCBFWFBPTkVOVF9NQVggPSA2MTExO1xuY29uc3QgRVhQT05FTlRfTUlOID0gLTYxNzY7XG5jb25zdCBFWFBPTkVOVF9CSUFTID0gNjE3NjtcbmNvbnN0IE1BWF9ESUdJVFMgPSAzNDtcbmNvbnN0IE5BTl9CVUZGRVIgPSBCeXRlVXRpbHMuZnJvbU51bWJlckFycmF5KFtcbiAgICAweDdjLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwXG5dLnJldmVyc2UoKSk7XG5jb25zdCBJTkZfTkVHQVRJVkVfQlVGRkVSID0gQnl0ZVV0aWxzLmZyb21OdW1iZXJBcnJheShbXG4gICAgMHhmOCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMFxuXS5yZXZlcnNlKCkpO1xuY29uc3QgSU5GX1BPU0lUSVZFX0JVRkZFUiA9IEJ5dGVVdGlscy5mcm9tTnVtYmVyQXJyYXkoW1xuICAgIDB4NzgsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBcbl0ucmV2ZXJzZSgpKTtcbmNvbnN0IEVYUE9ORU5UX1JFR0VYID0gL14oWy0rXSk/KFxcZCspPyQvO1xuY29uc3QgQ09NQklOQVRJT05fTUFTSyA9IDB4MWY7XG5jb25zdCBFWFBPTkVOVF9NQVNLID0gMHgzZmZmO1xuY29uc3QgQ09NQklOQVRJT05fSU5GSU5JVFkgPSAzMDtcbmNvbnN0IENPTUJJTkFUSU9OX05BTiA9IDMxO1xuZnVuY3Rpb24gaXNEaWdpdCh2YWx1ZSkge1xuICAgIHJldHVybiAhaXNOYU4ocGFyc2VJbnQodmFsdWUsIDEwKSk7XG59XG5mdW5jdGlvbiBkaXZpZGV1MTI4KHZhbHVlKSB7XG4gICAgY29uc3QgRElWSVNPUiA9IExvbmcuZnJvbU51bWJlcigxMDAwICogMTAwMCAqIDEwMDApO1xuICAgIGxldCBfcmVtID0gTG9uZy5mcm9tTnVtYmVyKDApO1xuICAgIGlmICghdmFsdWUucGFydHNbMF0gJiYgIXZhbHVlLnBhcnRzWzFdICYmICF2YWx1ZS5wYXJ0c1syXSAmJiAhdmFsdWUucGFydHNbM10pIHtcbiAgICAgICAgcmV0dXJuIHsgcXVvdGllbnQ6IHZhbHVlLCByZW06IF9yZW0gfTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMzsgaSsrKSB7XG4gICAgICAgIF9yZW0gPSBfcmVtLnNoaWZ0TGVmdCgzMik7XG4gICAgICAgIF9yZW0gPSBfcmVtLmFkZChuZXcgTG9uZyh2YWx1ZS5wYXJ0c1tpXSwgMCkpO1xuICAgICAgICB2YWx1ZS5wYXJ0c1tpXSA9IF9yZW0uZGl2KERJVklTT1IpLmxvdztcbiAgICAgICAgX3JlbSA9IF9yZW0ubW9kdWxvKERJVklTT1IpO1xuICAgIH1cbiAgICByZXR1cm4geyBxdW90aWVudDogdmFsdWUsIHJlbTogX3JlbSB9O1xufVxuZnVuY3Rpb24gbXVsdGlwbHk2NHgyKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKCFsZWZ0ICYmICFyaWdodCkge1xuICAgICAgICByZXR1cm4geyBoaWdoOiBMb25nLmZyb21OdW1iZXIoMCksIGxvdzogTG9uZy5mcm9tTnVtYmVyKDApIH07XG4gICAgfVxuICAgIGNvbnN0IGxlZnRIaWdoID0gbGVmdC5zaGlmdFJpZ2h0VW5zaWduZWQoMzIpO1xuICAgIGNvbnN0IGxlZnRMb3cgPSBuZXcgTG9uZyhsZWZ0LmdldExvd0JpdHMoKSwgMCk7XG4gICAgY29uc3QgcmlnaHRIaWdoID0gcmlnaHQuc2hpZnRSaWdodFVuc2lnbmVkKDMyKTtcbiAgICBjb25zdCByaWdodExvdyA9IG5ldyBMb25nKHJpZ2h0LmdldExvd0JpdHMoKSwgMCk7XG4gICAgbGV0IHByb2R1Y3RIaWdoID0gbGVmdEhpZ2gubXVsdGlwbHkocmlnaHRIaWdoKTtcbiAgICBsZXQgcHJvZHVjdE1pZCA9IGxlZnRIaWdoLm11bHRpcGx5KHJpZ2h0TG93KTtcbiAgICBjb25zdCBwcm9kdWN0TWlkMiA9IGxlZnRMb3cubXVsdGlwbHkocmlnaHRIaWdoKTtcbiAgICBsZXQgcHJvZHVjdExvdyA9IGxlZnRMb3cubXVsdGlwbHkocmlnaHRMb3cpO1xuICAgIHByb2R1Y3RIaWdoID0gcHJvZHVjdEhpZ2guYWRkKHByb2R1Y3RNaWQuc2hpZnRSaWdodFVuc2lnbmVkKDMyKSk7XG4gICAgcHJvZHVjdE1pZCA9IG5ldyBMb25nKHByb2R1Y3RNaWQuZ2V0TG93Qml0cygpLCAwKVxuICAgICAgICAuYWRkKHByb2R1Y3RNaWQyKVxuICAgICAgICAuYWRkKHByb2R1Y3RMb3cuc2hpZnRSaWdodFVuc2lnbmVkKDMyKSk7XG4gICAgcHJvZHVjdEhpZ2ggPSBwcm9kdWN0SGlnaC5hZGQocHJvZHVjdE1pZC5zaGlmdFJpZ2h0VW5zaWduZWQoMzIpKTtcbiAgICBwcm9kdWN0TG93ID0gcHJvZHVjdE1pZC5zaGlmdExlZnQoMzIpLmFkZChuZXcgTG9uZyhwcm9kdWN0TG93LmdldExvd0JpdHMoKSwgMCkpO1xuICAgIHJldHVybiB7IGhpZ2g6IHByb2R1Y3RIaWdoLCBsb3c6IHByb2R1Y3RMb3cgfTtcbn1cbmZ1bmN0aW9uIGxlc3NUaGFuKGxlZnQsIHJpZ2h0KSB7XG4gICAgY29uc3QgdWhsZWZ0ID0gbGVmdC5oaWdoID4+PiAwO1xuICAgIGNvbnN0IHVocmlnaHQgPSByaWdodC5oaWdoID4+PiAwO1xuICAgIGlmICh1aGxlZnQgPCB1aHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh1aGxlZnQgPT09IHVocmlnaHQpIHtcbiAgICAgICAgY29uc3QgdWxsZWZ0ID0gbGVmdC5sb3cgPj4+IDA7XG4gICAgICAgIGNvbnN0IHVscmlnaHQgPSByaWdodC5sb3cgPj4+IDA7XG4gICAgICAgIGlmICh1bGxlZnQgPCB1bHJpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGludmFsaWRFcnIoc3RyaW5nLCBtZXNzYWdlKSB7XG4gICAgdGhyb3cgbmV3IEJTT05FcnJvcihgXCIke3N0cmluZ31cIiBpcyBub3QgYSB2YWxpZCBEZWNpbWFsMTI4IHN0cmluZyAtICR7bWVzc2FnZX1gKTtcbn1cbmNsYXNzIERlY2ltYWwxMjggZXh0ZW5kcyBCU09OVmFsdWUge1xuICAgIGdldCBfYnNvbnR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnRGVjaW1hbDEyOCc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVzID0gRGVjaW1hbDEyOC5mcm9tU3RyaW5nKGJ5dGVzKS5ieXRlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1VpbnQ4QXJyYXkoYnl0ZXMpKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMuYnl0ZUxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdEZWNpbWFsMTI4IG11c3QgdGFrZSBhIEJ1ZmZlciBvZiAxNiBieXRlcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignRGVjaW1hbDEyOCBtdXN0IHRha2UgYSBCdWZmZXIgb3Igc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcocmVwcmVzZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIERlY2ltYWwxMjguX2Zyb21TdHJpbmcocmVwcmVzZW50YXRpb24sIHsgYWxsb3dSb3VuZGluZzogZmFsc2UgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nV2l0aFJvdW5kaW5nKHJlcHJlc2VudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBEZWNpbWFsMTI4Ll9mcm9tU3RyaW5nKHJlcHJlc2VudGF0aW9uLCB7IGFsbG93Um91bmRpbmc6IHRydWUgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBfZnJvbVN0cmluZyhyZXByZXNlbnRhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICBsZXQgaXNOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICBsZXQgc2F3U2lnbiA9IGZhbHNlO1xuICAgICAgICBsZXQgc2F3UmFkaXggPSBmYWxzZTtcbiAgICAgICAgbGV0IGZvdW5kTm9uWmVybyA9IGZhbHNlO1xuICAgICAgICBsZXQgc2lnbmlmaWNhbnREaWdpdHMgPSAwO1xuICAgICAgICBsZXQgbkRpZ2l0c1JlYWQgPSAwO1xuICAgICAgICBsZXQgbkRpZ2l0cyA9IDA7XG4gICAgICAgIGxldCByYWRpeFBvc2l0aW9uID0gMDtcbiAgICAgICAgbGV0IGZpcnN0Tm9uWmVybyA9IDA7XG4gICAgICAgIGNvbnN0IGRpZ2l0cyA9IFswXTtcbiAgICAgICAgbGV0IG5EaWdpdHNTdG9yZWQgPSAwO1xuICAgICAgICBsZXQgZGlnaXRzSW5zZXJ0ID0gMDtcbiAgICAgICAgbGV0IGxhc3REaWdpdCA9IDA7XG4gICAgICAgIGxldCBleHBvbmVudCA9IDA7XG4gICAgICAgIGxldCBzaWduaWZpY2FuZEhpZ2ggPSBuZXcgTG9uZygwLCAwKTtcbiAgICAgICAgbGV0IHNpZ25pZmljYW5kTG93ID0gbmV3IExvbmcoMCwgMCk7XG4gICAgICAgIGxldCBiaWFzZWRFeHBvbmVudCA9IDA7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGlmIChyZXByZXNlbnRhdGlvbi5sZW5ndGggPj0gNzAwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignJyArIHJlcHJlc2VudGF0aW9uICsgJyBub3QgYSB2YWxpZCBEZWNpbWFsMTI4IHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmluZ01hdGNoID0gcmVwcmVzZW50YXRpb24ubWF0Y2goUEFSU0VfU1RSSU5HX1JFR0VYUCk7XG4gICAgICAgIGNvbnN0IGluZk1hdGNoID0gcmVwcmVzZW50YXRpb24ubWF0Y2goUEFSU0VfSU5GX1JFR0VYUCk7XG4gICAgICAgIGNvbnN0IG5hbk1hdGNoID0gcmVwcmVzZW50YXRpb24ubWF0Y2goUEFSU0VfTkFOX1JFR0VYUCk7XG4gICAgICAgIGlmICgoIXN0cmluZ01hdGNoICYmICFpbmZNYXRjaCAmJiAhbmFuTWF0Y2gpIHx8IHJlcHJlc2VudGF0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignJyArIHJlcHJlc2VudGF0aW9uICsgJyBub3QgYSB2YWxpZCBEZWNpbWFsMTI4IHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpbmdNYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgdW5zaWduZWROdW1iZXIgPSBzdHJpbmdNYXRjaFsyXTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBzdHJpbmdNYXRjaFs0XTtcbiAgICAgICAgICAgIGNvbnN0IGV4cFNpZ24gPSBzdHJpbmdNYXRjaFs1XTtcbiAgICAgICAgICAgIGNvbnN0IGV4cE51bWJlciA9IHN0cmluZ01hdGNoWzZdO1xuICAgICAgICAgICAgaWYgKGUgJiYgZXhwTnVtYmVyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgaW52YWxpZEVycihyZXByZXNlbnRhdGlvbiwgJ21pc3NpbmcgZXhwb25lbnQgcG93ZXInKTtcbiAgICAgICAgICAgIGlmIChlICYmIHVuc2lnbmVkTnVtYmVyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgaW52YWxpZEVycihyZXByZXNlbnRhdGlvbiwgJ21pc3NpbmcgZXhwb25lbnQgYmFzZScpO1xuICAgICAgICAgICAgaWYgKGUgPT09IHVuZGVmaW5lZCAmJiAoZXhwU2lnbiB8fCBleHBOdW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgaW52YWxpZEVycihyZXByZXNlbnRhdGlvbiwgJ21pc3NpbmcgZSBiZWZvcmUgZXhwb25lbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVwcmVzZW50YXRpb25baW5kZXhdID09PSAnKycgfHwgcmVwcmVzZW50YXRpb25baW5kZXhdID09PSAnLScpIHtcbiAgICAgICAgICAgIHNhd1NpZ24gPSB0cnVlO1xuICAgICAgICAgICAgaXNOZWdhdGl2ZSA9IHJlcHJlc2VudGF0aW9uW2luZGV4KytdID09PSAnLSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0RpZ2l0KHJlcHJlc2VudGF0aW9uW2luZGV4XSkgJiYgcmVwcmVzZW50YXRpb25baW5kZXhdICE9PSAnLicpIHtcbiAgICAgICAgICAgIGlmIChyZXByZXNlbnRhdGlvbltpbmRleF0gPT09ICdpJyB8fCByZXByZXNlbnRhdGlvbltpbmRleF0gPT09ICdJJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjaW1hbDEyOChpc05lZ2F0aXZlID8gSU5GX05FR0FUSVZFX0JVRkZFUiA6IElORl9QT1NJVElWRV9CVUZGRVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVwcmVzZW50YXRpb25baW5kZXhdID09PSAnTicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwxMjgoTkFOX0JVRkZFUik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGlzRGlnaXQocmVwcmVzZW50YXRpb25baW5kZXhdKSB8fCByZXByZXNlbnRhdGlvbltpbmRleF0gPT09ICcuJykge1xuICAgICAgICAgICAgaWYgKHJlcHJlc2VudGF0aW9uW2luZGV4XSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhd1JhZGl4KVxuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnY29udGFpbnMgbXVsdGlwbGUgcGVyaW9kcycpO1xuICAgICAgICAgICAgICAgIHNhd1JhZGl4ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuRGlnaXRzU3RvcmVkIDwgTUFYX0RJR0lUUykge1xuICAgICAgICAgICAgICAgIGlmIChyZXByZXNlbnRhdGlvbltpbmRleF0gIT09ICcwJyB8fCBmb3VuZE5vblplcm8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZE5vblplcm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9uWmVybyA9IG5EaWdpdHNSZWFkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kTm9uWmVybyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRpZ2l0c1tkaWdpdHNJbnNlcnQrK10gPSBwYXJzZUludChyZXByZXNlbnRhdGlvbltpbmRleF0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgbkRpZ2l0c1N0b3JlZCA9IG5EaWdpdHNTdG9yZWQgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZE5vblplcm8pXG4gICAgICAgICAgICAgICAgbkRpZ2l0cyA9IG5EaWdpdHMgKyAxO1xuICAgICAgICAgICAgaWYgKHNhd1JhZGl4KVxuICAgICAgICAgICAgICAgIHJhZGl4UG9zaXRpb24gPSByYWRpeFBvc2l0aW9uICsgMTtcbiAgICAgICAgICAgIG5EaWdpdHNSZWFkID0gbkRpZ2l0c1JlYWQgKyAxO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhd1JhZGl4ICYmICFuRGlnaXRzUmVhZClcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJycgKyByZXByZXNlbnRhdGlvbiArICcgbm90IGEgdmFsaWQgRGVjaW1hbDEyOCBzdHJpbmcnKTtcbiAgICAgICAgaWYgKHJlcHJlc2VudGF0aW9uW2luZGV4XSA9PT0gJ2UnIHx8IHJlcHJlc2VudGF0aW9uW2luZGV4XSA9PT0gJ0UnKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHJlcHJlc2VudGF0aW9uLnN1YnN0cigrK2luZGV4KS5tYXRjaChFWFBPTkVOVF9SRUdFWCk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoIHx8ICFtYXRjaFsyXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwxMjgoTkFOX0JVRkZFUik7XG4gICAgICAgICAgICBleHBvbmVudCA9IHBhcnNlSW50KG1hdGNoWzBdLCAxMCk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXByZXNlbnRhdGlvbltpbmRleF0pXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwxMjgoTkFOX0JVRkZFUik7XG4gICAgICAgIGlmICghbkRpZ2l0c1N0b3JlZCkge1xuICAgICAgICAgICAgZGlnaXRzWzBdID0gMDtcbiAgICAgICAgICAgIG5EaWdpdHMgPSAxO1xuICAgICAgICAgICAgbkRpZ2l0c1N0b3JlZCA9IDE7XG4gICAgICAgICAgICBzaWduaWZpY2FudERpZ2l0cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYXN0RGlnaXQgPSBuRGlnaXRzU3RvcmVkIC0gMTtcbiAgICAgICAgICAgIHNpZ25pZmljYW50RGlnaXRzID0gbkRpZ2l0cztcbiAgICAgICAgICAgIGlmIChzaWduaWZpY2FudERpZ2l0cyAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZXByZXNlbnRhdGlvbltmaXJzdE5vblplcm8gKyBzaWduaWZpY2FudERpZ2l0cyAtIDEgKyBOdW1iZXIoc2F3U2lnbikgKyBOdW1iZXIoc2F3UmFkaXgpXSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25pZmljYW50RGlnaXRzID0gc2lnbmlmaWNhbnREaWdpdHMgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwb25lbnQgPD0gcmFkaXhQb3NpdGlvbiAmJiByYWRpeFBvc2l0aW9uID4gZXhwb25lbnQgKyAoMSA8PCAxNCkpIHtcbiAgICAgICAgICAgIGV4cG9uZW50ID0gRVhQT05FTlRfTUlOO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXhwb25lbnQgPSBleHBvbmVudCAtIHJhZGl4UG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGV4cG9uZW50ID4gRVhQT05FTlRfTUFYKSB7XG4gICAgICAgICAgICBsYXN0RGlnaXQgPSBsYXN0RGlnaXQgKyAxO1xuICAgICAgICAgICAgaWYgKGxhc3REaWdpdCA+PSBNQVhfRElHSVRTKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25pZmljYW50RGlnaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gRVhQT05FTlRfTUFYO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW52YWxpZEVycihyZXByZXNlbnRhdGlvbiwgJ292ZXJmbG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBvbmVudCA9IGV4cG9uZW50IC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hbGxvd1JvdW5kaW5nKSB7XG4gICAgICAgICAgICB3aGlsZSAoZXhwb25lbnQgPCBFWFBPTkVOVF9NSU4gfHwgbkRpZ2l0c1N0b3JlZCA8IG5EaWdpdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdERpZ2l0ID09PSAwICYmIHNpZ25pZmljYW50RGlnaXRzIDwgbkRpZ2l0c1N0b3JlZCkge1xuICAgICAgICAgICAgICAgICAgICBleHBvbmVudCA9IEVYUE9ORU5UX01JTjtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWNhbnREaWdpdHMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5EaWdpdHNTdG9yZWQgPCBuRGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5EaWdpdHMgPSBuRGlnaXRzIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3REaWdpdCA9IGxhc3REaWdpdCAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleHBvbmVudCA8IEVYUE9ORU5UX01BWCkge1xuICAgICAgICAgICAgICAgICAgICBleHBvbmVudCA9IGV4cG9uZW50ICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZ2l0c1N0cmluZyA9IGRpZ2l0cy5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpZ2l0c1N0cmluZy5tYXRjaCgvXjArJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvbmVudCA9IEVYUE9ORU5UX01BWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdvdmVyZmxvdycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0RGlnaXQgKyAxIDwgc2lnbmlmaWNhbnREaWdpdHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kT2ZTdHJpbmcgPSBuRGlnaXRzUmVhZDtcbiAgICAgICAgICAgICAgICBpZiAoc2F3UmFkaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb25aZXJvID0gZmlyc3ROb25aZXJvICsgMTtcbiAgICAgICAgICAgICAgICAgICAgZW5kT2ZTdHJpbmcgPSBlbmRPZlN0cmluZyArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzYXdTaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9uWmVybyA9IGZpcnN0Tm9uWmVybyArIDE7XG4gICAgICAgICAgICAgICAgICAgIGVuZE9mU3RyaW5nID0gZW5kT2ZTdHJpbmcgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByb3VuZERpZ2l0ID0gcGFyc2VJbnQocmVwcmVzZW50YXRpb25bZmlyc3ROb25aZXJvICsgbGFzdERpZ2l0ICsgMV0sIDEwKTtcbiAgICAgICAgICAgICAgICBsZXQgcm91bmRCaXQgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChyb3VuZERpZ2l0ID49IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgcm91bmRCaXQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAocm91bmREaWdpdCA9PT0gNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91bmRCaXQgPSBkaWdpdHNbbGFzdERpZ2l0XSAlIDIgPT09IDEgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBmaXJzdE5vblplcm8gKyBsYXN0RGlnaXQgKyAyOyBpIDwgZW5kT2ZTdHJpbmc7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZUludChyZXByZXNlbnRhdGlvbltpXSwgMTApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kQml0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb3VuZEJpdCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZElkeCA9IGxhc3REaWdpdDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGRJZHggPj0gMDsgZElkeC0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKytkaWdpdHNbZElkeF0gPiA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRzW2RJZHhdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZElkeCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwb25lbnQgPCBFWFBPTkVOVF9NQVgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gZXhwb25lbnQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRzW2RJZHhdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjaW1hbDEyOChpc05lZ2F0aXZlID8gSU5GX05FR0FUSVZFX0JVRkZFUiA6IElORl9QT1NJVElWRV9CVUZGRVIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoZXhwb25lbnQgPCBFWFBPTkVOVF9NSU4gfHwgbkRpZ2l0c1N0b3JlZCA8IG5EaWdpdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdERpZ2l0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWduaWZpY2FudERpZ2l0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBFWFBPTkVOVF9NSU47XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnZXhwb25lbnQgdW5kZXJmbG93Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuRGlnaXRzU3RvcmVkIDwgbkRpZ2l0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwcmVzZW50YXRpb25bbkRpZ2l0cyAtIDEgKyBOdW1iZXIoc2F3U2lnbikgKyBOdW1iZXIoc2F3UmFkaXgpXSAhPT0gJzAnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduaWZpY2FudERpZ2l0cyAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZEVycihyZXByZXNlbnRhdGlvbiwgJ2luZXhhY3Qgcm91bmRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuRGlnaXRzID0gbkRpZ2l0cyAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlnaXRzW2xhc3REaWdpdF0gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdpbmV4YWN0IHJvdW5kaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdERpZ2l0ID0gbGFzdERpZ2l0IC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50IDwgRVhQT05FTlRfTUFYKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gZXhwb25lbnQgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZEVycihyZXByZXNlbnRhdGlvbiwgJ292ZXJmbG93Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3REaWdpdCArIDEgPCBzaWduaWZpY2FudERpZ2l0cykge1xuICAgICAgICAgICAgICAgIGlmIChzYXdSYWRpeCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdE5vblplcm8gPSBmaXJzdE5vblplcm8gKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2F3U2lnbikge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdE5vblplcm8gPSBmaXJzdE5vblplcm8gKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByb3VuZERpZ2l0ID0gcGFyc2VJbnQocmVwcmVzZW50YXRpb25bZmlyc3ROb25aZXJvICsgbGFzdERpZ2l0ICsgMV0sIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAocm91bmREaWdpdCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnaW5leGFjdCByb3VuZGluZycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaWduaWZpY2FuZEhpZ2ggPSBMb25nLmZyb21OdW1iZXIoMCk7XG4gICAgICAgIHNpZ25pZmljYW5kTG93ID0gTG9uZy5mcm9tTnVtYmVyKDApO1xuICAgICAgICBpZiAoc2lnbmlmaWNhbnREaWdpdHMgPT09IDApIHtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kSGlnaCA9IExvbmcuZnJvbU51bWJlcigwKTtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kTG93ID0gTG9uZy5mcm9tTnVtYmVyKDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhc3REaWdpdCA8IDE3KSB7XG4gICAgICAgICAgICBsZXQgZElkeCA9IDA7XG4gICAgICAgICAgICBzaWduaWZpY2FuZExvdyA9IExvbmcuZnJvbU51bWJlcihkaWdpdHNbZElkeCsrXSk7XG4gICAgICAgICAgICBzaWduaWZpY2FuZEhpZ2ggPSBuZXcgTG9uZygwLCAwKTtcbiAgICAgICAgICAgIGZvciAoOyBkSWR4IDw9IGxhc3REaWdpdDsgZElkeCsrKSB7XG4gICAgICAgICAgICAgICAgc2lnbmlmaWNhbmRMb3cgPSBzaWduaWZpY2FuZExvdy5tdWx0aXBseShMb25nLmZyb21OdW1iZXIoMTApKTtcbiAgICAgICAgICAgICAgICBzaWduaWZpY2FuZExvdyA9IHNpZ25pZmljYW5kTG93LmFkZChMb25nLmZyb21OdW1iZXIoZGlnaXRzW2RJZHhdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZElkeCA9IDA7XG4gICAgICAgICAgICBzaWduaWZpY2FuZEhpZ2ggPSBMb25nLmZyb21OdW1iZXIoZGlnaXRzW2RJZHgrK10pO1xuICAgICAgICAgICAgZm9yICg7IGRJZHggPD0gbGFzdERpZ2l0IC0gMTc7IGRJZHgrKykge1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kSGlnaCA9IHNpZ25pZmljYW5kSGlnaC5tdWx0aXBseShMb25nLmZyb21OdW1iZXIoMTApKTtcbiAgICAgICAgICAgICAgICBzaWduaWZpY2FuZEhpZ2ggPSBzaWduaWZpY2FuZEhpZ2guYWRkKExvbmcuZnJvbU51bWJlcihkaWdpdHNbZElkeF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpZ25pZmljYW5kTG93ID0gTG9uZy5mcm9tTnVtYmVyKGRpZ2l0c1tkSWR4KytdKTtcbiAgICAgICAgICAgIGZvciAoOyBkSWR4IDw9IGxhc3REaWdpdDsgZElkeCsrKSB7XG4gICAgICAgICAgICAgICAgc2lnbmlmaWNhbmRMb3cgPSBzaWduaWZpY2FuZExvdy5tdWx0aXBseShMb25nLmZyb21OdW1iZXIoMTApKTtcbiAgICAgICAgICAgICAgICBzaWduaWZpY2FuZExvdyA9IHNpZ25pZmljYW5kTG93LmFkZChMb25nLmZyb21OdW1iZXIoZGlnaXRzW2RJZHhdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbmlmaWNhbmQgPSBtdWx0aXBseTY0eDIoc2lnbmlmaWNhbmRIaWdoLCBMb25nLmZyb21TdHJpbmcoJzEwMDAwMDAwMDAwMDAwMDAwMCcpKTtcbiAgICAgICAgc2lnbmlmaWNhbmQubG93ID0gc2lnbmlmaWNhbmQubG93LmFkZChzaWduaWZpY2FuZExvdyk7XG4gICAgICAgIGlmIChsZXNzVGhhbihzaWduaWZpY2FuZC5sb3csIHNpZ25pZmljYW5kTG93KSkge1xuICAgICAgICAgICAgc2lnbmlmaWNhbmQuaGlnaCA9IHNpZ25pZmljYW5kLmhpZ2guYWRkKExvbmcuZnJvbU51bWJlcigxKSk7XG4gICAgICAgIH1cbiAgICAgICAgYmlhc2VkRXhwb25lbnQgPSBleHBvbmVudCArIEVYUE9ORU5UX0JJQVM7XG4gICAgICAgIGNvbnN0IGRlYyA9IHsgbG93OiBMb25nLmZyb21OdW1iZXIoMCksIGhpZ2g6IExvbmcuZnJvbU51bWJlcigwKSB9O1xuICAgICAgICBpZiAoc2lnbmlmaWNhbmQuaGlnaC5zaGlmdFJpZ2h0VW5zaWduZWQoNDkpLmFuZChMb25nLmZyb21OdW1iZXIoMSkpLmVxdWFscyhMb25nLmZyb21OdW1iZXIoMSkpKSB7XG4gICAgICAgICAgICBkZWMuaGlnaCA9IGRlYy5oaWdoLm9yKExvbmcuZnJvbU51bWJlcigweDMpLnNoaWZ0TGVmdCg2MSkpO1xuICAgICAgICAgICAgZGVjLmhpZ2ggPSBkZWMuaGlnaC5vcihMb25nLmZyb21OdW1iZXIoYmlhc2VkRXhwb25lbnQpLmFuZChMb25nLmZyb21OdW1iZXIoMHgzZmZmKS5zaGlmdExlZnQoNDcpKSk7XG4gICAgICAgICAgICBkZWMuaGlnaCA9IGRlYy5oaWdoLm9yKHNpZ25pZmljYW5kLmhpZ2guYW5kKExvbmcuZnJvbU51bWJlcigweDdmZmZmZmZmZmZmZikpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYy5oaWdoID0gZGVjLmhpZ2gub3IoTG9uZy5mcm9tTnVtYmVyKGJpYXNlZEV4cG9uZW50ICYgMHgzZmZmKS5zaGlmdExlZnQoNDkpKTtcbiAgICAgICAgICAgIGRlYy5oaWdoID0gZGVjLmhpZ2gub3Ioc2lnbmlmaWNhbmQuaGlnaC5hbmQoTG9uZy5mcm9tTnVtYmVyKDB4MWZmZmZmZmZmZmZmZikpKTtcbiAgICAgICAgfVxuICAgICAgICBkZWMubG93ID0gc2lnbmlmaWNhbmQubG93O1xuICAgICAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgICAgICAgZGVjLmhpZ2ggPSBkZWMuaGlnaC5vcihMb25nLmZyb21TdHJpbmcoJzkyMjMzNzIwMzY4NTQ3NzU4MDgnKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnl0ZVV0aWxzLmFsbG9jYXRlKDE2KTtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBkZWMubG93LmxvdyAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMubG93LmxvdyA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMubG93LmxvdyA+PiAxNikgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmxvdy5sb3cgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gZGVjLmxvdy5oaWdoICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5sb3cuaGlnaCA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMubG93LmhpZ2ggPj4gMTYpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5sb3cuaGlnaCA+PiAyNCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBkZWMuaGlnaC5sb3cgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmhpZ2gubG93ID4+IDgpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5oaWdoLmxvdyA+PiAxNikgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmhpZ2gubG93ID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IGRlYy5oaWdoLmhpZ2ggJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmhpZ2guaGlnaCA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMuaGlnaC5oaWdoID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMuaGlnaC5oaWdoID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIHJldHVybiBuZXcgRGVjaW1hbDEyOChidWZmZXIpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGJpYXNlZF9leHBvbmVudDtcbiAgICAgICAgbGV0IHNpZ25pZmljYW5kX2RpZ2l0cyA9IDA7XG4gICAgICAgIGNvbnN0IHNpZ25pZmljYW5kID0gbmV3IEFycmF5KDM2KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduaWZpY2FuZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHNpZ25pZmljYW5kW2ldID0gMDtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgbGV0IGlzX3plcm8gPSBmYWxzZTtcbiAgICAgICAgbGV0IHNpZ25pZmljYW5kX21zYjtcbiAgICAgICAgbGV0IHNpZ25pZmljYW5kMTI4ID0geyBwYXJ0czogWzAsIDAsIDAsIDBdIH07XG4gICAgICAgIGxldCBqLCBrO1xuICAgICAgICBjb25zdCBzdHJpbmcgPSBbXTtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmJ5dGVzO1xuICAgICAgICBjb25zdCBsb3cgPSBidWZmZXJbaW5kZXgrK10gfCAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfCAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgY29uc3QgbWlkbCA9IGJ1ZmZlcltpbmRleCsrXSB8IChidWZmZXJbaW5kZXgrK10gPDwgOCkgfCAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICBjb25zdCBtaWRoID0gYnVmZmVyW2luZGV4KytdIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgIGNvbnN0IGhpZ2ggPSBidWZmZXJbaW5kZXgrK10gfCAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfCAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICBjb25zdCBkZWMgPSB7XG4gICAgICAgICAgICBsb3c6IG5ldyBMb25nKGxvdywgbWlkbCksXG4gICAgICAgICAgICBoaWdoOiBuZXcgTG9uZyhtaWRoLCBoaWdoKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZGVjLmhpZ2gubGVzc1RoYW4oTG9uZy5aRVJPKSkge1xuICAgICAgICAgICAgc3RyaW5nLnB1c2goJy0nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21iaW5hdGlvbiA9IChoaWdoID4+IDI2KSAmIENPTUJJTkFUSU9OX01BU0s7XG4gICAgICAgIGlmIChjb21iaW5hdGlvbiA+PiAzID09PSAzKSB7XG4gICAgICAgICAgICBpZiAoY29tYmluYXRpb24gPT09IENPTUJJTkFUSU9OX0lORklOSVRZKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5qb2luKCcnKSArICdJbmZpbml0eSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb21iaW5hdGlvbiA9PT0gQ09NQklOQVRJT05fTkFOKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdOYU4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYmlhc2VkX2V4cG9uZW50ID0gKGhpZ2ggPj4gMTUpICYgRVhQT05FTlRfTUFTSztcbiAgICAgICAgICAgICAgICBzaWduaWZpY2FuZF9tc2IgPSAweDA4ICsgKChoaWdoID4+IDE0KSAmIDB4MDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2lnbmlmaWNhbmRfbXNiID0gKGhpZ2ggPj4gMTQpICYgMHgwNztcbiAgICAgICAgICAgIGJpYXNlZF9leHBvbmVudCA9IChoaWdoID4+IDE3KSAmIEVYUE9ORU5UX01BU0s7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhwb25lbnQgPSBiaWFzZWRfZXhwb25lbnQgLSBFWFBPTkVOVF9CSUFTO1xuICAgICAgICBzaWduaWZpY2FuZDEyOC5wYXJ0c1swXSA9IChoaWdoICYgMHgzZmZmKSArICgoc2lnbmlmaWNhbmRfbXNiICYgMHhmKSA8PCAxNCk7XG4gICAgICAgIHNpZ25pZmljYW5kMTI4LnBhcnRzWzFdID0gbWlkaDtcbiAgICAgICAgc2lnbmlmaWNhbmQxMjgucGFydHNbMl0gPSBtaWRsO1xuICAgICAgICBzaWduaWZpY2FuZDEyOC5wYXJ0c1szXSA9IGxvdztcbiAgICAgICAgaWYgKHNpZ25pZmljYW5kMTI4LnBhcnRzWzBdID09PSAwICYmXG4gICAgICAgICAgICBzaWduaWZpY2FuZDEyOC5wYXJ0c1sxXSA9PT0gMCAmJlxuICAgICAgICAgICAgc2lnbmlmaWNhbmQxMjgucGFydHNbMl0gPT09IDAgJiZcbiAgICAgICAgICAgIHNpZ25pZmljYW5kMTI4LnBhcnRzWzNdID09PSAwKSB7XG4gICAgICAgICAgICBpc196ZXJvID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoayA9IDM7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxlYXN0X2RpZ2l0cyA9IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZGl2aWRldTEyOChzaWduaWZpY2FuZDEyOCk7XG4gICAgICAgICAgICAgICAgc2lnbmlmaWNhbmQxMjggPSByZXN1bHQucXVvdGllbnQ7XG4gICAgICAgICAgICAgICAgbGVhc3RfZGlnaXRzID0gcmVzdWx0LnJlbS5sb3c7XG4gICAgICAgICAgICAgICAgaWYgKCFsZWFzdF9kaWdpdHMpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kW2sgKiA5ICsgal0gPSBsZWFzdF9kaWdpdHMgJSAxMDtcbiAgICAgICAgICAgICAgICAgICAgbGVhc3RfZGlnaXRzID0gTWF0aC5mbG9vcihsZWFzdF9kaWdpdHMgLyAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc196ZXJvKSB7XG4gICAgICAgICAgICBzaWduaWZpY2FuZF9kaWdpdHMgPSAxO1xuICAgICAgICAgICAgc2lnbmlmaWNhbmRbaW5kZXhdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kX2RpZ2l0cyA9IDM2O1xuICAgICAgICAgICAgd2hpbGUgKCFzaWduaWZpY2FuZFtpbmRleF0pIHtcbiAgICAgICAgICAgICAgICBzaWduaWZpY2FuZF9kaWdpdHMgPSBzaWduaWZpY2FuZF9kaWdpdHMgLSAxO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjaWVudGlmaWNfZXhwb25lbnQgPSBzaWduaWZpY2FuZF9kaWdpdHMgLSAxICsgZXhwb25lbnQ7XG4gICAgICAgIGlmIChzY2llbnRpZmljX2V4cG9uZW50ID49IDM0IHx8IHNjaWVudGlmaWNfZXhwb25lbnQgPD0gLTcgfHwgZXhwb25lbnQgPiAwKSB7XG4gICAgICAgICAgICBpZiAoc2lnbmlmaWNhbmRfZGlnaXRzID4gMzQpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcucHVzaChgJHswfWApO1xuICAgICAgICAgICAgICAgIGlmIChleHBvbmVudCA+IDApXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKGBFKyR7ZXhwb25lbnR9YCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXhwb25lbnQgPCAwKVxuICAgICAgICAgICAgICAgICAgICBzdHJpbmcucHVzaChgRSR7ZXhwb25lbnR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5qb2luKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmluZy5wdXNoKGAke3NpZ25pZmljYW5kW2luZGV4KytdfWApO1xuICAgICAgICAgICAgc2lnbmlmaWNhbmRfZGlnaXRzID0gc2lnbmlmaWNhbmRfZGlnaXRzIC0gMTtcbiAgICAgICAgICAgIGlmIChzaWduaWZpY2FuZF9kaWdpdHMpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcucHVzaCgnLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduaWZpY2FuZF9kaWdpdHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKGAke3NpZ25pZmljYW5kW2luZGV4KytdfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaW5nLnB1c2goJ0UnKTtcbiAgICAgICAgICAgIGlmIChzY2llbnRpZmljX2V4cG9uZW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKGArJHtzY2llbnRpZmljX2V4cG9uZW50fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goYCR7c2NpZW50aWZpY19leHBvbmVudH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChleHBvbmVudCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduaWZpY2FuZF9kaWdpdHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcucHVzaChgJHtzaWduaWZpY2FuZFtpbmRleCsrXX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgcmFkaXhfcG9zaXRpb24gPSBzaWduaWZpY2FuZF9kaWdpdHMgKyBleHBvbmVudDtcbiAgICAgICAgICAgICAgICBpZiAocmFkaXhfcG9zaXRpb24gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFkaXhfcG9zaXRpb247IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goYCR7c2lnbmlmaWNhbmRbaW5kZXgrK119YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKCcwJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKCcuJyk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJhZGl4X3Bvc2l0aW9uKysgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKCcwJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmlmaWNhbmRfZGlnaXRzIC0gTWF0aC5tYXgocmFkaXhfcG9zaXRpb24gLSAxLCAwKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKGAke3NpZ25pZmljYW5kW2luZGV4KytdfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nLmpvaW4oJycpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7ICRudW1iZXJEZWNpbWFsOiB0aGlzLnRvU3RyaW5nKCkgfTtcbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04oKSB7XG4gICAgICAgIHJldHVybiB7ICRudW1iZXJEZWNpbWFsOiB0aGlzLnRvU3RyaW5nKCkgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jKSB7XG4gICAgICAgIHJldHVybiBEZWNpbWFsMTI4LmZyb21TdHJpbmcoZG9jLiRudW1iZXJEZWNpbWFsKTtcbiAgICB9XG4gICAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCk7XG4gICAgfVxuICAgIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiBgbmV3IERlY2ltYWwxMjgoXCIke3RoaXMudG9TdHJpbmcoKX1cIilgO1xuICAgIH1cbn1cblxuY2xhc3MgRG91YmxlIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0RvdWJsZSc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9ICt2YWx1ZTtcbiAgICB9XG4gICAgdmFsdWVPZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRvU3RyaW5nKHJhZGl4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnRvU3RyaW5nKHJhZGl4KTtcbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04ob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiAob3B0aW9ucy5sZWdhY3kgfHwgKG9wdGlvbnMucmVsYXhlZCAmJiBpc0Zpbml0ZSh0aGlzLnZhbHVlKSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmlzKE1hdGguc2lnbih0aGlzLnZhbHVlKSwgLTApKSB7XG4gICAgICAgICAgICByZXR1cm4geyAkbnVtYmVyRG91YmxlOiAnLTAuMCcgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJG51bWJlckRvdWJsZTogTnVtYmVyLmlzSW50ZWdlcih0aGlzLnZhbHVlKSA/IHRoaXMudmFsdWUudG9GaXhlZCgxKSA6IHRoaXMudmFsdWUudG9TdHJpbmcoKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZG91YmxlVmFsdWUgPSBwYXJzZUZsb2F0KGRvYy4kbnVtYmVyRG91YmxlKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5yZWxheGVkID8gZG91YmxlVmFsdWUgOiBuZXcgRG91YmxlKGRvdWJsZVZhbHVlKTtcbiAgICB9XG4gICAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCk7XG4gICAgfVxuICAgIGluc3BlY3QoKSB7XG4gICAgICAgIGNvbnN0IGVKU09OID0gdGhpcy50b0V4dGVuZGVkSlNPTigpO1xuICAgICAgICByZXR1cm4gYG5ldyBEb3VibGUoJHtlSlNPTi4kbnVtYmVyRG91YmxlfSlgO1xuICAgIH1cbn1cblxuY2xhc3MgSW50MzIgZXh0ZW5kcyBCU09OVmFsdWUge1xuICAgIGdldCBfYnNvbnR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnSW50MzInO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSArdmFsdWUgfCAwO1xuICAgIH1cbiAgICB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgdG9TdHJpbmcocmFkaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUudG9TdHJpbmcocmFkaXgpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTihvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICYmIChvcHRpb25zLnJlbGF4ZWQgfHwgb3B0aW9ucy5sZWdhY3kpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB7ICRudW1iZXJJbnQ6IHRoaXMudmFsdWUudG9TdHJpbmcoKSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5yZWxheGVkID8gcGFyc2VJbnQoZG9jLiRudW1iZXJJbnQsIDEwKSA6IG5ldyBJbnQzMihkb2MuJG51bWJlckludCk7XG4gICAgfVxuICAgIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpO1xuICAgIH1cbiAgICBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4gYG5ldyBJbnQzMigke3RoaXMudmFsdWVPZigpfSlgO1xuICAgIH1cbn1cblxuY2xhc3MgTWF4S2V5IGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ01heEtleSc7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKCkge1xuICAgICAgICByZXR1cm4geyAkbWF4S2V5OiAxIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1heEtleSgpO1xuICAgIH1cbiAgICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3BlY3QoKTtcbiAgICB9XG4gICAgaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuICduZXcgTWF4S2V5KCknO1xuICAgIH1cbn1cblxuY2xhc3MgTWluS2V5IGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ01pbktleSc7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKCkge1xuICAgICAgICByZXR1cm4geyAkbWluS2V5OiAxIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1pbktleSgpO1xuICAgIH1cbiAgICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3BlY3QoKTtcbiAgICB9XG4gICAgaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuICduZXcgTWluS2V5KCknO1xuICAgIH1cbn1cblxuY29uc3QgY2hlY2tGb3JIZXhSZWdFeHAgPSBuZXcgUmVnRXhwKCdeWzAtOWEtZkEtRl17MjR9JCcpO1xubGV0IFBST0NFU1NfVU5JUVVFID0gbnVsbDtcbmNvbnN0IGtJZCA9IFN5bWJvbCgnaWQnKTtcbmNsYXNzIE9iamVjdElkIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ09iamVjdElkJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaW5wdXRJZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBsZXQgd29ya2luZ0lkO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0SWQgPT09ICdvYmplY3QnICYmIGlucHV0SWQgJiYgJ2lkJyBpbiBpbnB1dElkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0SWQuaWQgIT09ICdzdHJpbmcnICYmICFBcnJheUJ1ZmZlci5pc1ZpZXcoaW5wdXRJZC5pZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdBcmd1bWVudCBwYXNzZWQgaW4gbXVzdCBoYXZlIGFuIGlkIHRoYXQgaXMgb2YgdHlwZSBzdHJpbmcgb3IgQnVmZmVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3RvSGV4U3RyaW5nJyBpbiBpbnB1dElkICYmIHR5cGVvZiBpbnB1dElkLnRvSGV4U3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgd29ya2luZ0lkID0gQnl0ZVV0aWxzLmZyb21IZXgoaW5wdXRJZC50b0hleFN0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdvcmtpbmdJZCA9IGlucHV0SWQuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3b3JraW5nSWQgPSBpbnB1dElkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JraW5nSWQgPT0gbnVsbCB8fCB0eXBlb2Ygd29ya2luZ0lkID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpc1trSWRdID0gT2JqZWN0SWQuZ2VuZXJhdGUodHlwZW9mIHdvcmtpbmdJZCA9PT0gJ251bWJlcicgPyB3b3JraW5nSWQgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh3b3JraW5nSWQpICYmIHdvcmtpbmdJZC5ieXRlTGVuZ3RoID09PSAxMikge1xuICAgICAgICAgICAgdGhpc1trSWRdID0gQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKHdvcmtpbmdJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHdvcmtpbmdJZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh3b3JraW5nSWQubGVuZ3RoID09PSAxMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gQnl0ZVV0aWxzLmZyb21VVEY4KHdvcmtpbmdJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVzLmJ5dGVMZW5ndGggPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNba0lkXSA9IGJ5dGVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQXJndW1lbnQgcGFzc2VkIGluIG11c3QgYmUgYSBzdHJpbmcgb2YgMTIgYnl0ZXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3b3JraW5nSWQubGVuZ3RoID09PSAyNCAmJiBjaGVja0ZvckhleFJlZ0V4cC50ZXN0KHdvcmtpbmdJZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tJZF0gPSBCeXRlVXRpbHMuZnJvbUhleCh3b3JraW5nSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQXJndW1lbnQgcGFzc2VkIGluIG11c3QgYmUgYSBzdHJpbmcgb2YgMTIgYnl0ZXMgb3IgYSBzdHJpbmcgb2YgMjQgaGV4IGNoYXJhY3RlcnMgb3IgYW4gaW50ZWdlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQXJndW1lbnQgcGFzc2VkIGluIGRvZXMgbm90IG1hdGNoIHRoZSBhY2NlcHRlZCB0eXBlcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3RJZC5jYWNoZUhleFN0cmluZykge1xuICAgICAgICAgICAgdGhpcy5fX2lkID0gQnl0ZVV0aWxzLnRvSGV4KHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba0lkXTtcbiAgICB9XG4gICAgc2V0IGlkKHZhbHVlKSB7XG4gICAgICAgIHRoaXNba0lkXSA9IHZhbHVlO1xuICAgICAgICBpZiAoT2JqZWN0SWQuY2FjaGVIZXhTdHJpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX19pZCA9IEJ5dGVVdGlscy50b0hleCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9IZXhTdHJpbmcoKSB7XG4gICAgICAgIGlmIChPYmplY3RJZC5jYWNoZUhleFN0cmluZyAmJiB0aGlzLl9faWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9faWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGV4U3RyaW5nID0gQnl0ZVV0aWxzLnRvSGV4KHRoaXMuaWQpO1xuICAgICAgICBpZiAoT2JqZWN0SWQuY2FjaGVIZXhTdHJpbmcgJiYgIXRoaXMuX19pZCkge1xuICAgICAgICAgICAgdGhpcy5fX2lkID0gaGV4U3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhTdHJpbmc7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRJbmMoKSB7XG4gICAgICAgIHJldHVybiAoT2JqZWN0SWQuaW5kZXggPSAoT2JqZWN0SWQuaW5kZXggKyAxKSAlIDB4ZmZmZmZmKTtcbiAgICB9XG4gICAgc3RhdGljIGdlbmVyYXRlKHRpbWUpIHtcbiAgICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGltZSkge1xuICAgICAgICAgICAgdGltZSA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluYyA9IE9iamVjdElkLmdldEluYygpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBCeXRlVXRpbHMuYWxsb2NhdGUoMTIpO1xuICAgICAgICBCU09ORGF0YVZpZXcuZnJvbVVpbnQ4QXJyYXkoYnVmZmVyKS5zZXRVaW50MzIoMCwgdGltZSwgZmFsc2UpO1xuICAgICAgICBpZiAoUFJPQ0VTU19VTklRVUUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIFBST0NFU1NfVU5JUVVFID0gQnl0ZVV0aWxzLnJhbmRvbUJ5dGVzKDUpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlcls0XSA9IFBST0NFU1NfVU5JUVVFWzBdO1xuICAgICAgICBidWZmZXJbNV0gPSBQUk9DRVNTX1VOSVFVRVsxXTtcbiAgICAgICAgYnVmZmVyWzZdID0gUFJPQ0VTU19VTklRVUVbMl07XG4gICAgICAgIGJ1ZmZlcls3XSA9IFBST0NFU1NfVU5JUVVFWzNdO1xuICAgICAgICBidWZmZXJbOF0gPSBQUk9DRVNTX1VOSVFVRVs0XTtcbiAgICAgICAgYnVmZmVyWzExXSA9IGluYyAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlclsxMF0gPSAoaW5jID4+IDgpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyWzldID0gKGluYyA+PiAxNikgJiAweGZmO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgICB0b1N0cmluZyhlbmNvZGluZykge1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKVxuICAgICAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy50b0Jhc2U2NCh0aGlzLmlkKTtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnaGV4JylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVySWQpIHtcbiAgICAgICAgaWYgKG90aGVySWQgPT09IHVuZGVmaW5lZCB8fCBvdGhlcklkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVySWQgaW5zdGFuY2VvZiBPYmplY3RJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNba0lkXVsxMV0gPT09IG90aGVySWRba0lkXVsxMV0gJiYgQnl0ZVV0aWxzLmVxdWFscyh0aGlzW2tJZF0sIG90aGVySWRba0lkXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvdGhlcklkID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgT2JqZWN0SWQuaXNWYWxpZChvdGhlcklkKSAmJlxuICAgICAgICAgICAgb3RoZXJJZC5sZW5ndGggPT09IDEyICYmXG4gICAgICAgICAgICBpc1VpbnQ4QXJyYXkodGhpcy5pZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBCeXRlVXRpbHMuZXF1YWxzKHRoaXMuaWQsIEJ5dGVVdGlscy5mcm9tSVNPODg1OTEob3RoZXJJZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3RoZXJJZCA9PT0gJ3N0cmluZycgJiYgT2JqZWN0SWQuaXNWYWxpZChvdGhlcklkKSAmJiBvdGhlcklkLmxlbmd0aCA9PT0gMjQpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlcklkLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG90aGVySWQgPT09ICdzdHJpbmcnICYmIE9iamVjdElkLmlzVmFsaWQob3RoZXJJZCkgJiYgb3RoZXJJZC5sZW5ndGggPT09IDEyKSB7XG4gICAgICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLmVxdWFscyhCeXRlVXRpbHMuZnJvbVVURjgob3RoZXJJZCksIHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3RoZXJJZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICd0b0hleFN0cmluZycgaW4gb3RoZXJJZCAmJlxuICAgICAgICAgICAgdHlwZW9mIG90aGVySWQudG9IZXhTdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IG90aGVySWRTdHJpbmcgPSBvdGhlcklkLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCB0aGlzSWRTdHJpbmcgPSB0aGlzLnRvSGV4U3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb3RoZXJJZFN0cmluZyA9PT0gJ3N0cmluZycgJiYgb3RoZXJJZFN0cmluZy50b0xvd2VyQ2FzZSgpID09PSB0aGlzSWRTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXRUaW1lc3RhbXAoKSB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBCU09ORGF0YVZpZXcuZnJvbVVpbnQ4QXJyYXkodGhpcy5pZCkuZ2V0VWludDMyKDAsIGZhbHNlKTtcbiAgICAgICAgdGltZXN0YW1wLnNldFRpbWUoTWF0aC5mbG9vcih0aW1lKSAqIDEwMDApO1xuICAgICAgICByZXR1cm4gdGltZXN0YW1wO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlUGsoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQoKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21UaW1lKHRpbWUpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnl0ZVV0aWxzLmZyb21OdW1iZXJBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICBCU09ORGF0YVZpZXcuZnJvbVVpbnQ4QXJyYXkoYnVmZmVyKS5zZXRVaW50MzIoMCwgdGltZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gbmV3IE9iamVjdElkKGJ1ZmZlcik7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSGV4U3RyaW5nKGhleFN0cmluZykge1xuICAgICAgICBpZiAoaGV4U3RyaW5nPy5sZW5ndGggIT09IDI0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdoZXggc3RyaW5nIG11c3QgYmUgMjQgY2hhcmFjdGVycycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQoQnl0ZVV0aWxzLmZyb21IZXgoaGV4U3RyaW5nKSk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tQmFzZTY0KGJhc2U2NCkge1xuICAgICAgICBpZiAoYmFzZTY0Py5sZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdiYXNlNjQgc3RyaW5nIG11c3QgYmUgMTYgY2hhcmFjdGVycycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQoQnl0ZVV0aWxzLmZyb21CYXNlNjQoYmFzZTY0KSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc1ZhbGlkKGlkKSB7XG4gICAgICAgIGlmIChpZCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IE9iamVjdElkKGlkKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTigpIHtcbiAgICAgICAgaWYgKHRoaXMudG9IZXhTdHJpbmcpXG4gICAgICAgICAgICByZXR1cm4geyAkb2lkOiB0aGlzLnRvSGV4U3RyaW5nKCkgfTtcbiAgICAgICAgcmV0dXJuIHsgJG9pZDogdGhpcy50b1N0cmluZygnaGV4JykgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQoZG9jLiRvaWQpO1xuICAgIH1cbiAgICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3BlY3QoKTtcbiAgICB9XG4gICAgaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIGBuZXcgT2JqZWN0SWQoXCIke3RoaXMudG9IZXhTdHJpbmcoKX1cIilgO1xuICAgIH1cbn1cbk9iamVjdElkLmluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYpO1xuXG5mdW5jdGlvbiBpbnRlcm5hbENhbGN1bGF0ZU9iamVjdFNpemUob2JqZWN0LCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCkge1xuICAgIGxldCB0b3RhbExlbmd0aCA9IDQgKyAxO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IGNhbGN1bGF0ZUVsZW1lbnQoaS50b1N0cmluZygpLCBvYmplY3RbaV0sIHNlcmlhbGl6ZUZ1bmN0aW9ucywgdHJ1ZSwgaWdub3JlVW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Q/LnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LnRvQlNPTigpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IGNhbGN1bGF0ZUVsZW1lbnQoa2V5LCBvYmplY3Rba2V5XSwgc2VyaWFsaXplRnVuY3Rpb25zLCBmYWxzZSwgaWdub3JlVW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG90YWxMZW5ndGg7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVFbGVtZW50KG5hbWUsIHZhbHVlLCBzZXJpYWxpemVGdW5jdGlvbnMgPSBmYWxzZSwgaXNBcnJheSA9IGZhbHNlLCBpZ25vcmVVbmRlZmluZWQgPSBmYWxzZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWU/LnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvQlNPTigpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIDEgKyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxICsgNCArIEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aCh2YWx1ZSkgKyAxO1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgaWYgKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSAmJlxuICAgICAgICAgICAgICAgIHZhbHVlID49IEpTX0lOVF9NSU4gJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSA8PSBKU19JTlRfTUFYKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID49IEJTT05fSU5UMzJfTUlOICYmIHZhbHVlIDw9IEJTT05fSU5UMzJfTUFYKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDQgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArICg4ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICBpZiAoaXNBcnJheSB8fCAhaWdub3JlVW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgMTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDEgKyAxKTtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlLl9ic29udHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZVtTeW1ib2wuZm9yKCdAQG1kYi5ic29uLnZlcnNpb24nKV0gIT09IEJTT05fTUFKT1JfVkVSU0lPTikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09OVmVyc2lvbkVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlLl9ic29udHlwZSA9PT0gJ01pbktleScgfHwgdmFsdWUuX2Jzb250eXBlID09PSAnTWF4S2V5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ09iamVjdElkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDEyICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAgICAgICAgICAgaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgKyAoMSArIDQgKyAxKSArIHZhbHVlLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnTG9uZycgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZS5fYnNvbnR5cGUgPT09ICdEb3VibGUnIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUuX2Jzb250eXBlID09PSAnVGltZXN0YW1wJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0RlY2ltYWwxMjgnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgKyAoMTYgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0NvZGUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnNjb3BlICE9IG51bGwgJiYgT2JqZWN0LmtleXModmFsdWUuc2NvcGUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICAgICAgNCArXG4gICAgICAgICAgICAgICAgICAgICAgICA0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aCh2YWx1ZS5jb2RlLnRvU3RyaW5nKCkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxDYWxjdWxhdGVPYmplY3RTaXplKHZhbHVlLnNjb3BlLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICAgICAgNCArXG4gICAgICAgICAgICAgICAgICAgICAgICBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgodmFsdWUuY29kZS50b1N0cmluZygpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCaW5hcnknKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmluYXJ5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmFyeS5zdWJfdHlwZSA9PT0gQmluYXJ5LlNVQlRZUEVfQllURV9BUlJBWSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGJpbmFyeS5wb3NpdGlvbiArIDEgKyA0ICsgMSArIDQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArIChiaW5hcnkucG9zaXRpb24gKyAxICsgNCArIDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdTeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKHZhbHVlLnZhbHVlKSArXG4gICAgICAgICAgICAgICAgICAgIDQgK1xuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEQlJlZicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmRlcmVkX3ZhbHVlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICAkcmVmOiB2YWx1ZS5jb2xsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAkaWQ6IHZhbHVlLm9pZFxuICAgICAgICAgICAgICAgIH0sIHZhbHVlLmZpZWxkcyk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmRiICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJlZF92YWx1ZXNbJyRkYiddID0gdmFsdWUuZGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbENhbGN1bGF0ZU9iamVjdFNpemUob3JkZXJlZF92YWx1ZXMsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKHZhbHVlLnNvdXJjZSkgK1xuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlLmdsb2JhbCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZS5pZ25vcmVDYXNlID8gMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlLm11bHRpbGluZSA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQlNPTlJlZ0V4cCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKHZhbHVlLnBhdHRlcm4pICtcbiAgICAgICAgICAgICAgICAgICAgMSArXG4gICAgICAgICAgICAgICAgICAgIEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aCh2YWx1ZS5vcHRpb25zKSArXG4gICAgICAgICAgICAgICAgICAgIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxDYWxjdWxhdGVPYmplY3RTaXplKHZhbHVlLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCkgK1xuICAgICAgICAgICAgICAgICAgICAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZUZ1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICA0ICtcbiAgICAgICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKHZhbHVlLnRvU3RyaW5nKCkpICtcbiAgICAgICAgICAgICAgICAgICAgMSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBhbHBoYWJldGl6ZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCcnKS5zb3J0KCkuam9pbignJyk7XG59XG5jbGFzcyBCU09OUmVnRXhwIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0JTT05SZWdFeHAnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGFscGhhYmV0aXplKG9wdGlvbnMgPz8gJycpO1xuICAgICAgICBpZiAodGhpcy5wYXR0ZXJuLmluZGV4T2YoJ1xceDAwJykgIT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBCU09OIFJlZ2V4IHBhdHRlcm5zIGNhbm5vdCBjb250YWluIG51bGwgYnl0ZXMsIGZvdW5kOiAke0pTT04uc3RyaW5naWZ5KHRoaXMucGF0dGVybil9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbmRleE9mKCdcXHgwMCcpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgQlNPTiBSZWdleCBvcHRpb25zIGNhbm5vdCBjb250YWluIG51bGwgYnl0ZXMsIGZvdW5kOiAke0pTT04uc3RyaW5naWZ5KHRoaXMub3B0aW9ucyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMub3B0aW9uc1tpXSA9PT0gJ2knIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2ldID09PSAnbScgfHxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbaV0gPT09ICd4JyB8fFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1tpXSA9PT0gJ2wnIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2ldID09PSAncycgfHxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbaV0gPT09ICd1JykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBUaGUgcmVndWxhciBleHByZXNzaW9uIG9wdGlvbiBbJHt0aGlzLm9wdGlvbnNbaV19XSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHBhcnNlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zID8gb3B0aW9ucy5zcGxpdCgnJykuc29ydCgpLmpvaW4oJycpIDogJyc7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmIChvcHRpb25zLmxlZ2FjeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgJHJlZ2V4OiB0aGlzLnBhdHRlcm4sICRvcHRpb25zOiB0aGlzLm9wdGlvbnMgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAkcmVndWxhckV4cHJlc3Npb246IHsgcGF0dGVybjogdGhpcy5wYXR0ZXJuLCBvcHRpb25zOiB0aGlzLm9wdGlvbnMgfSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MpIHtcbiAgICAgICAgaWYgKCckcmVnZXgnIGluIGRvYykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2MuJHJlZ2V4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmIChkb2MuJHJlZ2V4Ll9ic29udHlwZSA9PT0gJ0JTT05SZWdFeHAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCU09OUmVnRXhwKGRvYy4kcmVnZXgsIEJTT05SZWdFeHAucGFyc2VPcHRpb25zKGRvYy4kb3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgnJHJlZ3VsYXJFeHByZXNzaW9uJyBpbiBkb2MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQlNPTlJlZ0V4cChkb2MuJHJlZ3VsYXJFeHByZXNzaW9uLnBhdHRlcm4sIEJTT05SZWdFeHAucGFyc2VPcHRpb25zKGRvYy4kcmVndWxhckV4cHJlc3Npb24ub3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYFVuZXhwZWN0ZWQgQlNPTlJlZ0V4cCBFSlNPTiBvYmplY3QgZm9ybTogJHtKU09OLnN0cmluZ2lmeShkb2MpfWApO1xuICAgIH1cbiAgICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3BlY3QoKTtcbiAgICB9XG4gICAgaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIGBuZXcgQlNPTlJlZ0V4cCgke0pTT04uc3RyaW5naWZ5KHRoaXMucGF0dGVybil9LCAke0pTT04uc3RyaW5naWZ5KHRoaXMub3B0aW9ucyl9KWA7XG4gICAgfVxufVxuXG5jbGFzcyBCU09OU3ltYm9sIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0JTT05TeW1ib2wnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiBgbmV3IEJTT05TeW1ib2woXCIke3RoaXMudmFsdWV9XCIpYDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04oKSB7XG4gICAgICAgIHJldHVybiB7ICRzeW1ib2w6IHRoaXMudmFsdWUgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgQlNPTlN5bWJvbChkb2MuJHN5bWJvbCk7XG4gICAgfVxuICAgIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpO1xuICAgIH1cbn1cblxuY29uc3QgTG9uZ1dpdGhvdXRPdmVycmlkZXNDbGFzcyA9IExvbmc7XG5jbGFzcyBUaW1lc3RhbXAgZXh0ZW5kcyBMb25nV2l0aG91dE92ZXJyaWRlc0NsYXNzIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ1RpbWVzdGFtcCc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGxvdykge1xuICAgICAgICBpZiAobG93ID09IG51bGwpIHtcbiAgICAgICAgICAgIHN1cGVyKDAsIDAsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsb3cgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBzdXBlcihsb3csIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKExvbmcuaXNMb25nKGxvdykpIHtcbiAgICAgICAgICAgIHN1cGVyKGxvdy5sb3csIGxvdy5oaWdoLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbG93ID09PSAnb2JqZWN0JyAmJiAndCcgaW4gbG93ICYmICdpJyBpbiBsb3cpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbG93LnQgIT09ICdudW1iZXInICYmICh0eXBlb2YgbG93LnQgIT09ICdvYmplY3QnIHx8IGxvdy50Ll9ic29udHlwZSAhPT0gJ0ludDMyJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdUaW1lc3RhbXAgY29uc3RydWN0ZWQgZnJvbSB7IHQsIGkgfSBtdXN0IHByb3ZpZGUgdCBhcyBhIG51bWJlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb3cuaSAhPT0gJ251bWJlcicgJiYgKHR5cGVvZiBsb3cuaSAhPT0gJ29iamVjdCcgfHwgbG93LmkuX2Jzb250eXBlICE9PSAnSW50MzInKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ1RpbWVzdGFtcCBjb25zdHJ1Y3RlZCBmcm9tIHsgdCwgaSB9IG11c3QgcHJvdmlkZSBpIGFzIGEgbnVtYmVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ID0gTnVtYmVyKGxvdy50KTtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBOdW1iZXIobG93LmkpO1xuICAgICAgICAgICAgaWYgKHQgPCAwIHx8IE51bWJlci5pc05hTih0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ1RpbWVzdGFtcCBjb25zdHJ1Y3RlZCBmcm9tIHsgdCwgaSB9IG11c3QgcHJvdmlkZSBhIHBvc2l0aXZlIHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpIDwgMCB8fCBOdW1iZXIuaXNOYU4oaSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdUaW1lc3RhbXAgY29uc3RydWN0ZWQgZnJvbSB7IHQsIGkgfSBtdXN0IHByb3ZpZGUgYSBwb3NpdGl2ZSBpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodCA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdUaW1lc3RhbXAgY29uc3RydWN0ZWQgZnJvbSB7IHQsIGkgfSBtdXN0IHByb3ZpZGUgdCBlcXVhbCBvciBsZXNzIHRoYW4gdWludDMyIG1heCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVGltZXN0YW1wIGNvbnN0cnVjdGVkIGZyb20geyB0LCBpIH0gbXVzdCBwcm92aWRlIGkgZXF1YWwgb3IgbGVzcyB0aGFuIHVpbnQzMiBtYXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1cGVyKGksIHQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQSBUaW1lc3RhbXAgY2FuIG9ubHkgYmUgY29uc3RydWN0ZWQgd2l0aDogYmlnaW50LCBMb25nLCBvciB7IHQ6IG51bWJlcjsgaTogbnVtYmVyIH0nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAkdGltZXN0YW1wOiB0aGlzLnRvU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21JbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoTG9uZy5mcm9tSW50KHZhbHVlLCB0cnVlKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKExvbmcuZnJvbU51bWJlcih2YWx1ZSwgdHJ1ZSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoeyBpOiBsb3dCaXRzLCB0OiBoaWdoQml0cyB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcoc3RyLCBvcHRSYWRpeCkge1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcChMb25nLmZyb21TdHJpbmcoc3RyLCB0cnVlLCBvcHRSYWRpeCkpO1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgJHRpbWVzdGFtcDogeyB0OiB0aGlzLmhpZ2ggPj4+IDAsIGk6IHRoaXMubG93ID4+PiAwIH0gfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jKSB7XG4gICAgICAgIGNvbnN0IGkgPSBMb25nLmlzTG9uZyhkb2MuJHRpbWVzdGFtcC5pKVxuICAgICAgICAgICAgPyBkb2MuJHRpbWVzdGFtcC5pLmdldExvd0JpdHNVbnNpZ25lZCgpXG4gICAgICAgICAgICA6IGRvYy4kdGltZXN0YW1wLmk7XG4gICAgICAgIGNvbnN0IHQgPSBMb25nLmlzTG9uZyhkb2MuJHRpbWVzdGFtcC50KVxuICAgICAgICAgICAgPyBkb2MuJHRpbWVzdGFtcC50LmdldExvd0JpdHNVbnNpZ25lZCgpXG4gICAgICAgICAgICA6IGRvYy4kdGltZXN0YW1wLnQ7XG4gICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKHsgdCwgaSB9KTtcbiAgICB9XG4gICAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCk7XG4gICAgfVxuICAgIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiBgbmV3IFRpbWVzdGFtcCh7IHQ6ICR7dGhpcy5nZXRIaWdoQml0cygpfSwgaTogJHt0aGlzLmdldExvd0JpdHMoKX0gfSlgO1xuICAgIH1cbn1cblRpbWVzdGFtcC5NQVhfVkFMVUUgPSBMb25nLk1BWF9VTlNJR05FRF9WQUxVRTtcblxuY29uc3QgRklSU1RfQklUID0gMHg4MDtcbmNvbnN0IEZJUlNUX1RXT19CSVRTID0gMHhjMDtcbmNvbnN0IEZJUlNUX1RIUkVFX0JJVFMgPSAweGUwO1xuY29uc3QgRklSU1RfRk9VUl9CSVRTID0gMHhmMDtcbmNvbnN0IEZJUlNUX0ZJVkVfQklUUyA9IDB4Zjg7XG5jb25zdCBUV09fQklUX0NIQVIgPSAweGMwO1xuY29uc3QgVEhSRUVfQklUX0NIQVIgPSAweGUwO1xuY29uc3QgRk9VUl9CSVRfQ0hBUiA9IDB4ZjA7XG5jb25zdCBDT05USU5VSU5HX0NIQVIgPSAweDgwO1xuZnVuY3Rpb24gdmFsaWRhdGVVdGY4KGJ5dGVzLCBzdGFydCwgZW5kKSB7XG4gICAgbGV0IGNvbnRpbnVhdGlvbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgYnl0ZSA9IGJ5dGVzW2ldO1xuICAgICAgICBpZiAoY29udGludWF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoKGJ5dGUgJiBGSVJTVF9UV09fQklUUykgIT09IENPTlRJTlVJTkdfQ0hBUikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVhdGlvbiAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJ5dGUgJiBGSVJTVF9CSVQpIHtcbiAgICAgICAgICAgIGlmICgoYnl0ZSAmIEZJUlNUX1RIUkVFX0JJVFMpID09PSBUV09fQklUX0NIQVIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51YXRpb24gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKGJ5dGUgJiBGSVJTVF9GT1VSX0JJVFMpID09PSBUSFJFRV9CSVRfQ0hBUikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVhdGlvbiA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoYnl0ZSAmIEZJUlNUX0ZJVkVfQklUUykgPT09IEZPVVJfQklUX0NIQVIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51YXRpb24gPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhY29udGludWF0aW9uO1xufVxuXG5jb25zdCBKU19JTlRfTUFYX0xPTkcgPSBMb25nLmZyb21OdW1iZXIoSlNfSU5UX01BWCk7XG5jb25zdCBKU19JTlRfTUlOX0xPTkcgPSBMb25nLmZyb21OdW1iZXIoSlNfSU5UX01JTik7XG5mdW5jdGlvbiBpbnRlcm5hbERlc2VyaWFsaXplKGJ1ZmZlciwgb3B0aW9ucywgaXNBcnJheSkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID09IG51bGwgPyB7fSA6IG9wdGlvbnM7XG4gICAgY29uc3QgaW5kZXggPSBvcHRpb25zICYmIG9wdGlvbnMuaW5kZXggPyBvcHRpb25zLmluZGV4IDogMDtcbiAgICBjb25zdCBzaXplID0gYnVmZmVyW2luZGV4XSB8XG4gICAgICAgIChidWZmZXJbaW5kZXggKyAxXSA8PCA4KSB8XG4gICAgICAgIChidWZmZXJbaW5kZXggKyAyXSA8PCAxNikgfFxuICAgICAgICAoYnVmZmVyW2luZGV4ICsgM10gPDwgMjQpO1xuICAgIGlmIChzaXplIDwgNSkge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBic29uIHNpemUgbXVzdCBiZSA+PSA1LCBpcyAke3NpemV9YCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFsbG93T2JqZWN0U21hbGxlclRoYW5CdWZmZXJTaXplICYmIGJ1ZmZlci5sZW5ndGggPCBzaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYGJ1ZmZlciBsZW5ndGggJHtidWZmZXIubGVuZ3RofSBtdXN0IGJlID49IGJzb24gc2l6ZSAke3NpemV9YCk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5hbGxvd09iamVjdFNtYWxsZXJUaGFuQnVmZmVyU2l6ZSAmJiBidWZmZXIubGVuZ3RoICE9PSBzaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYGJ1ZmZlciBsZW5ndGggJHtidWZmZXIubGVuZ3RofSBtdXN0ID09PSBic29uIHNpemUgJHtzaXplfWApO1xuICAgIH1cbiAgICBpZiAoc2l6ZSArIGluZGV4ID4gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgKGJzb24gc2l6ZSAke3NpemV9ICsgb3B0aW9ucy5pbmRleCAke2luZGV4fSBtdXN0IGJlIDw9IGJ1ZmZlciBsZW5ndGggJHtidWZmZXIuYnl0ZUxlbmd0aH0pYCk7XG4gICAgfVxuICAgIGlmIChidWZmZXJbaW5kZXggKyBzaXplIC0gMV0gIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihcIk9uZSBvYmplY3QsIHNpemVkIGNvcnJlY3RseSwgd2l0aCBhIHNwb3QgZm9yIGFuIEVPTywgYnV0IHRoZSBFT08gaXNuJ3QgMHgwMFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwgaW5kZXgsIG9wdGlvbnMsIGlzQXJyYXkpO1xufVxuY29uc3QgYWxsb3dlZERCUmVmS2V5cyA9IC9eXFwkcmVmJHxeXFwkaWQkfF5cXCRkYiQvO1xuZnVuY3Rpb24gZGVzZXJpYWxpemVPYmplY3QoYnVmZmVyLCBpbmRleCwgb3B0aW9ucywgaXNBcnJheSA9IGZhbHNlKSB7XG4gICAgY29uc3QgZmllbGRzQXNSYXcgPSBvcHRpb25zWydmaWVsZHNBc1JhdyddID09IG51bGwgPyBudWxsIDogb3B0aW9uc1snZmllbGRzQXNSYXcnXTtcbiAgICBjb25zdCByYXcgPSBvcHRpb25zWydyYXcnXSA9PSBudWxsID8gZmFsc2UgOiBvcHRpb25zWydyYXcnXTtcbiAgICBjb25zdCBic29uUmVnRXhwID0gdHlwZW9mIG9wdGlvbnNbJ2Jzb25SZWdFeHAnXSA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9uc1snYnNvblJlZ0V4cCddIDogZmFsc2U7XG4gICAgY29uc3QgcHJvbW90ZUJ1ZmZlcnMgPSBvcHRpb25zLnByb21vdGVCdWZmZXJzID8/IGZhbHNlO1xuICAgIGNvbnN0IHByb21vdGVMb25ncyA9IG9wdGlvbnMucHJvbW90ZUxvbmdzID8/IHRydWU7XG4gICAgY29uc3QgcHJvbW90ZVZhbHVlcyA9IG9wdGlvbnMucHJvbW90ZVZhbHVlcyA/PyB0cnVlO1xuICAgIGNvbnN0IHVzZUJpZ0ludDY0ID0gb3B0aW9ucy51c2VCaWdJbnQ2NCA/PyBmYWxzZTtcbiAgICBpZiAodXNlQmlnSW50NjQgJiYgIXByb21vdGVWYWx1ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignTXVzdCBlaXRoZXIgcmVxdWVzdCBiaWdpbnQgb3IgTG9uZyBmb3IgaW50NjQgZGVzZXJpYWxpemF0aW9uJyk7XG4gICAgfVxuICAgIGlmICh1c2VCaWdJbnQ2NCAmJiAhcHJvbW90ZUxvbmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ011c3QgZWl0aGVyIHJlcXVlc3QgYmlnaW50IG9yIExvbmcgZm9yIGludDY0IGRlc2VyaWFsaXphdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0aW9uID0gb3B0aW9ucy52YWxpZGF0aW9uID09IG51bGwgPyB7IHV0Zjg6IHRydWUgfSA6IG9wdGlvbnMudmFsaWRhdGlvbjtcbiAgICBsZXQgZ2xvYmFsVVRGVmFsaWRhdGlvbiA9IHRydWU7XG4gICAgbGV0IHZhbGlkYXRpb25TZXR0aW5nO1xuICAgIGNvbnN0IHV0ZjhLZXlzU2V0ID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHV0ZjhWYWxpZGF0ZWRLZXlzID0gdmFsaWRhdGlvbi51dGY4O1xuICAgIGlmICh0eXBlb2YgdXRmOFZhbGlkYXRlZEtleXMgPT09ICdib29sZWFuJykge1xuICAgICAgICB2YWxpZGF0aW9uU2V0dGluZyA9IHV0ZjhWYWxpZGF0ZWRLZXlzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsVVRGVmFsaWRhdGlvbiA9IGZhbHNlO1xuICAgICAgICBjb25zdCB1dGY4VmFsaWRhdGlvblZhbHVlcyA9IE9iamVjdC5rZXlzKHV0ZjhWYWxpZGF0ZWRLZXlzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHV0ZjhWYWxpZGF0ZWRLZXlzW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodXRmOFZhbGlkYXRpb25WYWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdVVEYtOCB2YWxpZGF0aW9uIHNldHRpbmcgY2Fubm90IGJlIGVtcHR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB1dGY4VmFsaWRhdGlvblZhbHVlc1swXSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdJbnZhbGlkIFVURi04IHZhbGlkYXRpb24gb3B0aW9uLCBtdXN0IHNwZWNpZnkgYm9vbGVhbiB2YWx1ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0aW9uU2V0dGluZyA9IHV0ZjhWYWxpZGF0aW9uVmFsdWVzWzBdO1xuICAgICAgICBpZiAoIXV0ZjhWYWxpZGF0aW9uVmFsdWVzLmV2ZXJ5KGl0ZW0gPT4gaXRlbSA9PT0gdmFsaWRhdGlvblNldHRpbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdJbnZhbGlkIFVURi04IHZhbGlkYXRpb24gb3B0aW9uIC0ga2V5cyBtdXN0IGJlIGFsbCB0cnVlIG9yIGFsbCBmYWxzZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghZ2xvYmFsVVRGVmFsaWRhdGlvbikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh1dGY4VmFsaWRhdGVkS2V5cykpIHtcbiAgICAgICAgICAgIHV0ZjhLZXlzU2V0LmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDUpXG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2NvcnJ1cHQgYnNvbiBtZXNzYWdlIDwgNSBieXRlcyBsb25nJyk7XG4gICAgY29uc3Qgc2l6ZSA9IGJ1ZmZlcltpbmRleCsrXSB8IChidWZmZXJbaW5kZXgrK10gPDwgOCkgfCAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgIGlmIChzaXplIDwgNSB8fCBzaXplID4gYnVmZmVyLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignY29ycnVwdCBic29uIG1lc3NhZ2UnKTtcbiAgICBjb25zdCBvYmplY3QgPSBpc0FycmF5ID8gW10gOiB7fTtcbiAgICBsZXQgYXJyYXlJbmRleCA9IDA7XG4gICAgY29uc3QgZG9uZSA9IGZhbHNlO1xuICAgIGxldCBpc1Bvc3NpYmxlREJSZWYgPSBpc0FycmF5ID8gZmFsc2UgOiBudWxsO1xuICAgIGNvbnN0IGRhdGF2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlci5idWZmZXIsIGJ1ZmZlci5ieXRlT2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRUeXBlID0gYnVmZmVyW2luZGV4KytdO1xuICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGkgPSBpbmRleDtcbiAgICAgICAgd2hpbGUgKGJ1ZmZlcltpXSAhPT0gMHgwMCAmJiBpIDwgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID49IGJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQmFkIEJTT04gRG9jdW1lbnQ6IGlsbGVnYWwgQ1N0cmluZycpO1xuICAgICAgICBjb25zdCBuYW1lID0gaXNBcnJheSA/IGFycmF5SW5kZXgrKyA6IEJ5dGVVdGlscy50b1VURjgoYnVmZmVyLCBpbmRleCwgaSk7XG4gICAgICAgIGxldCBzaG91bGRWYWxpZGF0ZUtleSA9IHRydWU7XG4gICAgICAgIGlmIChnbG9iYWxVVEZWYWxpZGF0aW9uIHx8IHV0ZjhLZXlzU2V0LmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgc2hvdWxkVmFsaWRhdGVLZXkgPSB2YWxpZGF0aW9uU2V0dGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNob3VsZFZhbGlkYXRlS2V5ID0gIXZhbGlkYXRpb25TZXR0aW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Bvc3NpYmxlREJSZWYgIT09IGZhbHNlICYmIG5hbWVbMF0gPT09ICckJykge1xuICAgICAgICAgICAgaXNQb3NzaWJsZURCUmVmID0gYWxsb3dlZERCUmVmS2V5cy50ZXN0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgaW5kZXggPSBpICsgMTtcbiAgICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfU1RSSU5HKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdTaXplID0gYnVmZmVyW2luZGV4KytdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgICAgICBpZiAoc3RyaW5nU2l6ZSA8PSAwIHx8XG4gICAgICAgICAgICAgICAgc3RyaW5nU2l6ZSA+IGJ1ZmZlci5sZW5ndGggLSBpbmRleCB8fFxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpbmRleCArIHN0cmluZ1NpemUgLSAxXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2JhZCBzdHJpbmcgbGVuZ3RoIGluIGJzb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gZ2V0VmFsaWRhdGVkU3RyaW5nKGJ1ZmZlciwgaW5kZXgsIGluZGV4ICsgc3RyaW5nU2l6ZSAtIDEsIHNob3VsZFZhbGlkYXRlS2V5KTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBzdHJpbmdTaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfT0lEKSB7XG4gICAgICAgICAgICBjb25zdCBvaWQgPSBCeXRlVXRpbHMuYWxsb2NhdGUoMTIpO1xuICAgICAgICAgICAgb2lkLnNldChidWZmZXIuc3ViYXJyYXkoaW5kZXgsIGluZGV4ICsgMTIpKTtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IE9iamVjdElkKG9pZCk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgMTI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9JTlQgJiYgcHJvbW90ZVZhbHVlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IEludDMyKGJ1ZmZlcltpbmRleCsrXSB8IChidWZmZXJbaW5kZXgrK10gPDwgOCkgfCAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMjQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0lOVCkge1xuICAgICAgICAgICAgdmFsdWUgPVxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpbmRleCsrXSB8XG4gICAgICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgOCkgfFxuICAgICAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfTlVNQkVSICYmIHByb21vdGVWYWx1ZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBEb3VibGUoZGF0YXZpZXcuZ2V0RmxvYXQ2NChpbmRleCwgdHJ1ZSkpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIDg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9OVU1CRVIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZGF0YXZpZXcuZ2V0RmxvYXQ2NChpbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0RBVEUpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvd0JpdHMgPSBidWZmZXJbaW5kZXgrK10gfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hCaXRzID0gYnVmZmVyW2luZGV4KytdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKG5ldyBMb25nKGxvd0JpdHMsIGhpZ2hCaXRzKS50b051bWJlcigpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0JPT0xFQU4pIHtcbiAgICAgICAgICAgIGlmIChidWZmZXJbaW5kZXhdICE9PSAwICYmIGJ1ZmZlcltpbmRleF0gIT09IDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignaWxsZWdhbCBib29sZWFuIHR5cGUgdmFsdWUnKTtcbiAgICAgICAgICAgIHZhbHVlID0gYnVmZmVyW2luZGV4KytdID09PSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfT0JKRUNUKSB7XG4gICAgICAgICAgICBjb25zdCBfaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdFNpemUgPSBidWZmZXJbaW5kZXhdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4ICsgMV0gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXggKyAyXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXggKyAzXSA8PCAyNCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0U2l6ZSA8PSAwIHx8IG9iamVjdFNpemUgPiBidWZmZXIubGVuZ3RoIC0gaW5kZXgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignYmFkIGVtYmVkZGVkIGRvY3VtZW50IGxlbmd0aCBpbiBic29uJyk7XG4gICAgICAgICAgICBpZiAocmF3KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBidWZmZXIuc2xpY2UoaW5kZXgsIGluZGV4ICsgb2JqZWN0U2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgb2JqZWN0T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKCFnbG9iYWxVVEZWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIHZhbGlkYXRpb246IHsgdXRmODogc2hvdWxkVmFsaWRhdGVLZXkgfSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwgX2luZGV4LCBvYmplY3RPcHRpb25zLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgb2JqZWN0U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0FSUkFZKSB7XG4gICAgICAgICAgICBjb25zdCBfaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdFNpemUgPSBidWZmZXJbaW5kZXhdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4ICsgMV0gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXggKyAyXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXggKyAzXSA8PCAyNCk7XG4gICAgICAgICAgICBsZXQgYXJyYXlPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IHN0b3BJbmRleCA9IGluZGV4ICsgb2JqZWN0U2l6ZTtcbiAgICAgICAgICAgIGlmIChmaWVsZHNBc1JhdyAmJiBmaWVsZHNBc1Jhd1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGFycmF5T3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgcmF3OiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWdsb2JhbFVURlZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICBhcnJheU9wdGlvbnMgPSB7IC4uLmFycmF5T3B0aW9ucywgdmFsaWRhdGlvbjogeyB1dGY4OiBzaG91bGRWYWxpZGF0ZUtleSB9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IGRlc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwgX2luZGV4LCBhcnJheU9wdGlvbnMsIHRydWUpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIG9iamVjdFNpemU7XG4gICAgICAgICAgICBpZiAoYnVmZmVyW2luZGV4IC0gMV0gIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignaW52YWxpZCBhcnJheSB0ZXJtaW5hdG9yIGJ5dGUnKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gc3RvcEluZGV4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2NvcnJ1cHRlZCBhcnJheSBic29uJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9VTkRFRklORUQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfTlVMTCkge1xuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfTE9ORykge1xuICAgICAgICAgICAgY29uc3QgZGF0YXZpZXcgPSBCU09ORGF0YVZpZXcuZnJvbVVpbnQ4QXJyYXkoYnVmZmVyLnN1YmFycmF5KGluZGV4LCBpbmRleCArIDgpKTtcbiAgICAgICAgICAgIGNvbnN0IGxvd0JpdHMgPSBidWZmZXJbaW5kZXgrK10gfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hCaXRzID0gYnVmZmVyW2luZGV4KytdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgICAgICBjb25zdCBsb25nID0gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMpO1xuICAgICAgICAgICAgaWYgKHVzZUJpZ0ludDY0KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkYXRhdmlldy5nZXRCaWdJbnQ2NCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb21vdGVMb25ncyAmJiBwcm9tb3RlVmFsdWVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICBsb25nLmxlc3NUaGFuT3JFcXVhbChKU19JTlRfTUFYX0xPTkcpICYmIGxvbmcuZ3JlYXRlclRoYW5PckVxdWFsKEpTX0lOVF9NSU5fTE9ORylcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbG9uZy50b051bWJlcigpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGxvbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxvbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9ERUNJTUFMMTI4KSB7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IEJ5dGVVdGlscy5hbGxvY2F0ZSgxNik7XG4gICAgICAgICAgICBieXRlcy5zZXQoYnVmZmVyLnN1YmFycmF5KGluZGV4LCBpbmRleCArIDE2KSwgMCk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgMTY7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBEZWNpbWFsMTI4KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0JJTkFSWSkge1xuICAgICAgICAgICAgbGV0IGJpbmFyeVNpemUgPSBidWZmZXJbaW5kZXgrK10gfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsQmluYXJ5U2l6ZSA9IGJpbmFyeVNpemU7XG4gICAgICAgICAgICBjb25zdCBzdWJUeXBlID0gYnVmZmVyW2luZGV4KytdO1xuICAgICAgICAgICAgaWYgKGJpbmFyeVNpemUgPCAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ05lZ2F0aXZlIGJpbmFyeSB0eXBlIGVsZW1lbnQgc2l6ZSBmb3VuZCcpO1xuICAgICAgICAgICAgaWYgKGJpbmFyeVNpemUgPiBidWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCaW5hcnkgdHlwZSBzaXplIGxhcmdlciB0aGFuIGRvY3VtZW50IHNpemUnKTtcbiAgICAgICAgICAgIGlmIChidWZmZXJbJ3NsaWNlJ10gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChzdWJUeXBlID09PSBCaW5hcnkuU1VCVFlQRV9CWVRFX0FSUkFZKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeVNpemUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4KytdIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaW5hcnlTaXplIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ05lZ2F0aXZlIGJpbmFyeSB0eXBlIGVsZW1lbnQgc2l6ZSBmb3VuZCBmb3Igc3VidHlwZSAweDAyJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaW5hcnlTaXplID4gdG90YWxCaW5hcnlTaXplIC0gNClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JpbmFyeSB0eXBlIHdpdGggc3VidHlwZSAweDAyIGNvbnRhaW5zIHRvbyBsb25nIGJpbmFyeSBzaXplJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaW5hcnlTaXplIDwgdG90YWxCaW5hcnlTaXplIC0gNClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JpbmFyeSB0eXBlIHdpdGggc3VidHlwZSAweDAyIGNvbnRhaW5zIHRvbyBzaG9ydCBiaW5hcnkgc2l6ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvbW90ZUJ1ZmZlcnMgJiYgcHJvbW90ZVZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEJ5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIuc2xpY2UoaW5kZXgsIGluZGV4ICsgYmluYXJ5U2l6ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQmluYXJ5KGJ1ZmZlci5zbGljZShpbmRleCwgaW5kZXggKyBiaW5hcnlTaXplKSwgc3ViVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJUeXBlID09PSBCU09OX0JJTkFSWV9TVUJUWVBFX1VVSURfTkVXICYmIFVVSUQuaXNWYWxpZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9VVUlEKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfYnVmZmVyID0gQnl0ZVV0aWxzLmFsbG9jYXRlKGJpbmFyeVNpemUpO1xuICAgICAgICAgICAgICAgIGlmIChzdWJUeXBlID09PSBCaW5hcnkuU1VCVFlQRV9CWVRFX0FSUkFZKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeVNpemUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4KytdIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaW5hcnlTaXplIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ05lZ2F0aXZlIGJpbmFyeSB0eXBlIGVsZW1lbnQgc2l6ZSBmb3VuZCBmb3Igc3VidHlwZSAweDAyJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaW5hcnlTaXplID4gdG90YWxCaW5hcnlTaXplIC0gNClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JpbmFyeSB0eXBlIHdpdGggc3VidHlwZSAweDAyIGNvbnRhaW5zIHRvbyBsb25nIGJpbmFyeSBzaXplJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaW5hcnlTaXplIDwgdG90YWxCaW5hcnlTaXplIC0gNClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JpbmFyeSB0eXBlIHdpdGggc3VidHlwZSAweDAyIGNvbnRhaW5zIHRvbyBzaG9ydCBiaW5hcnkgc2l6ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmluYXJ5U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9idWZmZXJbaV0gPSBidWZmZXJbaW5kZXggKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb21vdGVCdWZmZXJzICYmIHByb21vdGVWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYnVmZmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQmluYXJ5KGJ1ZmZlci5zbGljZShpbmRleCwgaW5kZXggKyBiaW5hcnlTaXplKSwgc3ViVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJUeXBlID09PSBCU09OX0JJTkFSWV9TVUJUWVBFX1VVSURfTkVXICYmIFVVSUQuaXNWYWxpZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9VVUlEKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgYmluYXJ5U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX1JFR0VYUCAmJiBic29uUmVnRXhwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaSA9IGluZGV4O1xuICAgICAgICAgICAgd2hpbGUgKGJ1ZmZlcltpXSAhPT0gMHgwMCAmJiBpIDwgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID49IGJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQmFkIEJTT04gRG9jdW1lbnQ6IGlsbGVnYWwgQ1N0cmluZycpO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gQnl0ZVV0aWxzLnRvVVRGOChidWZmZXIsIGluZGV4LCBpKTtcbiAgICAgICAgICAgIGluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICBpID0gaW5kZXg7XG4gICAgICAgICAgICB3aGlsZSAoYnVmZmVyW2ldICE9PSAweDAwICYmIGkgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPj0gYnVmZmVyLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCYWQgQlNPTiBEb2N1bWVudDogaWxsZWdhbCBDU3RyaW5nJyk7XG4gICAgICAgICAgICBjb25zdCByZWdFeHBPcHRpb25zID0gQnl0ZVV0aWxzLnRvVVRGOChidWZmZXIsIGluZGV4LCBpKTtcbiAgICAgICAgICAgIGluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zQXJyYXkgPSBuZXcgQXJyYXkocmVnRXhwT3B0aW9ucy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlZ0V4cE9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlZ0V4cE9wdGlvbnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zQXJyYXlbaV0gPSAnbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zQXJyYXlbaV0gPSAnZyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zQXJyYXlbaV0gPSAnaSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBSZWdFeHAoc291cmNlLCBvcHRpb25zQXJyYXkuam9pbignJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfUkVHRVhQICYmIGJzb25SZWdFeHAgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGkgPSBpbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChidWZmZXJbaV0gIT09IDB4MDAgJiYgaSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+PSBidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JhZCBCU09OIERvY3VtZW50OiBpbGxlZ2FsIENTdHJpbmcnKTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IEJ5dGVVdGlscy50b1VURjgoYnVmZmVyLCBpbmRleCwgaSk7XG4gICAgICAgICAgICBpbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgaSA9IGluZGV4O1xuICAgICAgICAgICAgd2hpbGUgKGJ1ZmZlcltpXSAhPT0gMHgwMCAmJiBpIDwgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID49IGJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQmFkIEJTT04gRG9jdW1lbnQ6IGlsbGVnYWwgQ1N0cmluZycpO1xuICAgICAgICAgICAgY29uc3QgcmVnRXhwT3B0aW9ucyA9IEJ5dGVVdGlscy50b1VURjgoYnVmZmVyLCBpbmRleCwgaSk7XG4gICAgICAgICAgICBpbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgQlNPTlJlZ0V4cChzb3VyY2UsIHJlZ0V4cE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfU1lNQk9MKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdTaXplID0gYnVmZmVyW2luZGV4KytdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgICAgICBpZiAoc3RyaW5nU2l6ZSA8PSAwIHx8XG4gICAgICAgICAgICAgICAgc3RyaW5nU2l6ZSA+IGJ1ZmZlci5sZW5ndGggLSBpbmRleCB8fFxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpbmRleCArIHN0cmluZ1NpemUgLSAxXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2JhZCBzdHJpbmcgbGVuZ3RoIGluIGJzb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IGdldFZhbGlkYXRlZFN0cmluZyhidWZmZXIsIGluZGV4LCBpbmRleCArIHN0cmluZ1NpemUgLSAxLCBzaG91bGRWYWxpZGF0ZUtleSk7XG4gICAgICAgICAgICB2YWx1ZSA9IHByb21vdGVWYWx1ZXMgPyBzeW1ib2wgOiBuZXcgQlNPTlN5bWJvbChzeW1ib2wpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIHN0cmluZ1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9USU1FU1RBTVApIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBidWZmZXJbaW5kZXgrK10gK1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltpbmRleCsrXSAqICgxIDw8IDgpICtcbiAgICAgICAgICAgICAgICBidWZmZXJbaW5kZXgrK10gKiAoMSA8PCAxNikgK1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltpbmRleCsrXSAqICgxIDw8IDI0KTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBidWZmZXJbaW5kZXgrK10gK1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltpbmRleCsrXSAqICgxIDw8IDgpICtcbiAgICAgICAgICAgICAgICBidWZmZXJbaW5kZXgrK10gKiAoMSA8PCAxNikgK1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltpbmRleCsrXSAqICgxIDw8IDI0KTtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IFRpbWVzdGFtcCh7IGksIHQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9NSU5fS0VZKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBNaW5LZXkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX01BWF9LRVkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IE1heEtleSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfQ09ERSkge1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5nU2l6ZSA9IGJ1ZmZlcltpbmRleCsrXSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICAgICAgaWYgKHN0cmluZ1NpemUgPD0gMCB8fFxuICAgICAgICAgICAgICAgIHN0cmluZ1NpemUgPiBidWZmZXIubGVuZ3RoIC0gaW5kZXggfHxcbiAgICAgICAgICAgICAgICBidWZmZXJbaW5kZXggKyBzdHJpbmdTaXplIC0gMV0gIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdiYWQgc3RyaW5nIGxlbmd0aCBpbiBic29uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmdW5jdGlvblN0cmluZyA9IGdldFZhbGlkYXRlZFN0cmluZyhidWZmZXIsIGluZGV4LCBpbmRleCArIHN0cmluZ1NpemUgLSAxLCBzaG91bGRWYWxpZGF0ZUtleSk7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBDb2RlKGZ1bmN0aW9uU3RyaW5nKTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBzdHJpbmdTaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfQ09ERV9XX1NDT1BFKSB7XG4gICAgICAgICAgICBjb25zdCB0b3RhbFNpemUgPSBidWZmZXJbaW5kZXgrK10gfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgICAgIGlmICh0b3RhbFNpemUgPCA0ICsgNCArIDQgKyAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignY29kZV93X3Njb3BlIHRvdGFsIHNpemUgc2hvcnRlciBtaW5pbXVtIGV4cGVjdGVkIGxlbmd0aCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RyaW5nU2l6ZSA9IGJ1ZmZlcltpbmRleCsrXSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICAgICAgaWYgKHN0cmluZ1NpemUgPD0gMCB8fFxuICAgICAgICAgICAgICAgIHN0cmluZ1NpemUgPiBidWZmZXIubGVuZ3RoIC0gaW5kZXggfHxcbiAgICAgICAgICAgICAgICBidWZmZXJbaW5kZXggKyBzdHJpbmdTaXplIC0gMV0gIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdiYWQgc3RyaW5nIGxlbmd0aCBpbiBic29uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmdW5jdGlvblN0cmluZyA9IGdldFZhbGlkYXRlZFN0cmluZyhidWZmZXIsIGluZGV4LCBpbmRleCArIHN0cmluZ1NpemUgLSAxLCBzaG91bGRWYWxpZGF0ZUtleSk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgc3RyaW5nU2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IF9pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0U2l6ZSA9IGJ1ZmZlcltpbmRleF0gfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXggKyAxXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCArIDJdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCArIDNdIDw8IDI0KTtcbiAgICAgICAgICAgIGNvbnN0IHNjb3BlT2JqZWN0ID0gZGVzZXJpYWxpemVPYmplY3QoYnVmZmVyLCBfaW5kZXgsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBvYmplY3RTaXplO1xuICAgICAgICAgICAgaWYgKHRvdGFsU2l6ZSA8IDQgKyA0ICsgb2JqZWN0U2l6ZSArIHN0cmluZ1NpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdjb2RlX3dfc2NvcGUgdG90YWwgc2l6ZSBpcyB0b28gc2hvcnQsIHRydW5jYXRpbmcgc2NvcGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3RhbFNpemUgPiA0ICsgNCArIG9iamVjdFNpemUgKyBzdHJpbmdTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignY29kZV93X3Njb3BlIHRvdGFsIHNpemUgaXMgdG9vIGxvbmcsIGNsaXBzIG91dGVyIGRvY3VtZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBDb2RlKGZ1bmN0aW9uU3RyaW5nLCBzY29wZU9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9EQlBPSU5URVIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ1NpemUgPSBidWZmZXJbaW5kZXgrK10gfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgICAgIGlmIChzdHJpbmdTaXplIDw9IDAgfHxcbiAgICAgICAgICAgICAgICBzdHJpbmdTaXplID4gYnVmZmVyLmxlbmd0aCAtIGluZGV4IHx8XG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4ICsgc3RyaW5nU2l6ZSAtIDFdICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2JhZCBzdHJpbmcgbGVuZ3RoIGluIGJzb24nKTtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uICE9IG51bGwgJiYgdmFsaWRhdGlvbi51dGY4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVV0ZjgoYnVmZmVyLCBpbmRleCwgaW5kZXggKyBzdHJpbmdTaXplIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignSW52YWxpZCBVVEYtOCBzdHJpbmcgaW4gQlNPTiBkb2N1bWVudCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5hbWVzcGFjZSA9IEJ5dGVVdGlscy50b1VURjgoYnVmZmVyLCBpbmRleCwgaW5kZXggKyBzdHJpbmdTaXplIC0gMSk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgc3RyaW5nU2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IG9pZEJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZSgxMik7XG4gICAgICAgICAgICBvaWRCdWZmZXIuc2V0KGJ1ZmZlci5zdWJhcnJheShpbmRleCwgaW5kZXggKyAxMiksIDApO1xuICAgICAgICAgICAgY29uc3Qgb2lkID0gbmV3IE9iamVjdElkKG9pZEJ1ZmZlcik7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgMTI7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBEQlJlZihuYW1lc3BhY2UsIG9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBEZXRlY3RlZCB1bmtub3duIEJTT04gdHlwZSAke2VsZW1lbnRUeXBlLnRvU3RyaW5nKDE2KX0gZm9yIGZpZWxkbmFtZSBcIiR7bmFtZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzaXplICE9PSBpbmRleCAtIHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdjb3JydXB0IGFycmF5IGJzb24nKTtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignY29ycnVwdCBvYmplY3QgYnNvbicpO1xuICAgIH1cbiAgICBpZiAoIWlzUG9zc2libGVEQlJlZilcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICBpZiAoaXNEQlJlZkxpa2Uob2JqZWN0KSkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqZWN0KTtcbiAgICAgICAgZGVsZXRlIGNvcHkuJHJlZjtcbiAgICAgICAgZGVsZXRlIGNvcHkuJGlkO1xuICAgICAgICBkZWxldGUgY29weS4kZGI7XG4gICAgICAgIHJldHVybiBuZXcgREJSZWYob2JqZWN0LiRyZWYsIG9iamVjdC4kaWQsIG9iamVjdC4kZGIsIGNvcHkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0VmFsaWRhdGVkU3RyaW5nKGJ1ZmZlciwgc3RhcnQsIGVuZCwgc2hvdWxkVmFsaWRhdGVVdGY4KSB7XG4gICAgY29uc3QgdmFsdWUgPSBCeXRlVXRpbHMudG9VVEY4KGJ1ZmZlciwgc3RhcnQsIGVuZCk7XG4gICAgaWYgKHNob3VsZFZhbGlkYXRlVXRmOCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUuY2hhckNvZGVBdChpKSA9PT0gMHhmZmZkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVV0ZjgoYnVmZmVyLCBzdGFydCwgZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdJbnZhbGlkIFVURi04IHN0cmluZyBpbiBCU09OIGRvY3VtZW50Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuY29uc3QgcmVnZXhwID0gL1xceDAwLztcbmNvbnN0IGlnbm9yZUtleXMgPSBuZXcgU2V0KFsnJGRiJywgJyRyZWYnLCAnJGlkJywgJyRjbHVzdGVyVGltZSddKTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZVN0cmluZyhidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX1NUUklORztcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcyArIDE7XG4gICAgYnVmZmVyW2luZGV4IC0gMV0gPSAwO1xuICAgIGNvbnN0IHNpemUgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCB2YWx1ZSwgaW5kZXggKyA0KTtcbiAgICBidWZmZXJbaW5kZXggKyAzXSA9ICgoc2l6ZSArIDEpID4+IDI0KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4ICsgMl0gPSAoKHNpemUgKyAxKSA+PiAxNikgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCArIDFdID0gKChzaXplICsgMSkgPj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleF0gPSAoc2l6ZSArIDEpICYgMHhmZjtcbiAgICBpbmRleCA9IGluZGV4ICsgNCArIHNpemU7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5jb25zdCBOVU1CRVJfU1BBQ0UgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDgpLCAwLCA4KTtcbmNvbnN0IEZPVVJfQllURV9WSUVXX09OX05VTUJFUiA9IG5ldyBVaW50OEFycmF5KE5VTUJFUl9TUEFDRS5idWZmZXIsIDAsIDQpO1xuY29uc3QgRUlHSFRfQllURV9WSUVXX09OX05VTUJFUiA9IG5ldyBVaW50OEFycmF5KE5VTUJFUl9TUEFDRS5idWZmZXIsIDAsIDgpO1xuZnVuY3Rpb24gc2VyaWFsaXplTnVtYmVyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBjb25zdCBpc05lZ2F0aXZlWmVybyA9IE9iamVjdC5pcyh2YWx1ZSwgLTApO1xuICAgIGNvbnN0IHR5cGUgPSAhaXNOZWdhdGl2ZVplcm8gJiZcbiAgICAgICAgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpICYmXG4gICAgICAgIHZhbHVlIDw9IEJTT05fSU5UMzJfTUFYICYmXG4gICAgICAgIHZhbHVlID49IEJTT05fSU5UMzJfTUlOXG4gICAgICAgID8gQlNPTl9EQVRBX0lOVFxuICAgICAgICA6IEJTT05fREFUQV9OVU1CRVI7XG4gICAgaWYgKHR5cGUgPT09IEJTT05fREFUQV9JTlQpIHtcbiAgICAgICAgTlVNQkVSX1NQQUNFLnNldEludDMyKDAsIHZhbHVlLCB0cnVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIE5VTUJFUl9TUEFDRS5zZXRGbG9hdDY0KDAsIHZhbHVlLCB0cnVlKTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSB0eXBlID09PSBCU09OX0RBVEFfSU5UID8gRk9VUl9CWVRFX1ZJRVdfT05fTlVNQkVSIDogRUlHSFRfQllURV9WSUVXX09OX05VTUJFUjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSB0eXBlO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDB4MDA7XG4gICAgYnVmZmVyLnNldChieXRlcywgaW5kZXgpO1xuICAgIGluZGV4ICs9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQmlnSW50KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfTE9ORztcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ICs9IG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgTlVNQkVSX1NQQUNFLnNldEJpZ0ludDY0KDAsIHZhbHVlLCB0cnVlKTtcbiAgICBidWZmZXIuc2V0KEVJR0hUX0JZVEVfVklFV19PTl9OVU1CRVIsIGluZGV4KTtcbiAgICBpbmRleCArPSBFSUdIVF9CWVRFX1ZJRVdfT05fTlVNQkVSLmJ5dGVMZW5ndGg7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplTnVsbChidWZmZXIsIGtleSwgXywgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfTlVMTDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUJvb2xlYW4oYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9CT09MRUFOO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgYnVmZmVyW2luZGV4KytdID0gdmFsdWUgPyAxIDogMDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVEYXRlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfREFURTtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IGRhdGVJbk1pbGlzID0gTG9uZy5mcm9tTnVtYmVyKHZhbHVlLmdldFRpbWUoKSk7XG4gICAgY29uc3QgbG93Qml0cyA9IGRhdGVJbk1pbGlzLmdldExvd0JpdHMoKTtcbiAgICBjb25zdCBoaWdoQml0cyA9IGRhdGVJbk1pbGlzLmdldEhpZ2hCaXRzKCk7XG4gICAgYnVmZmVyW2luZGV4KytdID0gbG93Qml0cyAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKGxvd0JpdHMgPj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChsb3dCaXRzID4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKGxvd0JpdHMgPj4gMjQpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBoaWdoQml0cyAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKGhpZ2hCaXRzID4+IDgpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAoaGlnaEJpdHMgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAoaGlnaEJpdHMgPj4gMjQpICYgMHhmZjtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVSZWdFeHAoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9SRUdFWFA7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBpZiAodmFsdWUuc291cmNlICYmIHZhbHVlLnNvdXJjZS5tYXRjaChyZWdleHApICE9IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigndmFsdWUgJyArIHZhbHVlLnNvdXJjZSArICcgbXVzdCBub3QgY29udGFpbiBudWxsIGJ5dGVzJyk7XG4gICAgfVxuICAgIGluZGV4ID0gaW5kZXggKyBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCB2YWx1ZS5zb3VyY2UsIGluZGV4KTtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAweDAwO1xuICAgIGlmICh2YWx1ZS5pZ25vcmVDYXNlKVxuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAweDY5O1xuICAgIGlmICh2YWx1ZS5nbG9iYWwpXG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IDB4NzM7XG4gICAgaWYgKHZhbHVlLm11bHRpbGluZSlcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gMHg2ZDtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAweDAwO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUJTT05SZWdFeHAoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9SRUdFWFA7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBpZiAodmFsdWUucGF0dGVybi5tYXRjaChyZWdleHApICE9IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigncGF0dGVybiAnICsgdmFsdWUucGF0dGVybiArICcgbXVzdCBub3QgY29udGFpbiBudWxsIGJ5dGVzJyk7XG4gICAgfVxuICAgIGluZGV4ID0gaW5kZXggKyBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCB2YWx1ZS5wYXR0ZXJuLCBpbmRleCk7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMHgwMDtcbiAgICBjb25zdCBzb3J0ZWRPcHRpb25zID0gdmFsdWUub3B0aW9ucy5zcGxpdCgnJykuc29ydCgpLmpvaW4oJycpO1xuICAgIGluZGV4ID0gaW5kZXggKyBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBzb3J0ZWRPcHRpb25zLCBpbmRleCk7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMHgwMDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVNaW5NYXgoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfTlVMTDtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnTWluS2V5Jykge1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfTUlOX0tFWTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9NQVhfS0VZO1xuICAgIH1cbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdElkKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfT0lEO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgaWYgKGlzVWludDhBcnJheSh2YWx1ZS5pZCkpIHtcbiAgICAgICAgYnVmZmVyLnNldCh2YWx1ZS5pZC5zdWJhcnJheSgwLCAxMiksIGluZGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ29iamVjdCBbJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICddIGlzIG5vdCBhIHZhbGlkIE9iamVjdElkJyk7XG4gICAgfVxuICAgIHJldHVybiBpbmRleCArIDEyO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQnVmZmVyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQklOQVJZO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgY29uc3Qgc2l6ZSA9IHZhbHVlLmxlbmd0aDtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBzaXplICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAoc2l6ZSA+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKHNpemUgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAoc2l6ZSA+PiAyNCkgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fQklOQVJZX1NVQlRZUEVfREVGQVVMVDtcbiAgICBidWZmZXIuc2V0KHZhbHVlLCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIHNpemU7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGNoZWNrS2V5cywgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKSB7XG4gICAgaWYgKHBhdGguaGFzKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdDYW5ub3QgY29udmVydCBjaXJjdWxhciBzdHJ1Y3R1cmUgdG8gQlNPTicpO1xuICAgIH1cbiAgICBwYXRoLmFkZCh2YWx1ZSk7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBCU09OX0RBVEFfQVJSQVkgOiBCU09OX0RBVEFfT0JKRUNUO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgY29uc3QgZW5kSW5kZXggPSBzZXJpYWxpemVJbnRvKGJ1ZmZlciwgdmFsdWUsIGNoZWNrS2V5cywgaW5kZXgsIGRlcHRoICsgMSwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpO1xuICAgIHBhdGguZGVsZXRlKHZhbHVlKTtcbiAgICByZXR1cm4gZW5kSW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVEZWNpbWFsMTI4KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfREVDSU1BTDEyODtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGJ1ZmZlci5zZXQodmFsdWUuYnl0ZXMuc3ViYXJyYXkoMCwgMTYpLCBpbmRleCk7XG4gICAgcmV0dXJuIGluZGV4ICsgMTY7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVMb25nKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPVxuICAgICAgICB2YWx1ZS5fYnNvbnR5cGUgPT09ICdMb25nJyA/IEJTT05fREFUQV9MT05HIDogQlNPTl9EQVRBX1RJTUVTVEFNUDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IGxvd0JpdHMgPSB2YWx1ZS5nZXRMb3dCaXRzKCk7XG4gICAgY29uc3QgaGlnaEJpdHMgPSB2YWx1ZS5nZXRIaWdoQml0cygpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IGxvd0JpdHMgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChsb3dCaXRzID4+IDgpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAobG93Qml0cyA+PiAxNikgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChsb3dCaXRzID4+IDI0KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gaGlnaEJpdHMgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChoaWdoQml0cyA+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKGhpZ2hCaXRzID4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKGhpZ2hCaXRzID4+IDI0KSAmIDB4ZmY7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplSW50MzIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9JTlQ7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBidWZmZXJbaW5kZXgrK10gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKHZhbHVlID4+IDgpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAodmFsdWUgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAodmFsdWUgPj4gMjQpICYgMHhmZjtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVEb3VibGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9OVU1CRVI7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBOVU1CRVJfU1BBQ0Uuc2V0RmxvYXQ2NCgwLCB2YWx1ZS52YWx1ZSwgdHJ1ZSk7XG4gICAgYnVmZmVyLnNldChFSUdIVF9CWVRFX1ZJRVdfT05fTlVNQkVSLCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIDg7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRnVuY3Rpb24oYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9DT0RFO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgY29uc3QgZnVuY3Rpb25TdHJpbmcgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIGNvbnN0IHNpemUgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBmdW5jdGlvblN0cmluZywgaW5kZXggKyA0KSArIDE7XG4gICAgYnVmZmVyW2luZGV4XSA9IHNpemUgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCArIDFdID0gKHNpemUgPj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCArIDJdID0gKHNpemUgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXggKyAzXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgaW5kZXggPSBpbmRleCArIDQgKyBzaXplIC0gMTtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUNvZGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgY2hlY2tLZXlzID0gZmFsc2UsIGRlcHRoID0gMCwgc2VyaWFsaXplRnVuY3Rpb25zID0gZmFsc2UsIGlnbm9yZVVuZGVmaW5lZCA9IHRydWUsIHBhdGgpIHtcbiAgICBpZiAodmFsdWUuc2NvcGUgJiYgdHlwZW9mIHZhbHVlLnNjb3BlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQ09ERV9XX1NDT1BFO1xuICAgICAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgICAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgICAgIGxldCBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uU3RyaW5nID0gdmFsdWUuY29kZTtcbiAgICAgICAgaW5kZXggPSBpbmRleCArIDQ7XG4gICAgICAgIGNvbnN0IGNvZGVTaXplID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgZnVuY3Rpb25TdHJpbmcsIGluZGV4ICsgNCkgKyAxO1xuICAgICAgICBidWZmZXJbaW5kZXhdID0gY29kZVNpemUgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXggKyAxXSA9IChjb2RlU2l6ZSA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCArIDJdID0gKGNvZGVTaXplID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCArIDNdID0gKGNvZGVTaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCArIDQgKyBjb2RlU2l6ZSAtIDFdID0gMDtcbiAgICAgICAgaW5kZXggPSBpbmRleCArIGNvZGVTaXplICsgNDtcbiAgICAgICAgY29uc3QgZW5kSW5kZXggPSBzZXJpYWxpemVJbnRvKGJ1ZmZlciwgdmFsdWUuc2NvcGUsIGNoZWNrS2V5cywgaW5kZXgsIGRlcHRoICsgMSwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpO1xuICAgICAgICBpbmRleCA9IGVuZEluZGV4IC0gMTtcbiAgICAgICAgY29uc3QgdG90YWxTaXplID0gZW5kSW5kZXggLSBzdGFydEluZGV4O1xuICAgICAgICBidWZmZXJbc3RhcnRJbmRleCsrXSA9IHRvdGFsU2l6ZSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltzdGFydEluZGV4KytdID0gKHRvdGFsU2l6ZSA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltzdGFydEluZGV4KytdID0gKHRvdGFsU2l6ZSA+PiAxNikgJiAweGZmO1xuICAgICAgICBidWZmZXJbc3RhcnRJbmRleCsrXSA9ICh0b3RhbFNpemUgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9DT0RFO1xuICAgICAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgICAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uU3RyaW5nID0gdmFsdWUuY29kZS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBzaXplID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgZnVuY3Rpb25TdHJpbmcsIGluZGV4ICsgNCkgKyAxO1xuICAgICAgICBidWZmZXJbaW5kZXhdID0gc2l6ZSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCArIDFdID0gKHNpemUgPj4gOCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXggKyAyXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCArIDNdID0gKHNpemUgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgaW5kZXggPSBpbmRleCArIDQgKyBzaXplIC0gMTtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQmluYXJ5KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQklOQVJZO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgY29uc3QgZGF0YSA9IHZhbHVlLmJ1ZmZlcjtcbiAgICBsZXQgc2l6ZSA9IHZhbHVlLnBvc2l0aW9uO1xuICAgIGlmICh2YWx1ZS5zdWJfdHlwZSA9PT0gQmluYXJ5LlNVQlRZUEVfQllURV9BUlJBWSlcbiAgICAgICAgc2l6ZSA9IHNpemUgKyA0O1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IHNpemUgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChzaXplID4+IDgpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAoc2l6ZSA+PiAxNikgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gdmFsdWUuc3ViX3R5cGU7XG4gICAgaWYgKHZhbHVlLnN1Yl90eXBlID09PSBCaW5hcnkuU1VCVFlQRV9CWVRFX0FSUkFZKSB7XG4gICAgICAgIHNpemUgPSBzaXplIC0gNDtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gc2l6ZSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChzaXplID4+IDgpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKHNpemUgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKHNpemUgPj4gMjQpICYgMHhmZjtcbiAgICB9XG4gICAgYnVmZmVyLnNldChkYXRhLCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIHZhbHVlLnBvc2l0aW9uO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVN5bWJvbChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX1NZTUJPTDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IHNpemUgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCB2YWx1ZS52YWx1ZSwgaW5kZXggKyA0KSArIDE7XG4gICAgYnVmZmVyW2luZGV4XSA9IHNpemUgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCArIDFdID0gKHNpemUgPj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCArIDJdID0gKHNpemUgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXggKyAzXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgaW5kZXggPSBpbmRleCArIDQgKyBzaXplIC0gMTtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAweDAwO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZURCUmVmKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIHBhdGgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfT0JKRUNUO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICBsZXQgb3V0cHV0ID0ge1xuICAgICAgICAkcmVmOiB2YWx1ZS5jb2xsZWN0aW9uIHx8IHZhbHVlLm5hbWVzcGFjZSxcbiAgICAgICAgJGlkOiB2YWx1ZS5vaWRcbiAgICB9O1xuICAgIGlmICh2YWx1ZS5kYiAhPSBudWxsKSB7XG4gICAgICAgIG91dHB1dC4kZGIgPSB2YWx1ZS5kYjtcbiAgICB9XG4gICAgb3V0cHV0ID0gT2JqZWN0LmFzc2lnbihvdXRwdXQsIHZhbHVlLmZpZWxkcyk7XG4gICAgY29uc3QgZW5kSW5kZXggPSBzZXJpYWxpemVJbnRvKGJ1ZmZlciwgb3V0cHV0LCBmYWxzZSwgaW5kZXgsIGRlcHRoICsgMSwgc2VyaWFsaXplRnVuY3Rpb25zLCB0cnVlLCBwYXRoKTtcbiAgICBjb25zdCBzaXplID0gZW5kSW5kZXggLSBzdGFydEluZGV4O1xuICAgIGJ1ZmZlcltzdGFydEluZGV4KytdID0gc2l6ZSAmIDB4ZmY7XG4gICAgYnVmZmVyW3N0YXJ0SW5kZXgrK10gPSAoc2l6ZSA+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyW3N0YXJ0SW5kZXgrK10gPSAoc2l6ZSA+PiAxNikgJiAweGZmO1xuICAgIGJ1ZmZlcltzdGFydEluZGV4KytdID0gKHNpemUgPj4gMjQpICYgMHhmZjtcbiAgICByZXR1cm4gZW5kSW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVJbnRvKGJ1ZmZlciwgb2JqZWN0LCBjaGVja0tleXMsIHN0YXJ0aW5nSW5kZXgsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgcGF0aCkge1xuICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBidWZmZXJbMF0gPSAweDA1O1xuICAgICAgICAgICAgYnVmZmVyWzFdID0gMHgwMDtcbiAgICAgICAgICAgIGJ1ZmZlclsyXSA9IDB4MDA7XG4gICAgICAgICAgICBidWZmZXJbM10gPSAweDAwO1xuICAgICAgICAgICAgYnVmZmVyWzRdID0gMHgwMDtcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ3NlcmlhbGl6ZSBkb2VzIG5vdCBzdXBwb3J0IGFuIGFycmF5IGFzIHRoZSByb290IGlucHV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdzZXJpYWxpemUgZG9lcyBub3Qgc3VwcG9ydCBub24tb2JqZWN0IGFzIHRoZSByb290IGlucHV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ19ic29udHlwZScgaW4gb2JqZWN0ICYmIHR5cGVvZiBvYmplY3QuX2Jzb250eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgQlNPTiB0eXBlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBhcyBhIGRvY3VtZW50YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEYXRlKG9iamVjdCkgfHxcbiAgICAgICAgICAgIGlzUmVnRXhwKG9iamVjdCkgfHxcbiAgICAgICAgICAgIGlzVWludDhBcnJheShvYmplY3QpIHx8XG4gICAgICAgICAgICBpc0FueUFycmF5QnVmZmVyKG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYGRhdGUsIHJlZ2V4cCwgdHlwZWRhcnJheSwgYW5kIGFycmF5YnVmZmVyIGNhbm5vdCBiZSBCU09OIGRvY3VtZW50c2ApO1xuICAgICAgICB9XG4gICAgICAgIHBhdGggPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIHBhdGguYWRkKG9iamVjdCk7XG4gICAgbGV0IGluZGV4ID0gc3RhcnRpbmdJbmRleCArIDQ7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7aX1gO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gb2JqZWN0W2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZT8udG9CU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0JTT04oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVTdHJpbmcoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVOdW1iZXIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCaWdJbnQoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQm9vbGVhbihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fCBpc0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEYXRlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTnVsbChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVOdWxsKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNVaW50OEFycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQnVmZmVyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVSZWdFeHAoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLl9ic29udHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVPYmplY3QoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgY2hlY2tLZXlzLCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHZhbHVlW1N5bWJvbC5mb3IoJ0BAbWRiLmJzb24udmVyc2lvbicpXSAhPT0gQlNPTl9NQUpPUl9WRVJTSU9OKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05WZXJzaW9uRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ09iamVjdElkJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplT2JqZWN0SWQoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEZWNpbWFsMTI4Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRGVjaW1hbDEyOChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0xvbmcnIHx8IHZhbHVlLl9ic29udHlwZSA9PT0gJ1RpbWVzdGFtcCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUxvbmcoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEb3VibGUnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEb3VibGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgc2VyaWFsaXplRnVuY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVGdW5jdGlvbihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0NvZGUnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVDb2RlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGNoZWNrS2V5cywgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JpbmFyeScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJpbmFyeShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JTT05TeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVTeW1ib2woYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEQlJlZicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURCUmVmKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQlNPTlJlZ0V4cCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJTT05SZWdFeHAoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdJbnQzMicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUludDMyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnTWluS2V5JyB8fCB2YWx1ZS5fYnNvbnR5cGUgPT09ICdNYXhLZXknKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVNaW5NYXgoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUuX2Jzb250eXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYFVucmVjb2duaXplZCBvciBpbnZhbGlkIF9ic29udHlwZTogJHtTdHJpbmcodmFsdWUuX2Jzb250eXBlKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBNYXAgfHwgaXNNYXAob2JqZWN0KSkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IG9iamVjdC5lbnRyaWVzKCk7XG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBkb25lID0gISFlbnRyeS5kb25lO1xuICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBlbnRyeS52YWx1ZVswXTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGVudHJ5LnZhbHVlWzFdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZT8udG9CU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0JTT04oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIWlnbm9yZUtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Lm1hdGNoKHJlZ2V4cCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdrZXkgJyArIGtleSArICcgbXVzdCBub3QgY29udGFpbiBudWxsIGJ5dGVzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGVja0tleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCckJyA9PT0ga2V5WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdrZXkgJyArIGtleSArIFwiIG11c3Qgbm90IHN0YXJ0IHdpdGggJyQnXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKH5rZXkuaW5kZXhPZignLicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdrZXkgJyArIGtleSArIFwiIG11c3Qgbm90IGNvbnRhaW4gJy4nXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVTdHJpbmcoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTnVtYmVyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJpZ0ludChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQm9vbGVhbihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fCBpc0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEYXRlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IG51bGwgfHwgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgaWdub3JlVW5kZWZpbmVkID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU51bGwoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1VpbnQ4QXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCdWZmZXIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZVJlZ0V4cChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHZhbHVlLl9ic29udHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVPYmplY3QoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgY2hlY2tLZXlzLCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHZhbHVlW1N5bWJvbC5mb3IoJ0BAbWRiLmJzb24udmVyc2lvbicpXSAhPT0gQlNPTl9NQUpPUl9WRVJTSU9OKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05WZXJzaW9uRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ09iamVjdElkJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplT2JqZWN0SWQoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5fYnNvbnR5cGUgPT09ICdEZWNpbWFsMTI4Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRGVjaW1hbDEyOChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0xvbmcnIHx8IHZhbHVlLl9ic29udHlwZSA9PT0gJ1RpbWVzdGFtcCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUxvbmcoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEb3VibGUnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEb3VibGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdDb2RlJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQ29kZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgc2VyaWFsaXplRnVuY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVGdW5jdGlvbihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JpbmFyeScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJpbmFyeShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JTT05TeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVTeW1ib2woYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEQlJlZicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURCUmVmKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQlNPTlJlZ0V4cCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJTT05SZWdFeHAoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdJbnQzMicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUludDMyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnTWluS2V5JyB8fCB2YWx1ZS5fYnNvbnR5cGUgPT09ICdNYXhLZXknKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVNaW5NYXgoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUuX2Jzb250eXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYFVucmVjb2duaXplZCBvciBpbnZhbGlkIF9ic29udHlwZTogJHtTdHJpbmcodmFsdWUuX2Jzb250eXBlKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Q/LnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LnRvQlNPTigpO1xuICAgICAgICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigndG9CU09OIGZ1bmN0aW9uIGRpZCBub3QgcmV0dXJuIGFuIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iamVjdCkpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZT8udG9CU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0JTT04oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIWlnbm9yZUtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Lm1hdGNoKHJlZ2V4cCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdrZXkgJyArIGtleSArICcgbXVzdCBub3QgY29udGFpbiBudWxsIGJ5dGVzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGVja0tleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCckJyA9PT0ga2V5WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdrZXkgJyArIGtleSArIFwiIG11c3Qgbm90IHN0YXJ0IHdpdGggJyQnXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKH5rZXkuaW5kZXhPZignLicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdrZXkgJyArIGtleSArIFwiIG11c3Qgbm90IGNvbnRhaW4gJy4nXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVTdHJpbmcoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTnVtYmVyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJpZ0ludChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQm9vbGVhbihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fCBpc0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEYXRlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChpZ25vcmVVbmRlZmluZWQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU51bGwoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTnVsbChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVWludDhBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJ1ZmZlcihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwIHx8IGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplUmVnRXhwKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuX2Jzb250eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU9iamVjdChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgdmFsdWVbU3ltYm9sLmZvcignQEBtZGIuYnNvbi52ZXJzaW9uJyldICE9PSBCU09OX01BSk9SX1ZFUlNJT04pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTlZlcnNpb25FcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnT2JqZWN0SWQnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVPYmplY3RJZChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHZhbHVlLl9ic29udHlwZSA9PT0gJ0RlY2ltYWwxMjgnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEZWNpbWFsMTI4KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnTG9uZycgfHwgdmFsdWUuX2Jzb250eXBlID09PSAnVGltZXN0YW1wJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTG9uZyhidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0RvdWJsZScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURvdWJsZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0NvZGUnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVDb2RlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGNoZWNrS2V5cywgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBzZXJpYWxpemVGdW5jdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUZ1bmN0aW9uKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQmluYXJ5Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQmluYXJ5KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQlNPTlN5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZVN5bWJvbChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0RCUmVmJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplREJSZWYoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCU09OUmVnRXhwJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQlNPTlJlZ0V4cChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0ludDMyJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplSW50MzIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdNaW5LZXknIHx8IHZhbHVlLl9ic29udHlwZSA9PT0gJ01heEtleScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU1pbk1heChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS5fYnNvbnR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgVW5yZWNvZ25pemVkIG9yIGludmFsaWQgX2Jzb250eXBlOiAke1N0cmluZyh2YWx1ZS5fYnNvbnR5cGUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHBhdGguZGVsZXRlKG9iamVjdCk7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMHgwMDtcbiAgICBjb25zdCBzaXplID0gaW5kZXggLSBzdGFydGluZ0luZGV4O1xuICAgIGJ1ZmZlcltzdGFydGluZ0luZGV4KytdID0gc2l6ZSAmIDB4ZmY7XG4gICAgYnVmZmVyW3N0YXJ0aW5nSW5kZXgrK10gPSAoc2l6ZSA+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyW3N0YXJ0aW5nSW5kZXgrK10gPSAoc2l6ZSA+PiAxNikgJiAweGZmO1xuICAgIGJ1ZmZlcltzdGFydGluZ0luZGV4KytdID0gKHNpemUgPj4gMjQpICYgMHhmZjtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5cbmZ1bmN0aW9uIGlzQlNPTlR5cGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnX2Jzb250eXBlJyBpbiB2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUuX2Jzb250eXBlID09PSAnc3RyaW5nJyk7XG59XG5jb25zdCBrZXlzVG9Db2RlY3MgPSB7XG4gICAgJG9pZDogT2JqZWN0SWQsXG4gICAgJGJpbmFyeTogQmluYXJ5LFxuICAgICR1dWlkOiBCaW5hcnksXG4gICAgJHN5bWJvbDogQlNPTlN5bWJvbCxcbiAgICAkbnVtYmVySW50OiBJbnQzMixcbiAgICAkbnVtYmVyRGVjaW1hbDogRGVjaW1hbDEyOCxcbiAgICAkbnVtYmVyRG91YmxlOiBEb3VibGUsXG4gICAgJG51bWJlckxvbmc6IExvbmcsXG4gICAgJG1pbktleTogTWluS2V5LFxuICAgICRtYXhLZXk6IE1heEtleSxcbiAgICAkcmVnZXg6IEJTT05SZWdFeHAsXG4gICAgJHJlZ3VsYXJFeHByZXNzaW9uOiBCU09OUmVnRXhwLFxuICAgICR0aW1lc3RhbXA6IFRpbWVzdGFtcFxufTtcbmZ1bmN0aW9uIGRlc2VyaWFsaXplVmFsdWUodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnN0IGluMzJCaXRSYW5nZSA9IHZhbHVlIDw9IEJTT05fSU5UMzJfTUFYICYmIHZhbHVlID49IEJTT05fSU5UMzJfTUlOO1xuICAgICAgICBjb25zdCBpbjY0Qml0UmFuZ2UgPSB2YWx1ZSA8PSBCU09OX0lOVDY0X01BWCAmJiB2YWx1ZSA+PSBCU09OX0lOVDY0X01JTjtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVsYXhlZCB8fCBvcHRpb25zLmxlZ2FjeSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJiAhT2JqZWN0LmlzKHZhbHVlLCAtMCkpIHtcbiAgICAgICAgICAgIGlmIChpbjMyQml0UmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludDMyKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbjY0Qml0UmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy51c2VCaWdJbnQ2NCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEb3VibGUodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgaWYgKHZhbHVlLiR1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSkuZmlsdGVyKGsgPT4gay5zdGFydHNXaXRoKCckJykgJiYgdmFsdWVba10gIT0gbnVsbCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBrZXlzVG9Db2RlY3Nba2V5c1tpXV07XG4gICAgICAgIGlmIChjKVxuICAgICAgICAgICAgcmV0dXJuIGMuZnJvbUV4dGVuZGVkSlNPTih2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS4kZGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGQgPSB2YWx1ZS4kZGF0ZTtcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGlmIChvcHRpb25zLmxlZ2FjeSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICBkYXRlLnNldFRpbWUoZCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKERhdGUucGFyc2UoZCkpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQgPT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShOdW1iZXIoZCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09OUnVudGltZUVycm9yKGBVbnJlY29nbml6ZWQgdHlwZSBmb3IgRUpTT04gZGF0ZTogJHt0eXBlb2YgZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKERhdGUucGFyc2UoZCkpO1xuICAgICAgICAgICAgZWxzZSBpZiAoTG9uZy5pc0xvbmcoZCkpXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKGQudG9OdW1iZXIoKSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZCA9PT0gJ251bWJlcicgJiYgb3B0aW9ucy5yZWxheGVkKVxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShkKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkID09PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICBkYXRlLnNldFRpbWUoTnVtYmVyKGQpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTlJ1bnRpbWVFcnJvcihgVW5yZWNvZ25pemVkIHR5cGUgZm9yIEVKU09OIGRhdGU6ICR7dHlwZW9mIGR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIGlmICh2YWx1ZS4kY29kZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZS4kc2NvcGUpIHtcbiAgICAgICAgICAgIGNvcHkuJHNjb3BlID0gZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZS4kc2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb2RlLmZyb21FeHRlbmRlZEpTT04odmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaXNEQlJlZkxpa2UodmFsdWUpIHx8IHZhbHVlLiRkYlBvaW50ZXIpIHtcbiAgICAgICAgY29uc3QgdiA9IHZhbHVlLiRyZWYgPyB2YWx1ZSA6IHZhbHVlLiRkYlBvaW50ZXI7XG4gICAgICAgIGlmICh2IGluc3RhbmNlb2YgREJSZWYpXG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY29uc3QgZG9sbGFyS2V5cyA9IE9iamVjdC5rZXlzKHYpLmZpbHRlcihrID0+IGsuc3RhcnRzV2l0aCgnJCcpKTtcbiAgICAgICAgbGV0IHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgZG9sbGFyS2V5cy5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAgICAgaWYgKFsnJHJlZicsICckaWQnLCAnJGRiJ10uaW5kZXhPZihrKSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh2YWxpZClcbiAgICAgICAgICAgIHJldHVybiBEQlJlZi5mcm9tRXh0ZW5kZWRKU09OKHYpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVBcnJheShhcnJheSwgb3B0aW9ucykge1xuICAgIHJldHVybiBhcnJheS5tYXAoKHYsIGluZGV4KSA9PiB7XG4gICAgICAgIG9wdGlvbnMuc2Vlbk9iamVjdHMucHVzaCh7IHByb3BlcnR5TmFtZTogYGluZGV4ICR7aW5kZXh9YCwgb2JqOiBudWxsIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVZhbHVlKHYsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgb3B0aW9ucy5zZWVuT2JqZWN0cy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0SVNPU3RyaW5nKGRhdGUpIHtcbiAgICBjb25zdCBpc29TdHIgPSBkYXRlLnRvSVNPU3RyaW5nKCk7XG4gICAgcmV0dXJuIGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgIT09IDAgPyBpc29TdHIgOiBpc29TdHIuc2xpY2UoMCwgLTUpICsgJ1onO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplVmFsdWUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgaXNNYXAodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGsgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQ2FuIG9ubHkgc2VyaWFsaXplIG1hcHMgd2l0aCBzdHJpbmcga2V5cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqW2tdID0gdjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplVmFsdWUob2JqLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKCh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBvcHRpb25zLnNlZW5PYmplY3RzLmZpbmRJbmRleChlbnRyeSA9PiBlbnRyeS5vYmogPT09IHZhbHVlKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBvcHRpb25zLnNlZW5PYmplY3RzLm1hcChlbnRyeSA9PiBlbnRyeS5wcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgY29uc3QgbGVhZGluZ1BhcnQgPSBwcm9wc1xuICAgICAgICAgICAgICAgIC5zbGljZSgwLCBpbmRleClcbiAgICAgICAgICAgICAgICAubWFwKHByb3AgPT4gYCR7cHJvcH0gLT4gYClcbiAgICAgICAgICAgICAgICAuam9pbignJyk7XG4gICAgICAgICAgICBjb25zdCBhbHJlYWR5U2VlbiA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGNpcmN1bGFyUGFydCA9ICcgLT4gJyArXG4gICAgICAgICAgICAgICAgcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgLnNsaWNlKGluZGV4ICsgMSwgcHJvcHMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcChwcm9wID0+IGAke3Byb3B9IC0+IGApXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBwcm9wc1twcm9wcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGxlYWRpbmdTcGFjZSA9ICcgJy5yZXBlYXQobGVhZGluZ1BhcnQubGVuZ3RoICsgYWxyZWFkeVNlZW4ubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICBjb25zdCBkYXNoZXMgPSAnLScucmVwZWF0KGNpcmN1bGFyUGFydC5sZW5ndGggKyAoYWxyZWFkeVNlZW4ubGVuZ3RoICsgY3VycmVudC5sZW5ndGgpIC8gMiAtIDEpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQ29udmVydGluZyBjaXJjdWxhciBzdHJ1Y3R1cmUgdG8gRUpTT046XFxuJyArXG4gICAgICAgICAgICAgICAgYCAgICAke2xlYWRpbmdQYXJ0fSR7YWxyZWFkeVNlZW59JHtjaXJjdWxhclBhcnR9JHtjdXJyZW50fVxcbmAgK1xuICAgICAgICAgICAgICAgIGAgICAgJHtsZWFkaW5nU3BhY2V9XFxcXCR7ZGFzaGVzfS9gKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnNlZW5PYmplY3RzW29wdGlvbnMuc2Vlbk9iamVjdHMubGVuZ3RoIC0gMV0ub2JqID0gdmFsdWU7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUFycmF5KHZhbHVlLCBvcHRpb25zKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fCBpc0RhdGUodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGRhdGVOdW0gPSB2YWx1ZS5nZXRUaW1lKCksIGluUmFuZ2UgPSBkYXRlTnVtID4gLTEgJiYgZGF0ZU51bSA8IDI1MzQwMjMxODgwMDAwMDtcbiAgICAgICAgaWYgKG9wdGlvbnMubGVnYWN5KSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5yZWxheGVkICYmIGluUmFuZ2VcbiAgICAgICAgICAgICAgICA/IHsgJGRhdGU6IHZhbHVlLmdldFRpbWUoKSB9XG4gICAgICAgICAgICAgICAgOiB7ICRkYXRlOiBnZXRJU09TdHJpbmcodmFsdWUpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVsYXhlZCAmJiBpblJhbmdlXG4gICAgICAgICAgICA/IHsgJGRhdGU6IGdldElTT1N0cmluZyh2YWx1ZSkgfVxuICAgICAgICAgICAgOiB7ICRkYXRlOiB7ICRudW1iZXJMb25nOiB2YWx1ZS5nZXRUaW1lKCkudG9TdHJpbmcoKSB9IH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICghb3B0aW9ucy5yZWxheGVkIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpKSB7XG4gICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJiAhT2JqZWN0LmlzKHZhbHVlLCAtMCkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBCU09OX0lOVDMyX01JTiAmJiB2YWx1ZSA8PSBCU09OX0lOVDMyX01BWCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7ICRudW1iZXJJbnQ6IHZhbHVlLnRvU3RyaW5nKCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBCU09OX0lOVDY0X01JTiAmJiB2YWx1ZSA8PSBCU09OX0lOVDY0X01BWCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7ICRudW1iZXJMb25nOiB2YWx1ZS50b1N0cmluZygpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJG51bWJlckRvdWJsZTogT2JqZWN0LmlzKHZhbHVlLCAtMCkgPyAnLTAuMCcgOiB2YWx1ZS50b1N0cmluZygpIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5yZWxheGVkKSB7XG4gICAgICAgICAgICByZXR1cm4geyAkbnVtYmVyTG9uZzogQmlnSW50LmFzSW50Tig2NCwgdmFsdWUpLnRvU3RyaW5nKCkgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTnVtYmVyKEJpZ0ludC5hc0ludE4oNjQsIHZhbHVlKSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IGZsYWdzID0gdmFsdWUuZmxhZ3M7XG4gICAgICAgIGlmIChmbGFncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLnRvU3RyaW5nKCkubWF0Y2goL1tnaW11eV0qJC8pO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgPSBtYXRjaFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByeCA9IG5ldyBCU09OUmVnRXhwKHZhbHVlLnNvdXJjZSwgZmxhZ3MpO1xuICAgICAgICByZXR1cm4gcngudG9FeHRlbmRlZEpTT04ob3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVEb2N1bWVudCh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgQlNPTl9UWVBFX01BUFBJTkdTID0ge1xuICAgIEJpbmFyeTogKG8pID0+IG5ldyBCaW5hcnkoby52YWx1ZSgpLCBvLnN1Yl90eXBlKSxcbiAgICBDb2RlOiAobykgPT4gbmV3IENvZGUoby5jb2RlLCBvLnNjb3BlKSxcbiAgICBEQlJlZjogKG8pID0+IG5ldyBEQlJlZihvLmNvbGxlY3Rpb24gfHwgby5uYW1lc3BhY2UsIG8ub2lkLCBvLmRiLCBvLmZpZWxkcyksXG4gICAgRGVjaW1hbDEyODogKG8pID0+IG5ldyBEZWNpbWFsMTI4KG8uYnl0ZXMpLFxuICAgIERvdWJsZTogKG8pID0+IG5ldyBEb3VibGUoby52YWx1ZSksXG4gICAgSW50MzI6IChvKSA9PiBuZXcgSW50MzIoby52YWx1ZSksXG4gICAgTG9uZzogKG8pID0+IExvbmcuZnJvbUJpdHMoby5sb3cgIT0gbnVsbCA/IG8ubG93IDogby5sb3dfLCBvLmxvdyAhPSBudWxsID8gby5oaWdoIDogby5oaWdoXywgby5sb3cgIT0gbnVsbCA/IG8udW5zaWduZWQgOiBvLnVuc2lnbmVkXyksXG4gICAgTWF4S2V5OiAoKSA9PiBuZXcgTWF4S2V5KCksXG4gICAgTWluS2V5OiAoKSA9PiBuZXcgTWluS2V5KCksXG4gICAgT2JqZWN0SWQ6IChvKSA9PiBuZXcgT2JqZWN0SWQobyksXG4gICAgQlNPTlJlZ0V4cDogKG8pID0+IG5ldyBCU09OUmVnRXhwKG8ucGF0dGVybiwgby5vcHRpb25zKSxcbiAgICBCU09OU3ltYm9sOiAobykgPT4gbmV3IEJTT05TeW1ib2woby52YWx1ZSksXG4gICAgVGltZXN0YW1wOiAobykgPT4gVGltZXN0YW1wLmZyb21CaXRzKG8ubG93LCBvLmhpZ2gpXG59O1xuZnVuY3Rpb24gc2VyaWFsaXplRG9jdW1lbnQoZG9jLCBvcHRpb25zKSB7XG4gICAgaWYgKGRvYyA9PSBudWxsIHx8IHR5cGVvZiBkb2MgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdub3QgYW4gb2JqZWN0IGluc3RhbmNlJyk7XG4gICAgY29uc3QgYnNvbnR5cGUgPSBkb2MuX2Jzb250eXBlO1xuICAgIGlmICh0eXBlb2YgYnNvbnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IF9kb2MgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGRvYykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2Vlbk9iamVjdHMucHVzaCh7IHByb3BlcnR5TmFtZTogbmFtZSwgb2JqOiBudWxsIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHNlcmlhbGl6ZVZhbHVlKGRvY1tuYW1lXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZG9jLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9kb2NbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNlZW5PYmplY3RzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZG9jO1xuICAgIH1cbiAgICBlbHNlIGlmIChkb2MgIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgZG9jID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB0eXBlb2YgZG9jLl9ic29udHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgZG9jW1N5bWJvbC5mb3IoJ0BAbWRiLmJzb24udmVyc2lvbicpXSAhPT0gQlNPTl9NQUpPUl9WRVJTSU9OKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09OVmVyc2lvbkVycm9yKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQlNPTlR5cGUoZG9jKSkge1xuICAgICAgICBsZXQgb3V0RG9jID0gZG9jO1xuICAgICAgICBpZiAodHlwZW9mIG91dERvYy50b0V4dGVuZGVkSlNPTiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgbWFwcGVyID0gQlNPTl9UWVBFX01BUFBJTkdTW2RvYy5fYnNvbnR5cGVdO1xuICAgICAgICAgICAgaWYgKCFtYXBwZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdVbnJlY29nbml6ZWQgb3IgaW52YWxpZCBfYnNvbnR5cGU6ICcgKyBkb2MuX2Jzb250eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dERvYyA9IG1hcHBlcihvdXREb2MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChic29udHlwZSA9PT0gJ0NvZGUnICYmIG91dERvYy5zY29wZSkge1xuICAgICAgICAgICAgb3V0RG9jID0gbmV3IENvZGUob3V0RG9jLmNvZGUsIHNlcmlhbGl6ZVZhbHVlKG91dERvYy5zY29wZSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJzb250eXBlID09PSAnREJSZWYnICYmIG91dERvYy5vaWQpIHtcbiAgICAgICAgICAgIG91dERvYyA9IG5ldyBEQlJlZihzZXJpYWxpemVWYWx1ZShvdXREb2MuY29sbGVjdGlvbiwgb3B0aW9ucyksIHNlcmlhbGl6ZVZhbHVlKG91dERvYy5vaWQsIG9wdGlvbnMpLCBzZXJpYWxpemVWYWx1ZShvdXREb2MuZGIsIG9wdGlvbnMpLCBzZXJpYWxpemVWYWx1ZShvdXREb2MuZmllbGRzLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dERvYy50b0V4dGVuZGVkSlNPTihvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ19ic29udHlwZSBtdXN0IGJlIGEgc3RyaW5nLCBidXQgd2FzOiAnICsgdHlwZW9mIGJzb250eXBlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZSh0ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZWpzb25PcHRpb25zID0ge1xuICAgICAgICB1c2VCaWdJbnQ2NDogb3B0aW9ucz8udXNlQmlnSW50NjQgPz8gZmFsc2UsXG4gICAgICAgIHJlbGF4ZWQ6IG9wdGlvbnM/LnJlbGF4ZWQgPz8gdHJ1ZSxcbiAgICAgICAgbGVnYWN5OiBvcHRpb25zPy5sZWdhY3kgPz8gZmFsc2VcbiAgICB9O1xuICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChrZXkuaW5kZXhPZignXFx4MDAnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYEJTT04gRG9jdW1lbnQgZmllbGQgbmFtZXMgY2Fubm90IGNvbnRhaW4gbnVsbCBieXRlcywgZm91bmQ6ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSwgZWpzb25PcHRpb25zKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlLCBvcHRpb25zKSB7XG4gICAgaWYgKHNwYWNlICE9IG51bGwgJiYgdHlwZW9mIHNwYWNlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25zID0gc3BhY2U7XG4gICAgICAgIHNwYWNlID0gMDtcbiAgICB9XG4gICAgaWYgKHJlcGxhY2VyICE9IG51bGwgJiYgdHlwZW9mIHJlcGxhY2VyID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShyZXBsYWNlcikpIHtcbiAgICAgICAgb3B0aW9ucyA9IHJlcGxhY2VyO1xuICAgICAgICByZXBsYWNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3BhY2UgPSAwO1xuICAgIH1cbiAgICBjb25zdCBzZXJpYWxpemVPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHJlbGF4ZWQ6IHRydWUsIGxlZ2FjeTogZmFsc2UgfSwgb3B0aW9ucywge1xuICAgICAgICBzZWVuT2JqZWN0czogW3sgcHJvcGVydHlOYW1lOiAnKHJvb3QpJywgb2JqOiBudWxsIH1dXG4gICAgfSk7XG4gICAgY29uc3QgZG9jID0gc2VyaWFsaXplVmFsdWUodmFsdWUsIHNlcmlhbGl6ZU9wdGlvbnMpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkb2MsIHJlcGxhY2VyLCBzcGFjZSk7XG59XG5mdW5jdGlvbiBFSlNPTnNlcmlhbGl6ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykpO1xufVxuZnVuY3Rpb24gRUpTT05kZXNlcmlhbGl6ZShlanNvbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBwYXJzZShKU09OLnN0cmluZ2lmeShlanNvbiksIG9wdGlvbnMpO1xufVxuY29uc3QgRUpTT04gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuRUpTT04ucGFyc2UgPSBwYXJzZTtcbkVKU09OLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbkVKU09OLnNlcmlhbGl6ZSA9IEVKU09Oc2VyaWFsaXplO1xuRUpTT04uZGVzZXJpYWxpemUgPSBFSlNPTmRlc2VyaWFsaXplO1xuT2JqZWN0LmZyZWV6ZShFSlNPTik7XG5cbmNvbnN0IE1BWFNJWkUgPSAxMDI0ICogMTAyNCAqIDE3O1xubGV0IGJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZShNQVhTSVpFKTtcbmZ1bmN0aW9uIHNldEludGVybmFsQnVmZmVyU2l6ZShzaXplKSB7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCBzaXplKSB7XG4gICAgICAgIGJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZShzaXplKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXJpYWxpemUob2JqZWN0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBjaGVja0tleXMgPSB0eXBlb2Ygb3B0aW9ucy5jaGVja0tleXMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuY2hlY2tLZXlzIDogZmFsc2U7XG4gICAgY29uc3Qgc2VyaWFsaXplRnVuY3Rpb25zID0gdHlwZW9mIG9wdGlvbnMuc2VyaWFsaXplRnVuY3Rpb25zID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnNlcmlhbGl6ZUZ1bmN0aW9ucyA6IGZhbHNlO1xuICAgIGNvbnN0IGlnbm9yZVVuZGVmaW5lZCA9IHR5cGVvZiBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5pZ25vcmVVbmRlZmluZWQgOiB0cnVlO1xuICAgIGNvbnN0IG1pbkludGVybmFsQnVmZmVyU2l6ZSA9IHR5cGVvZiBvcHRpb25zLm1pbkludGVybmFsQnVmZmVyU2l6ZSA9PT0gJ251bWJlcicgPyBvcHRpb25zLm1pbkludGVybmFsQnVmZmVyU2l6ZSA6IE1BWFNJWkU7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCBtaW5JbnRlcm5hbEJ1ZmZlclNpemUpIHtcbiAgICAgICAgYnVmZmVyID0gQnl0ZVV0aWxzLmFsbG9jYXRlKG1pbkludGVybmFsQnVmZmVyU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IHNlcmlhbGl6YXRpb25JbmRleCA9IHNlcmlhbGl6ZUludG8oYnVmZmVyLCBvYmplY3QsIGNoZWNrS2V5cywgMCwgMCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIG51bGwpO1xuICAgIGNvbnN0IGZpbmlzaGVkQnVmZmVyID0gQnl0ZVV0aWxzLmFsbG9jYXRlKHNlcmlhbGl6YXRpb25JbmRleCk7XG4gICAgZmluaXNoZWRCdWZmZXIuc2V0KGJ1ZmZlci5zdWJhcnJheSgwLCBzZXJpYWxpemF0aW9uSW5kZXgpLCAwKTtcbiAgICByZXR1cm4gZmluaXNoZWRCdWZmZXI7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXgob2JqZWN0LCBmaW5hbEJ1ZmZlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tLZXlzID0gdHlwZW9mIG9wdGlvbnMuY2hlY2tLZXlzID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmNoZWNrS2V5cyA6IGZhbHNlO1xuICAgIGNvbnN0IHNlcmlhbGl6ZUZ1bmN0aW9ucyA9IHR5cGVvZiBvcHRpb25zLnNlcmlhbGl6ZUZ1bmN0aW9ucyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5zZXJpYWxpemVGdW5jdGlvbnMgOiBmYWxzZTtcbiAgICBjb25zdCBpZ25vcmVVbmRlZmluZWQgPSB0eXBlb2Ygb3B0aW9ucy5pZ25vcmVVbmRlZmluZWQgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuaWdub3JlVW5kZWZpbmVkIDogdHJ1ZTtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gdHlwZW9mIG9wdGlvbnMuaW5kZXggPT09ICdudW1iZXInID8gb3B0aW9ucy5pbmRleCA6IDA7XG4gICAgY29uc3Qgc2VyaWFsaXphdGlvbkluZGV4ID0gc2VyaWFsaXplSW50byhidWZmZXIsIG9iamVjdCwgY2hlY2tLZXlzLCAwLCAwLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgbnVsbCk7XG4gICAgZmluYWxCdWZmZXIuc2V0KGJ1ZmZlci5zdWJhcnJheSgwLCBzZXJpYWxpemF0aW9uSW5kZXgpLCBzdGFydEluZGV4KTtcbiAgICByZXR1cm4gc3RhcnRJbmRleCArIHNlcmlhbGl6YXRpb25JbmRleCAtIDE7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShidWZmZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBpbnRlcm5hbERlc2VyaWFsaXplKEJ5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIpLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZU9iamVjdFNpemUob2JqZWN0LCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzZXJpYWxpemVGdW5jdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucy5zZXJpYWxpemVGdW5jdGlvbnMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2VyaWFsaXplRnVuY3Rpb25zIDogZmFsc2U7XG4gICAgY29uc3QgaWdub3JlVW5kZWZpbmVkID0gdHlwZW9mIG9wdGlvbnMuaWdub3JlVW5kZWZpbmVkID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZCA6IHRydWU7XG4gICAgcmV0dXJuIGludGVybmFsQ2FsY3VsYXRlT2JqZWN0U2l6ZShvYmplY3QsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplU3RyZWFtKGRhdGEsIHN0YXJ0SW5kZXgsIG51bWJlck9mRG9jdW1lbnRzLCBkb2N1bWVudHMsIGRvY1N0YXJ0SW5kZXgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnRlcm5hbE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgYWxsb3dPYmplY3RTbWFsbGVyVGhhbkJ1ZmZlclNpemU6IHRydWUsIGluZGV4OiAwIH0sIG9wdGlvbnMpO1xuICAgIGNvbnN0IGJ1ZmZlckRhdGEgPSBCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoZGF0YSk7XG4gICAgbGV0IGluZGV4ID0gc3RhcnRJbmRleDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mRG9jdW1lbnRzOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGJ1ZmZlckRhdGFbaW5kZXhdIHxcbiAgICAgICAgICAgIChidWZmZXJEYXRhW2luZGV4ICsgMV0gPDwgOCkgfFxuICAgICAgICAgICAgKGJ1ZmZlckRhdGFbaW5kZXggKyAyXSA8PCAxNikgfFxuICAgICAgICAgICAgKGJ1ZmZlckRhdGFbaW5kZXggKyAzXSA8PCAyNCk7XG4gICAgICAgIGludGVybmFsT3B0aW9ucy5pbmRleCA9IGluZGV4O1xuICAgICAgICBkb2N1bWVudHNbZG9jU3RhcnRJbmRleCArIGldID0gaW50ZXJuYWxEZXNlcmlhbGl6ZShidWZmZXJEYXRhLCBpbnRlcm5hbE9wdGlvbnMpO1xuICAgICAgICBpbmRleCA9IGluZGV4ICsgc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufVxuXG52YXIgYnNvbiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgQlNPTkVycm9yOiBCU09ORXJyb3IsXG4gICAgQlNPTlJlZ0V4cDogQlNPTlJlZ0V4cCxcbiAgICBCU09OUnVudGltZUVycm9yOiBCU09OUnVudGltZUVycm9yLFxuICAgIEJTT05TeW1ib2w6IEJTT05TeW1ib2wsXG4gICAgQlNPTlR5cGU6IEJTT05UeXBlLFxuICAgIEJTT05WYWx1ZTogQlNPTlZhbHVlLFxuICAgIEJTT05WZXJzaW9uRXJyb3I6IEJTT05WZXJzaW9uRXJyb3IsXG4gICAgQmluYXJ5OiBCaW5hcnksXG4gICAgQ29kZTogQ29kZSxcbiAgICBEQlJlZjogREJSZWYsXG4gICAgRGVjaW1hbDEyODogRGVjaW1hbDEyOCxcbiAgICBEb3VibGU6IERvdWJsZSxcbiAgICBFSlNPTjogRUpTT04sXG4gICAgSW50MzI6IEludDMyLFxuICAgIExvbmc6IExvbmcsXG4gICAgTWF4S2V5OiBNYXhLZXksXG4gICAgTWluS2V5OiBNaW5LZXksXG4gICAgT2JqZWN0SWQ6IE9iamVjdElkLFxuICAgIFRpbWVzdGFtcDogVGltZXN0YW1wLFxuICAgIFVVSUQ6IFVVSUQsXG4gICAgY2FsY3VsYXRlT2JqZWN0U2l6ZTogY2FsY3VsYXRlT2JqZWN0U2l6ZSxcbiAgICBkZXNlcmlhbGl6ZTogZGVzZXJpYWxpemUsXG4gICAgZGVzZXJpYWxpemVTdHJlYW06IGRlc2VyaWFsaXplU3RyZWFtLFxuICAgIHNlcmlhbGl6ZTogc2VyaWFsaXplLFxuICAgIHNlcmlhbGl6ZVdpdGhCdWZmZXJBbmRJbmRleDogc2VyaWFsaXplV2l0aEJ1ZmZlckFuZEluZGV4LFxuICAgIHNldEludGVybmFsQnVmZmVyU2l6ZTogc2V0SW50ZXJuYWxCdWZmZXJTaXplXG59KTtcblxuZXhwb3J0cy5CU09OID0gYnNvbjtcbmV4cG9ydHMuQlNPTkVycm9yID0gQlNPTkVycm9yO1xuZXhwb3J0cy5CU09OUmVnRXhwID0gQlNPTlJlZ0V4cDtcbmV4cG9ydHMuQlNPTlJ1bnRpbWVFcnJvciA9IEJTT05SdW50aW1lRXJyb3I7XG5leHBvcnRzLkJTT05TeW1ib2wgPSBCU09OU3ltYm9sO1xuZXhwb3J0cy5CU09OVHlwZSA9IEJTT05UeXBlO1xuZXhwb3J0cy5CU09OVmFsdWUgPSBCU09OVmFsdWU7XG5leHBvcnRzLkJTT05WZXJzaW9uRXJyb3IgPSBCU09OVmVyc2lvbkVycm9yO1xuZXhwb3J0cy5CaW5hcnkgPSBCaW5hcnk7XG5leHBvcnRzLkNvZGUgPSBDb2RlO1xuZXhwb3J0cy5EQlJlZiA9IERCUmVmO1xuZXhwb3J0cy5EZWNpbWFsMTI4ID0gRGVjaW1hbDEyODtcbmV4cG9ydHMuRG91YmxlID0gRG91YmxlO1xuZXhwb3J0cy5FSlNPTiA9IEVKU09OO1xuZXhwb3J0cy5JbnQzMiA9IEludDMyO1xuZXhwb3J0cy5Mb25nID0gTG9uZztcbmV4cG9ydHMuTWF4S2V5ID0gTWF4S2V5O1xuZXhwb3J0cy5NaW5LZXkgPSBNaW5LZXk7XG5leHBvcnRzLk9iamVjdElkID0gT2JqZWN0SWQ7XG5leHBvcnRzLlRpbWVzdGFtcCA9IFRpbWVzdGFtcDtcbmV4cG9ydHMuVVVJRCA9IFVVSUQ7XG5leHBvcnRzLmNhbGN1bGF0ZU9iamVjdFNpemUgPSBjYWxjdWxhdGVPYmplY3RTaXplO1xuZXhwb3J0cy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xuZXhwb3J0cy5kZXNlcmlhbGl6ZVN0cmVhbSA9IGRlc2VyaWFsaXplU3RyZWFtO1xuZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG5leHBvcnRzLnNlcmlhbGl6ZVdpdGhCdWZmZXJBbmRJbmRleCA9IHNlcmlhbGl6ZVdpdGhCdWZmZXJBbmRJbmRleDtcbmV4cG9ydHMuc2V0SW50ZXJuYWxCdWZmZXJTaXplID0gc2V0SW50ZXJuYWxCdWZmZXJTaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnNvbi5janMubWFwXG4iXSwibmFtZXMiOlsiaXNBbnlBcnJheUJ1ZmZlciIsInZhbHVlIiwiaW5jbHVkZXMiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc1VpbnQ4QXJyYXkiLCJpc1JlZ0V4cCIsImQiLCJpc01hcCIsImlzRGF0ZSIsIkJTT05fTUFKT1JfVkVSU0lPTiIsIkJTT05fSU5UMzJfTUFYIiwiQlNPTl9JTlQzMl9NSU4iLCJCU09OX0lOVDY0X01BWCIsIk1hdGgiLCJwb3ciLCJCU09OX0lOVDY0X01JTiIsIkpTX0lOVF9NQVgiLCJKU19JTlRfTUlOIiwiQlNPTl9EQVRBX05VTUJFUiIsIkJTT05fREFUQV9TVFJJTkciLCJCU09OX0RBVEFfT0JKRUNUIiwiQlNPTl9EQVRBX0FSUkFZIiwiQlNPTl9EQVRBX0JJTkFSWSIsIkJTT05fREFUQV9VTkRFRklORUQiLCJCU09OX0RBVEFfT0lEIiwiQlNPTl9EQVRBX0JPT0xFQU4iLCJCU09OX0RBVEFfREFURSIsIkJTT05fREFUQV9OVUxMIiwiQlNPTl9EQVRBX1JFR0VYUCIsIkJTT05fREFUQV9EQlBPSU5URVIiLCJCU09OX0RBVEFfQ09ERSIsIkJTT05fREFUQV9TWU1CT0wiLCJCU09OX0RBVEFfQ09ERV9XX1NDT1BFIiwiQlNPTl9EQVRBX0lOVCIsIkJTT05fREFUQV9USU1FU1RBTVAiLCJCU09OX0RBVEFfTE9ORyIsIkJTT05fREFUQV9ERUNJTUFMMTI4IiwiQlNPTl9EQVRBX01JTl9LRVkiLCJCU09OX0RBVEFfTUFYX0tFWSIsIkJTT05fQklOQVJZX1NVQlRZUEVfREVGQVVMVCIsIkJTT05fQklOQVJZX1NVQlRZUEVfVVVJRF9ORVciLCJCU09OVHlwZSIsImZyZWV6ZSIsImRvdWJsZSIsInN0cmluZyIsIm9iamVjdCIsImFycmF5IiwiYmluRGF0YSIsInVuZGVmaW5lZCIsIm9iamVjdElkIiwiYm9vbCIsImRhdGUiLCJudWxsIiwicmVnZXgiLCJkYlBvaW50ZXIiLCJqYXZhc2NyaXB0Iiwic3ltYm9sIiwiamF2YXNjcmlwdFdpdGhTY29wZSIsImludCIsInRpbWVzdGFtcCIsImxvbmciLCJkZWNpbWFsIiwibWluS2V5IiwibWF4S2V5IiwiQlNPTkVycm9yIiwiRXJyb3IiLCJic29uRXJyb3IiLCJuYW1lIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiaXNCU09ORXJyb3IiLCJCU09OVmVyc2lvbkVycm9yIiwiQlNPTlJ1bnRpbWVFcnJvciIsIm5vZGVqc01hdGhSYW5kb21CeXRlcyIsImJ5dGVMZW5ndGgiLCJub2RlSnNCeXRlVXRpbHMiLCJmcm9tTnVtYmVyQXJyYXkiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJmbG9vciIsInJhbmRvbSIsIm5vZGVqc1JhbmRvbUJ5dGVzIiwicmVxdWlyZSIsInJhbmRvbUJ5dGVzIiwidG9Mb2NhbEJ1ZmZlclR5cGUiLCJwb3RlbnRpYWxCdWZmZXIiLCJCdWZmZXIiLCJpc0J1ZmZlciIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsInN0cmluZ1RhZyIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiU3RyaW5nIiwiYWxsb2NhdGUiLCJzaXplIiwiYWxsb2MiLCJlcXVhbHMiLCJhIiwiYiIsImZyb21CYXNlNjQiLCJiYXNlNjQiLCJ0b0Jhc2U2NCIsImZyb21JU084ODU5MSIsImNvZGVQb2ludHMiLCJ0b0lTTzg4NTkxIiwiZnJvbUhleCIsImhleCIsInRvSGV4IiwiZnJvbVVURjgiLCJ0ZXh0IiwidG9VVEY4Iiwic3RhcnQiLCJlbmQiLCJ1dGY4Qnl0ZUxlbmd0aCIsImlucHV0IiwiZW5jb2RlVVRGOEludG8iLCJzb3VyY2UiLCJ3cml0ZSIsImlzUmVhY3ROYXRpdmUiLCJuYXZpZ2F0b3IiLCJnbG9iYWxUaGlzIiwicHJvZHVjdCIsIndlYk1hdGhSYW5kb21CeXRlcyIsIlJhbmdlRXJyb3IiLCJ3ZWJCeXRlVXRpbHMiLCJ3ZWJSYW5kb21CeXRlcyIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsImNvbnNvbGUiLCJ3YXJuIiwiSEVYX0RJR0lUIiwicG90ZW50aWFsVWludDhhcnJheSIsIlVpbnQ4QXJyYXkiLCJzbGljZSIsIlR5cGVFcnJvciIsImkiLCJhdG9iIiwiYyIsImNoYXJDb2RlQXQiLCJ1aW50OGFycmF5IiwiYnRvYSIsIlVpbnQxNkFycmF5IiwiZnJvbUNoYXJDb2RlIiwiam9pbiIsImV2ZW5MZW5ndGhIZXgiLCJmaXJzdERpZ2l0Iiwic2Vjb25kRGlnaXQiLCJ0ZXN0IiwiaGV4RGlnaXQiLCJOdW1iZXIiLCJwYXJzZUludCIsInB1c2giLCJieXRlIiwicGFkU3RhcnQiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsIlRleHREZWNvZGVyIiwiZmF0YWwiLCJkZWNvZGUiLCJieXRlcyIsInNldCIsImhhc0dsb2JhbEJ1ZmZlciIsIl9pc0J1ZmZlciIsIkJ5dGVVdGlscyIsIkJTT05EYXRhVmlldyIsIkRhdGFWaWV3IiwiZnJvbVVpbnQ4QXJyYXkiLCJCU09OVmFsdWUiLCJmb3IiLCJCaW5hcnkiLCJfYnNvbnR5cGUiLCJzdWJUeXBlIiwiaXNBcnJheSIsInN1Yl90eXBlIiwiQlVGRkVSX1NJWkUiLCJwb3NpdGlvbiIsInB1dCIsImJ5dGVWYWx1ZSIsImRlY29kZWRCeXRlIiwibmV3U3BhY2UiLCJzZXF1ZW5jZSIsIm9mZnNldCIsInJlYWQiLCJhc1JhdyIsInN1YmFycmF5IiwidG9KU09OIiwiZW5jb2RpbmciLCJ0b0V4dGVuZGVkSlNPTiIsIm9wdGlvbnMiLCJiYXNlNjRTdHJpbmciLCJsZWdhY3kiLCIkYmluYXJ5IiwiJHR5cGUiLCJ0b1VVSUQiLCJTVUJUWVBFX1VVSUQiLCJVVUlEIiwiY3JlYXRlRnJvbUhleFN0cmluZyIsImNyZWF0ZUZyb21CYXNlNjQiLCJmcm9tRXh0ZW5kZWRKU09OIiwiZG9jIiwiZGF0YSIsInR5cGUiLCJieXRlc0Zyb21TdHJpbmciLCIkdXVpZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJpbnNwZWN0IiwiU1VCVFlQRV9ERUZBVUxUIiwiU1VCVFlQRV9GVU5DVElPTiIsIlNVQlRZUEVfQllURV9BUlJBWSIsIlNVQlRZUEVfVVVJRF9PTEQiLCJTVUJUWVBFX01ENSIsIlNVQlRZUEVfRU5DUllQVEVEIiwiU1VCVFlQRV9DT0xVTU4iLCJTVUJUWVBFX1VTRVJfREVGSU5FRCIsIlVVSURfQllURV9MRU5HVEgiLCJVVUlEX1dJVEhPVVRfREFTSEVTIiwiVVVJRF9XSVRIX0RBU0hFUyIsImdlbmVyYXRlIiwiaWQiLCJ0b0hleFN0cmluZyIsImluY2x1ZGVEYXNoZXMiLCJvdGhlcklkIiwidG9CaW5hcnkiLCJpc1ZhbGlkIiwiaXNWYWxpZFVVSURTdHJpbmciLCJoZXhTdHJpbmciLCJyZXByZXNlbnRhdGlvbiIsInJlcGxhY2UiLCJjYWNoZUhleFN0cmluZyIsIkNvZGUiLCJjb2RlIiwic2NvcGUiLCIkY29kZSIsIiRzY29wZSIsImNvZGVKc29uIiwiaXNEQlJlZkxpa2UiLCIkaWQiLCIkcmVmIiwiJGRiIiwiREJSZWYiLCJjb2xsZWN0aW9uIiwib2lkIiwiZGIiLCJmaWVsZHMiLCJwYXJ0cyIsInNwbGl0Iiwic2hpZnQiLCJuYW1lc3BhY2UiLCJvIiwiYXNzaWduIiwiY29weSIsIndhc20iLCJXZWJBc3NlbWJseSIsIkluc3RhbmNlIiwiTW9kdWxlIiwiZXhwb3J0cyIsIlRXT19QV1JfMTZfREJMIiwiVFdPX1BXUl8yNF9EQkwiLCJUV09fUFdSXzMyX0RCTCIsIlRXT19QV1JfNjRfREJMIiwiVFdPX1BXUl82M19EQkwiLCJJTlRfQ0FDSEUiLCJVSU5UX0NBQ0hFIiwiTUFYX0lOVDY0X1NUUklOR19MRU5HVEgiLCJERUNJTUFMX1JFR19FWCIsIkxvbmciLCJfX2lzTG9uZ19fIiwibG93IiwiaGlnaCIsInVuc2lnbmVkIiwiZnJvbUJpZ0ludCIsImZyb21TdHJpbmciLCJmcm9tQml0cyIsImxvd0JpdHMiLCJoaWdoQml0cyIsImZyb21JbnQiLCJvYmoiLCJjYWNoZWRPYmoiLCJjYWNoZSIsImZyb21OdW1iZXIiLCJpc05hTiIsIlVaRVJPIiwiWkVSTyIsIk1BWF9VTlNJR05FRF9WQUxVRSIsIk1JTl9WQUxVRSIsIk1BWF9WQUxVRSIsIm5lZyIsInN0ciIsInJhZGl4IiwicCIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJyYWRpeFRvUG93ZXIiLCJyZXN1bHQiLCJtaW4iLCJwb3dlciIsIm11bCIsImFkZCIsImZyb21CeXRlcyIsImxlIiwiZnJvbUJ5dGVzTEUiLCJmcm9tQnl0ZXNCRSIsImlzTG9uZyIsImZyb21WYWx1ZSIsInZhbCIsImFkZGVuZCIsImE0OCIsImEzMiIsImExNiIsImEwMCIsImI0OCIsImIzMiIsImIxNiIsImIwMCIsImM0OCIsImMzMiIsImMxNiIsImMwMCIsImFuZCIsIm90aGVyIiwiY29tcGFyZSIsImVxIiwidGhpc05lZyIsImlzTmVnYXRpdmUiLCJvdGhlck5lZyIsInN1YiIsImNvbXAiLCJkaXZpZGUiLCJkaXZpc29yIiwiaXNaZXJvIiwiZGl2X3UiLCJkaXZfcyIsImdldF9oaWdoIiwiYXBwcm94IiwicmVtIiwicmVzIiwiT05FIiwiTkVHX09ORSIsImhhbGZUaGlzIiwic2hyIiwiZGl2Iiwic2hsIiwidG9VbnNpZ25lZCIsImd0Iiwic2hydSIsIlVPTkUiLCJndGUiLCJtYXgiLCJ0b051bWJlciIsImxvZzIiLCJjZWlsIiwibG9nIiwiTE4yIiwiZGVsdGEiLCJhcHByb3hSZXMiLCJhcHByb3hSZW0iLCJnZXRIaWdoQml0cyIsImdldEhpZ2hCaXRzVW5zaWduZWQiLCJnZXRMb3dCaXRzIiwiZ2V0TG93Qml0c1Vuc2lnbmVkIiwiZ2V0TnVtQml0c0FicyIsImJpdCIsImdyZWF0ZXJUaGFuIiwiZ3JlYXRlclRoYW5PckVxdWFsIiwiZ2UiLCJpc0V2ZW4iLCJpc09kZCIsImlzUG9zaXRpdmUiLCJsZXNzVGhhbiIsImx0IiwibGVzc1RoYW5PckVxdWFsIiwibHRlIiwibW9kdWxvIiwicmVtX3UiLCJyZW1fcyIsIm1vZCIsIm11bHRpcGx5IiwibXVsdGlwbGllciIsIlRXT19QV1JfMjQiLCJuZWdhdGUiLCJub3QiLCJub3RFcXVhbHMiLCJuZXEiLCJuZSIsIm9yIiwic2hpZnRMZWZ0IiwibnVtQml0cyIsInRvSW50Iiwic2hpZnRSaWdodCIsInNoaWZ0UmlnaHRVbnNpZ25lZCIsInNocl91Iiwic3VidHJhY3QiLCJzdWJ0cmFoZW5kIiwidG9CaWdJbnQiLCJCaWdJbnQiLCJ0b0J5dGVzIiwidG9CeXRlc0xFIiwidG9CeXRlc0JFIiwiaGkiLCJsbyIsInRvU2lnbmVkIiwicmFkaXhMb25nIiwicmVtMSIsInJlbURpdiIsImludHZhbCIsImRpZ2l0cyIsInhvciIsImVxeiIsInJlbGF4ZWQiLCIkbnVtYmVyTG9uZyIsInVzZUJpZ0ludDY0IiwiYmlnSW50UmVzdWx0IiwiYXNJbnROIiwibG9uZ1Jlc3VsdCIsIlBBUlNFX1NUUklOR19SRUdFWFAiLCJQQVJTRV9JTkZfUkVHRVhQIiwiUEFSU0VfTkFOX1JFR0VYUCIsIkVYUE9ORU5UX01BWCIsIkVYUE9ORU5UX01JTiIsIkVYUE9ORU5UX0JJQVMiLCJNQVhfRElHSVRTIiwiTkFOX0JVRkZFUiIsInJldmVyc2UiLCJJTkZfTkVHQVRJVkVfQlVGRkVSIiwiSU5GX1BPU0lUSVZFX0JVRkZFUiIsIkVYUE9ORU5UX1JFR0VYIiwiQ09NQklOQVRJT05fTUFTSyIsIkVYUE9ORU5UX01BU0siLCJDT01CSU5BVElPTl9JTkZJTklUWSIsIkNPTUJJTkFUSU9OX05BTiIsImlzRGlnaXQiLCJkaXZpZGV1MTI4IiwiRElWSVNPUiIsIl9yZW0iLCJxdW90aWVudCIsIm11bHRpcGx5NjR4MiIsImxlZnQiLCJyaWdodCIsImxlZnRIaWdoIiwibGVmdExvdyIsInJpZ2h0SGlnaCIsInJpZ2h0TG93IiwicHJvZHVjdEhpZ2giLCJwcm9kdWN0TWlkIiwicHJvZHVjdE1pZDIiLCJwcm9kdWN0TG93IiwidWhsZWZ0IiwidWhyaWdodCIsInVsbGVmdCIsInVscmlnaHQiLCJpbnZhbGlkRXJyIiwiRGVjaW1hbDEyOCIsIl9mcm9tU3RyaW5nIiwiYWxsb3dSb3VuZGluZyIsImZyb21TdHJpbmdXaXRoUm91bmRpbmciLCJzYXdTaWduIiwic2F3UmFkaXgiLCJmb3VuZE5vblplcm8iLCJzaWduaWZpY2FudERpZ2l0cyIsIm5EaWdpdHNSZWFkIiwibkRpZ2l0cyIsInJhZGl4UG9zaXRpb24iLCJmaXJzdE5vblplcm8iLCJuRGlnaXRzU3RvcmVkIiwiZGlnaXRzSW5zZXJ0IiwibGFzdERpZ2l0IiwiZXhwb25lbnQiLCJzaWduaWZpY2FuZEhpZ2giLCJzaWduaWZpY2FuZExvdyIsImJpYXNlZEV4cG9uZW50IiwiaW5kZXgiLCJzdHJpbmdNYXRjaCIsIm1hdGNoIiwiaW5mTWF0Y2giLCJuYW5NYXRjaCIsInVuc2lnbmVkTnVtYmVyIiwiZSIsImV4cFNpZ24iLCJleHBOdW1iZXIiLCJzdWJzdHIiLCJkaWdpdHNTdHJpbmciLCJlbmRPZlN0cmluZyIsInJvdW5kRGlnaXQiLCJyb3VuZEJpdCIsImRJZHgiLCJzaWduaWZpY2FuZCIsImRlYyIsImJpYXNlZF9leHBvbmVudCIsInNpZ25pZmljYW5kX2RpZ2l0cyIsImlzX3plcm8iLCJzaWduaWZpY2FuZF9tc2IiLCJzaWduaWZpY2FuZDEyOCIsImoiLCJrIiwibWlkbCIsIm1pZGgiLCJjb21iaW5hdGlvbiIsImxlYXN0X2RpZ2l0cyIsInNjaWVudGlmaWNfZXhwb25lbnQiLCJyYWRpeF9wb3NpdGlvbiIsIiRudW1iZXJEZWNpbWFsIiwiRG91YmxlIiwidmFsdWVPZiIsImlzRmluaXRlIiwiaXMiLCJzaWduIiwiJG51bWJlckRvdWJsZSIsImlzSW50ZWdlciIsInRvRml4ZWQiLCJkb3VibGVWYWx1ZSIsInBhcnNlRmxvYXQiLCJlSlNPTiIsIkludDMyIiwiJG51bWJlckludCIsIk1heEtleSIsIiRtYXhLZXkiLCJNaW5LZXkiLCIkbWluS2V5IiwiY2hlY2tGb3JIZXhSZWdFeHAiLCJSZWdFeHAiLCJQUk9DRVNTX1VOSVFVRSIsImtJZCIsIk9iamVjdElkIiwiaW5wdXRJZCIsIndvcmtpbmdJZCIsIl9faWQiLCJnZXRJbmMiLCJ0aW1lIiwiRGF0ZSIsIm5vdyIsImluYyIsInNldFVpbnQzMiIsInRvTG93ZXJDYXNlIiwib3RoZXJJZFN0cmluZyIsInRoaXNJZFN0cmluZyIsImdldFRpbWVzdGFtcCIsImdldFVpbnQzMiIsInNldFRpbWUiLCJjcmVhdGVQayIsImNyZWF0ZUZyb21UaW1lIiwiJG9pZCIsImludGVybmFsQ2FsY3VsYXRlT2JqZWN0U2l6ZSIsInNlcmlhbGl6ZUZ1bmN0aW9ucyIsImlnbm9yZVVuZGVmaW5lZCIsInRvdGFsTGVuZ3RoIiwiY2FsY3VsYXRlRWxlbWVudCIsInRvQlNPTiIsImtleSIsImtleXMiLCJiaW5hcnkiLCJvcmRlcmVkX3ZhbHVlcyIsImdsb2JhbCIsImlnbm9yZUNhc2UiLCJtdWx0aWxpbmUiLCJwYXR0ZXJuIiwiYWxwaGFiZXRpemUiLCJzb3J0IiwiQlNPTlJlZ0V4cCIsInBhcnNlT3B0aW9ucyIsIiRyZWdleCIsIiRvcHRpb25zIiwiJHJlZ3VsYXJFeHByZXNzaW9uIiwiQlNPTlN5bWJvbCIsIiRzeW1ib2wiLCJMb25nV2l0aG91dE92ZXJyaWRlc0NsYXNzIiwiVGltZXN0YW1wIiwidCIsIiR0aW1lc3RhbXAiLCJvcHRSYWRpeCIsIkZJUlNUX0JJVCIsIkZJUlNUX1RXT19CSVRTIiwiRklSU1RfVEhSRUVfQklUUyIsIkZJUlNUX0ZPVVJfQklUUyIsIkZJUlNUX0ZJVkVfQklUUyIsIlRXT19CSVRfQ0hBUiIsIlRIUkVFX0JJVF9DSEFSIiwiRk9VUl9CSVRfQ0hBUiIsIkNPTlRJTlVJTkdfQ0hBUiIsInZhbGlkYXRlVXRmOCIsImNvbnRpbnVhdGlvbiIsIkpTX0lOVF9NQVhfTE9ORyIsIkpTX0lOVF9NSU5fTE9ORyIsImludGVybmFsRGVzZXJpYWxpemUiLCJhbGxvd09iamVjdFNtYWxsZXJUaGFuQnVmZmVyU2l6ZSIsImRlc2VyaWFsaXplT2JqZWN0IiwiYWxsb3dlZERCUmVmS2V5cyIsImZpZWxkc0FzUmF3IiwicmF3IiwiYnNvblJlZ0V4cCIsInByb21vdGVCdWZmZXJzIiwicHJvbW90ZUxvbmdzIiwicHJvbW90ZVZhbHVlcyIsInZhbGlkYXRpb24iLCJ1dGY4IiwiZ2xvYmFsVVRGVmFsaWRhdGlvbiIsInZhbGlkYXRpb25TZXR0aW5nIiwidXRmOEtleXNTZXQiLCJTZXQiLCJ1dGY4VmFsaWRhdGVkS2V5cyIsInV0ZjhWYWxpZGF0aW9uVmFsdWVzIiwibWFwIiwiZXZlcnkiLCJpdGVtIiwic3RhcnRJbmRleCIsImFycmF5SW5kZXgiLCJkb25lIiwiaXNQb3NzaWJsZURCUmVmIiwiZGF0YXZpZXciLCJlbGVtZW50VHlwZSIsInNob3VsZFZhbGlkYXRlS2V5IiwiaGFzIiwic3RyaW5nU2l6ZSIsImdldFZhbGlkYXRlZFN0cmluZyIsImdldEZsb2F0NjQiLCJfaW5kZXgiLCJvYmplY3RTaXplIiwib2JqZWN0T3B0aW9ucyIsImFycmF5T3B0aW9ucyIsInN0b3BJbmRleCIsImdldEJpZ0ludDY0IiwiYmluYXJ5U2l6ZSIsInRvdGFsQmluYXJ5U2l6ZSIsIl9idWZmZXIiLCJyZWdFeHBPcHRpb25zIiwib3B0aW9uc0FycmF5IiwiZnVuY3Rpb25TdHJpbmciLCJ0b3RhbFNpemUiLCJzY29wZU9iamVjdCIsIm9pZEJ1ZmZlciIsImRlZmluZVByb3BlcnR5Iiwid3JpdGFibGUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwic2hvdWxkVmFsaWRhdGVVdGY4IiwicmVnZXhwIiwiaWdub3JlS2V5cyIsInNlcmlhbGl6ZVN0cmluZyIsIm51bWJlck9mV3JpdHRlbkJ5dGVzIiwiTlVNQkVSX1NQQUNFIiwiRk9VUl9CWVRFX1ZJRVdfT05fTlVNQkVSIiwiRUlHSFRfQllURV9WSUVXX09OX05VTUJFUiIsInNlcmlhbGl6ZU51bWJlciIsImlzTmVnYXRpdmVaZXJvIiwiaXNTYWZlSW50ZWdlciIsInNldEludDMyIiwic2V0RmxvYXQ2NCIsInNlcmlhbGl6ZUJpZ0ludCIsInNldEJpZ0ludDY0Iiwic2VyaWFsaXplTnVsbCIsIl8iLCJzZXJpYWxpemVCb29sZWFuIiwic2VyaWFsaXplRGF0ZSIsImRhdGVJbk1pbGlzIiwiZ2V0VGltZSIsInNlcmlhbGl6ZVJlZ0V4cCIsInNlcmlhbGl6ZUJTT05SZWdFeHAiLCJzb3J0ZWRPcHRpb25zIiwic2VyaWFsaXplTWluTWF4Iiwic2VyaWFsaXplT2JqZWN0SWQiLCJzZXJpYWxpemVCdWZmZXIiLCJzZXJpYWxpemVPYmplY3QiLCJjaGVja0tleXMiLCJkZXB0aCIsInBhdGgiLCJlbmRJbmRleCIsInNlcmlhbGl6ZUludG8iLCJkZWxldGUiLCJzZXJpYWxpemVEZWNpbWFsMTI4Iiwic2VyaWFsaXplTG9uZyIsInNlcmlhbGl6ZUludDMyIiwic2VyaWFsaXplRG91YmxlIiwic2VyaWFsaXplRnVuY3Rpb24iLCJzZXJpYWxpemVDb2RlIiwiY29kZVNpemUiLCJzZXJpYWxpemVCaW5hcnkiLCJzZXJpYWxpemVTeW1ib2wiLCJzZXJpYWxpemVEQlJlZiIsIm91dHB1dCIsInN0YXJ0aW5nSW5kZXgiLCJNYXAiLCJpdGVyYXRvciIsImVudHJpZXMiLCJlbnRyeSIsIm5leHQiLCJpc0JTT05UeXBlIiwia2V5c1RvQ29kZWNzIiwiZGVzZXJpYWxpemVWYWx1ZSIsImluMzJCaXRSYW5nZSIsImluNjRCaXRSYW5nZSIsIiR1bmRlZmluZWQiLCJmaWx0ZXIiLCJzdGFydHNXaXRoIiwiJGRhdGUiLCJwYXJzZSIsIiRkYlBvaW50ZXIiLCJ2IiwiZG9sbGFyS2V5cyIsInZhbGlkIiwiZm9yRWFjaCIsInNlcmlhbGl6ZUFycmF5Iiwic2Vlbk9iamVjdHMiLCJwcm9wZXJ0eU5hbWUiLCJzZXJpYWxpemVWYWx1ZSIsInBvcCIsImdldElTT1N0cmluZyIsImlzb1N0ciIsInRvSVNPU3RyaW5nIiwiZ2V0VVRDTWlsbGlzZWNvbmRzIiwiY3JlYXRlIiwiZmluZEluZGV4IiwicHJvcHMiLCJsZWFkaW5nUGFydCIsInByb3AiLCJhbHJlYWR5U2VlbiIsImNpcmN1bGFyUGFydCIsImN1cnJlbnQiLCJsZWFkaW5nU3BhY2UiLCJyZXBlYXQiLCJkYXNoZXMiLCJkYXRlTnVtIiwiaW5SYW5nZSIsImZsYWdzIiwicngiLCJzZXJpYWxpemVEb2N1bWVudCIsIkJTT05fVFlQRV9NQVBQSU5HUyIsImxvd18iLCJoaWdoXyIsInVuc2lnbmVkXyIsImJzb250eXBlIiwiX2RvYyIsIm91dERvYyIsIm1hcHBlciIsImVqc29uT3B0aW9ucyIsInJlcGxhY2VyIiwic3BhY2UiLCJzZXJpYWxpemVPcHRpb25zIiwiRUpTT05zZXJpYWxpemUiLCJFSlNPTmRlc2VyaWFsaXplIiwiZWpzb24iLCJFSlNPTiIsInNlcmlhbGl6ZSIsImRlc2VyaWFsaXplIiwiTUFYU0laRSIsInNldEludGVybmFsQnVmZmVyU2l6ZSIsIm1pbkludGVybmFsQnVmZmVyU2l6ZSIsInNlcmlhbGl6YXRpb25JbmRleCIsImZpbmlzaGVkQnVmZmVyIiwic2VyaWFsaXplV2l0aEJ1ZmZlckFuZEluZGV4IiwiZmluYWxCdWZmZXIiLCJjYWxjdWxhdGVPYmplY3RTaXplIiwiZGVzZXJpYWxpemVTdHJlYW0iLCJudW1iZXJPZkRvY3VtZW50cyIsImRvY3VtZW50cyIsImRvY1N0YXJ0SW5kZXgiLCJpbnRlcm5hbE9wdGlvbnMiLCJidWZmZXJEYXRhIiwiYnNvbiIsIl9fcHJvdG9fXyIsIkJTT04iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bson/lib/bson.cjs\n");

/***/ })

};
;