"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mquery";
exports.ids = ["vendor-chunks/mquery"];
exports.modules = {

/***/ "(ssr)/./node_modules/mquery/lib/collection/collection.js":
/*!**********************************************************!*\
  !*** ./node_modules/mquery/lib/collection/collection.js ***!
  \**********************************************************/
/***/ ((module, exports) => {

eval("\n/**\n * methods a collection must implement\n */ const methods = [\n    \"find\",\n    \"findOne\",\n    \"updateMany\",\n    \"updateOne\",\n    \"replaceOne\",\n    \"count\",\n    \"distinct\",\n    \"findOneAndDelete\",\n    \"findOneAndUpdate\",\n    \"aggregate\",\n    \"findCursor\",\n    \"deleteOne\",\n    \"deleteMany\"\n];\n/**\n * Collection base class from which implementations inherit\n */ function Collection() {}\nfor(let i = 0, len = methods.length; i < len; ++i){\n    const method = methods[i];\n    Collection.prototype[method] = notImplemented(method);\n}\nmodule.exports = exports = Collection;\nCollection.methods = methods;\n/**\n * creates a function which throws an implementation error\n */ function notImplemented(method) {\n    return function() {\n        throw new Error(\"collection.\" + method + \" not implemented\");\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL2NvbGxlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Q0FFQyxHQUVELE1BQU1BLFVBQVU7SUFDZDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQ7O0NBRUMsR0FFRCxTQUFTQyxjQUFjO0FBRXZCLElBQUssSUFBSUMsSUFBSSxHQUFHQyxNQUFNSCxRQUFRSSxNQUFNLEVBQUVGLElBQUlDLEtBQUssRUFBRUQsRUFBRztJQUNsRCxNQUFNRyxTQUFTTCxPQUFPLENBQUNFLEVBQUU7SUFDekJELFdBQVdLLFNBQVMsQ0FBQ0QsT0FBTyxHQUFHRSxlQUFlRjtBQUNoRDtBQUVBRyxPQUFPQyxPQUFPLEdBQUdBLFVBQVVSO0FBQzNCQSxXQUFXRCxPQUFPLEdBQUdBO0FBRXJCOztDQUVDLEdBRUQsU0FBU08sZUFBZUYsTUFBTTtJQUM1QixPQUFPO1FBQ0wsTUFBTSxJQUFJSyxNQUFNLGdCQUFnQkwsU0FBUztJQUMzQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hdXRoLXJlZ2lzdGVyLy4vbm9kZV9tb2R1bGVzL21xdWVyeS9saWIvY29sbGVjdGlvbi9jb2xsZWN0aW9uLmpzPzY1NmYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIG1ldGhvZHMgYSBjb2xsZWN0aW9uIG11c3QgaW1wbGVtZW50XG4gKi9cblxuY29uc3QgbWV0aG9kcyA9IFtcbiAgJ2ZpbmQnLFxuICAnZmluZE9uZScsXG4gICd1cGRhdGVNYW55JyxcbiAgJ3VwZGF0ZU9uZScsXG4gICdyZXBsYWNlT25lJyxcbiAgJ2NvdW50JyxcbiAgJ2Rpc3RpbmN0JyxcbiAgJ2ZpbmRPbmVBbmREZWxldGUnLFxuICAnZmluZE9uZUFuZFVwZGF0ZScsXG4gICdhZ2dyZWdhdGUnLFxuICAnZmluZEN1cnNvcicsXG4gICdkZWxldGVPbmUnLFxuICAnZGVsZXRlTWFueSdcbl07XG5cbi8qKlxuICogQ29sbGVjdGlvbiBiYXNlIGNsYXNzIGZyb20gd2hpY2ggaW1wbGVtZW50YXRpb25zIGluaGVyaXRcbiAqL1xuXG5mdW5jdGlvbiBDb2xsZWN0aW9uKCkge31cblxuZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgY29uc3QgbWV0aG9kID0gbWV0aG9kc1tpXTtcbiAgQ29sbGVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG5vdEltcGxlbWVudGVkKG1ldGhvZCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IENvbGxlY3Rpb247XG5Db2xsZWN0aW9uLm1ldGhvZHMgPSBtZXRob2RzO1xuXG4vKipcbiAqIGNyZWF0ZXMgYSBmdW5jdGlvbiB3aGljaCB0aHJvd3MgYW4gaW1wbGVtZW50YXRpb24gZXJyb3JcbiAqL1xuXG5mdW5jdGlvbiBub3RJbXBsZW1lbnRlZChtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY29sbGVjdGlvbi4nICsgbWV0aG9kICsgJyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJtZXRob2RzIiwiQ29sbGVjdGlvbiIsImkiLCJsZW4iLCJsZW5ndGgiLCJtZXRob2QiLCJwcm90b3R5cGUiLCJub3RJbXBsZW1lbnRlZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/collection/collection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mquery/lib/collection/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mquery/lib/collection/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst env = __webpack_require__(/*! ../env */ \"(ssr)/./node_modules/mquery/lib/env.js\");\nif (\"unknown\" == env.type) {\n    throw new Error(\"Unknown environment\");\n}\nmodule.exports = env.isNode ? __webpack_require__(/*! ./node */ \"(ssr)/./node_modules/mquery/lib/collection/node.js\") : env.isMongo ? __webpack_require__(/*! ./collection */ \"(ssr)/./node_modules/mquery/lib/collection/collection.js\") : __webpack_require__(/*! ./collection */ \"(ssr)/./node_modules/mquery/lib/collection/collection.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsTUFBTUMsbUJBQU9BLENBQUM7QUFFcEIsSUFBSSxhQUFhRCxJQUFJRSxJQUFJLEVBQUU7SUFDekIsTUFBTSxJQUFJQyxNQUFNO0FBQ2xCO0FBRUFDLE9BQU9DLE9BQU8sR0FDWkwsSUFBSU0sTUFBTSxHQUFHTCxtQkFBT0EsQ0FBQyxzRUFDbkJELElBQUlPLE9BQU8sR0FBR04sbUJBQU9BLENBQUMsa0ZBQ3BCQSxtQkFBT0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXV0aC1yZWdpc3Rlci8uL25vZGVfbW9kdWxlcy9tcXVlcnkvbGliL2NvbGxlY3Rpb24vaW5kZXguanM/N2JlNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGVudiA9IHJlcXVpcmUoJy4uL2VudicpO1xuXG5pZiAoJ3Vua25vd24nID09IGVudi50eXBlKSB7XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbnZpcm9ubWVudCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9XG4gIGVudi5pc05vZGUgPyByZXF1aXJlKCcuL25vZGUnKSA6XG4gICAgZW52LmlzTW9uZ28gPyByZXF1aXJlKCcuL2NvbGxlY3Rpb24nKSA6XG4gICAgICByZXF1aXJlKCcuL2NvbGxlY3Rpb24nKTtcblxuIl0sIm5hbWVzIjpbImVudiIsInJlcXVpcmUiLCJ0eXBlIiwiRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIiwiaXNOb2RlIiwiaXNNb25nbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/collection/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mquery/lib/collection/node.js":
/*!****************************************************!*\
  !*** ./node_modules/mquery/lib/collection/node.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n/**\n * Module dependencies\n */ const Collection = __webpack_require__(/*! ./collection */ \"(ssr)/./node_modules/mquery/lib/collection/collection.js\");\nclass NodeCollection extends Collection {\n    constructor(col){\n        super();\n        this.collection = col;\n        this.collectionName = col.collectionName;\n    }\n    /**\n   * find(match, options)\n   */ async find(match, options) {\n        const cursor = this.collection.find(match, options);\n        return cursor.toArray();\n    }\n    /**\n   * findOne(match, options)\n   */ async findOne(match, options) {\n        return this.collection.findOne(match, options);\n    }\n    /**\n   * count(match, options)\n   */ async count(match, options) {\n        return this.collection.count(match, options);\n    }\n    /**\n   * distinct(prop, match, options)\n   */ async distinct(prop, match, options) {\n        return this.collection.distinct(prop, match, options);\n    }\n    /**\n   * updateMany(match, update, options)\n   */ async updateMany(match, update, options) {\n        return this.collection.updateMany(match, update, options);\n    }\n    /**\n   * updateOne(match, update, options)\n   */ async updateOne(match, update, options) {\n        return this.collection.updateOne(match, update, options);\n    }\n    /**\n   * replaceOne(match, update, options)\n   */ async replaceOne(match, update, options) {\n        return this.collection.replaceOne(match, update, options);\n    }\n    /**\n   * deleteOne(match, options)\n   */ async deleteOne(match, options) {\n        return this.collection.deleteOne(match, options);\n    }\n    /**\n   * deleteMany(match, options)\n   */ async deleteMany(match, options) {\n        return this.collection.deleteMany(match, options);\n    }\n    /**\n   * findOneAndDelete(match, options, function(err[, result])\n   */ async findOneAndDelete(match, options) {\n        return this.collection.findOneAndDelete(match, options);\n    }\n    /**\n   * findOneAndUpdate(match, update, options)\n   */ async findOneAndUpdate(match, update, options) {\n        return this.collection.findOneAndUpdate(match, update, options);\n    }\n    /**\n   * var cursor = findCursor(match, options)\n   */ findCursor(match, options) {\n        return this.collection.find(match, options);\n    }\n}\n/**\n * Expose\n */ module.exports = exports = NodeCollection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL25vZGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Q0FFQyxHQUVELE1BQU1BLGFBQWFDLG1CQUFPQSxDQUFDO0FBRTNCLE1BQU1DLHVCQUF1QkY7SUFDM0JHLFlBQVlDLEdBQUcsQ0FBRTtRQUNmLEtBQUs7UUFFTCxJQUFJLENBQUNDLFVBQVUsR0FBR0Q7UUFDbEIsSUFBSSxDQUFDRSxjQUFjLEdBQUdGLElBQUlFLGNBQWM7SUFDMUM7SUFFQTs7R0FFQyxHQUNELE1BQU1DLEtBQUtDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ3pCLE1BQU1DLFNBQVMsSUFBSSxDQUFDTCxVQUFVLENBQUNFLElBQUksQ0FBQ0MsT0FBT0M7UUFFM0MsT0FBT0MsT0FBT0MsT0FBTztJQUN2QjtJQUVBOztHQUVDLEdBQ0QsTUFBTUMsUUFBUUosS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDNUIsT0FBTyxJQUFJLENBQUNKLFVBQVUsQ0FBQ08sT0FBTyxDQUFDSixPQUFPQztJQUN4QztJQUVBOztHQUVDLEdBQ0QsTUFBTUksTUFBTUwsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDMUIsT0FBTyxJQUFJLENBQUNKLFVBQVUsQ0FBQ1EsS0FBSyxDQUFDTCxPQUFPQztJQUN0QztJQUVBOztHQUVDLEdBQ0QsTUFBTUssU0FBU0MsSUFBSSxFQUFFUCxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNuQyxPQUFPLElBQUksQ0FBQ0osVUFBVSxDQUFDUyxRQUFRLENBQUNDLE1BQU1QLE9BQU9DO0lBQy9DO0lBRUE7O0dBRUMsR0FDRCxNQUFNTyxXQUFXUixLQUFLLEVBQUVTLE1BQU0sRUFBRVIsT0FBTyxFQUFFO1FBQ3ZDLE9BQU8sSUFBSSxDQUFDSixVQUFVLENBQUNXLFVBQVUsQ0FBQ1IsT0FBT1MsUUFBUVI7SUFDbkQ7SUFFQTs7R0FFQyxHQUNELE1BQU1TLFVBQVVWLEtBQUssRUFBRVMsTUFBTSxFQUFFUixPQUFPLEVBQUU7UUFDdEMsT0FBTyxJQUFJLENBQUNKLFVBQVUsQ0FBQ2EsU0FBUyxDQUFDVixPQUFPUyxRQUFRUjtJQUNsRDtJQUVBOztHQUVDLEdBQ0QsTUFBTVUsV0FBV1gsS0FBSyxFQUFFUyxNQUFNLEVBQUVSLE9BQU8sRUFBRTtRQUN2QyxPQUFPLElBQUksQ0FBQ0osVUFBVSxDQUFDYyxVQUFVLENBQUNYLE9BQU9TLFFBQVFSO0lBQ25EO0lBRUE7O0dBRUMsR0FDRCxNQUFNVyxVQUFVWixLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUM5QixPQUFPLElBQUksQ0FBQ0osVUFBVSxDQUFDZSxTQUFTLENBQUNaLE9BQU9DO0lBQzFDO0lBRUE7O0dBRUMsR0FDRCxNQUFNWSxXQUFXYixLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUMvQixPQUFPLElBQUksQ0FBQ0osVUFBVSxDQUFDZ0IsVUFBVSxDQUFDYixPQUFPQztJQUMzQztJQUVBOztHQUVDLEdBQ0QsTUFBTWEsaUJBQWlCZCxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNyQyxPQUFPLElBQUksQ0FBQ0osVUFBVSxDQUFDaUIsZ0JBQWdCLENBQUNkLE9BQU9DO0lBQ2pEO0lBRUE7O0dBRUMsR0FDRCxNQUFNYyxpQkFBaUJmLEtBQUssRUFBRVMsTUFBTSxFQUFFUixPQUFPLEVBQUU7UUFDN0MsT0FBTyxJQUFJLENBQUNKLFVBQVUsQ0FBQ2tCLGdCQUFnQixDQUFDZixPQUFPUyxRQUFRUjtJQUN6RDtJQUVBOztHQUVDLEdBQ0RlLFdBQVdoQixLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUN6QixPQUFPLElBQUksQ0FBQ0osVUFBVSxDQUFDRSxJQUFJLENBQUNDLE9BQU9DO0lBQ3JDO0FBTUY7QUFHQTs7Q0FFQyxHQUVEZ0IsT0FBT0MsT0FBTyxHQUFHQSxVQUFVeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWF1dGgtcmVnaXN0ZXIvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL25vZGUuanM/NDMzNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2NvbGxlY3Rpb24nKTtcblxuY2xhc3MgTm9kZUNvbGxlY3Rpb24gZXh0ZW5kcyBDb2xsZWN0aW9uIHtcbiAgY29uc3RydWN0b3IoY29sKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuY29sbGVjdGlvbiA9IGNvbDtcbiAgICB0aGlzLmNvbGxlY3Rpb25OYW1lID0gY29sLmNvbGxlY3Rpb25OYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIGZpbmQobWF0Y2gsIG9wdGlvbnMpXG4gICAqL1xuICBhc3luYyBmaW5kKG1hdGNoLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY3Vyc29yID0gdGhpcy5jb2xsZWN0aW9uLmZpbmQobWF0Y2gsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIGN1cnNvci50b0FycmF5KCk7XG4gIH1cblxuICAvKipcbiAgICogZmluZE9uZShtYXRjaCwgb3B0aW9ucylcbiAgICovXG4gIGFzeW5jIGZpbmRPbmUobWF0Y2gsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLmZpbmRPbmUobWF0Y2gsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNvdW50KG1hdGNoLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgY291bnQobWF0Y2gsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLmNvdW50KG1hdGNoLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkaXN0aW5jdChwcm9wLCBtYXRjaCwgb3B0aW9ucylcbiAgICovXG4gIGFzeW5jIGRpc3RpbmN0KHByb3AsIG1hdGNoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5kaXN0aW5jdChwcm9wLCBtYXRjaCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogdXBkYXRlTWFueShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlTWFueShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi51cGRhdGVNYW55KG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIHVwZGF0ZU9uZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlT25lKG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLnVwZGF0ZU9uZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXBsYWNlT25lKG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpXG4gICAqL1xuICBhc3luYyByZXBsYWNlT25lKG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLnJlcGxhY2VPbmUobWF0Y2gsIHVwZGF0ZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogZGVsZXRlT25lKG1hdGNoLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlT25lKG1hdGNoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5kZWxldGVPbmUobWF0Y2gsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGRlbGV0ZU1hbnkobWF0Y2gsIG9wdGlvbnMpXG4gICAqL1xuICBhc3luYyBkZWxldGVNYW55KG1hdGNoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5kZWxldGVNYW55KG1hdGNoLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmaW5kT25lQW5kRGVsZXRlKG1hdGNoLCBvcHRpb25zLCBmdW5jdGlvbihlcnJbLCByZXN1bHRdKVxuICAgKi9cbiAgYXN5bmMgZmluZE9uZUFuZERlbGV0ZShtYXRjaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24uZmluZE9uZUFuZERlbGV0ZShtYXRjaCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogZmluZE9uZUFuZFVwZGF0ZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgZmluZE9uZUFuZFVwZGF0ZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5maW5kT25lQW5kVXBkYXRlKG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIHZhciBjdXJzb3IgPSBmaW5kQ3Vyc29yKG1hdGNoLCBvcHRpb25zKVxuICAgKi9cbiAgZmluZEN1cnNvcihtYXRjaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24uZmluZChtYXRjaCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogYWdncmVnYXRpb24ob3BlcmF0b3JzLi4uKVxuICAgKiBUT0RPXG4gICAqL1xufVxuXG5cbi8qKlxuICogRXhwb3NlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gTm9kZUNvbGxlY3Rpb247XG4iXSwibmFtZXMiOlsiQ29sbGVjdGlvbiIsInJlcXVpcmUiLCJOb2RlQ29sbGVjdGlvbiIsImNvbnN0cnVjdG9yIiwiY29sIiwiY29sbGVjdGlvbiIsImNvbGxlY3Rpb25OYW1lIiwiZmluZCIsIm1hdGNoIiwib3B0aW9ucyIsImN1cnNvciIsInRvQXJyYXkiLCJmaW5kT25lIiwiY291bnQiLCJkaXN0aW5jdCIsInByb3AiLCJ1cGRhdGVNYW55IiwidXBkYXRlIiwidXBkYXRlT25lIiwicmVwbGFjZU9uZSIsImRlbGV0ZU9uZSIsImRlbGV0ZU1hbnkiLCJmaW5kT25lQW5kRGVsZXRlIiwiZmluZE9uZUFuZFVwZGF0ZSIsImZpbmRDdXJzb3IiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/collection/node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mquery/lib/env.js":
/*!****************************************!*\
  !*** ./node_modules/mquery/lib/env.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nexports.isNode = \"undefined\" != typeof process && \"object\" == \"object\" && \"object\" == typeof global && \"function\" == typeof Buffer && process.argv;\nexports.isMongo = !exports.isNode && \"function\" == typeof printjson && \"function\" == typeof ObjectId && \"function\" == typeof rs && \"function\" == typeof sh;\nexports.isBrowser = !exports.isNode && !exports.isMongo && \"undefined\" != \"undefined\";\nexports.type = exports.isNode ? \"node\" : exports.isMongo ? \"mongo\" : exports.isBrowser ? \"browser\" : \"unknown\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9lbnYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsY0FBYyxHQUFHLGVBQWUsT0FBT0UsV0FDekIsWUFBWSxRQUFhQyxJQUN6QixZQUFZLE9BQU9DLFVBQ25CLGNBQWMsT0FBT0MsVUFDckJILFFBQVFJLElBQUk7QUFFMUJOLGVBQWUsR0FBRyxDQUFDQSxRQUFRQyxNQUFNLElBQ25CLGNBQWMsT0FBT08sYUFDckIsY0FBYyxPQUFPQyxZQUNyQixjQUFjLE9BQU9DLE1BQ3JCLGNBQWMsT0FBT0M7QUFFbkNYLGlCQUFpQixHQUFHLENBQUNBLFFBQVFDLE1BQU0sSUFDZixDQUFDRCxRQUFRTyxPQUFPLElBQ2hCLGVBQWU7QUFFbkNQLFlBQVksR0FBR0EsUUFBUUMsTUFBTSxHQUFHLFNBQzVCRCxRQUFRTyxPQUFPLEdBQUcsVUFDaEJQLFFBQVFZLFNBQVMsR0FBRyxZQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXV0aC1yZWdpc3Rlci8uL25vZGVfbW9kdWxlcy9tcXVlcnkvbGliL2Vudi5qcz8xZWU3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5pc05vZGUgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgcHJvY2Vzc1xuICAgICAgICAgICAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgbW9kdWxlXG4gICAgICAgICAgICYmICdvYmplY3QnID09IHR5cGVvZiBnbG9iYWxcbiAgICAgICAgICAgJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgQnVmZmVyXG4gICAgICAgICAgICYmIHByb2Nlc3MuYXJndjtcblxuZXhwb3J0cy5pc01vbmdvID0gIWV4cG9ydHMuaXNOb2RlXG4gICAgICAgICAgICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIHByaW50anNvblxuICAgICAgICAgICAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiBPYmplY3RJZFxuICAgICAgICAgICAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiByc1xuICAgICAgICAgICAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiBzaDtcblxuZXhwb3J0cy5pc0Jyb3dzZXIgPSAhZXhwb3J0cy5pc05vZGVcbiAgICAgICAgICAgICAgICAgJiYgIWV4cG9ydHMuaXNNb25nb1xuICAgICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2Ygd2luZG93O1xuXG5leHBvcnRzLnR5cGUgPSBleHBvcnRzLmlzTm9kZSA/ICdub2RlJ1xuICA6IGV4cG9ydHMuaXNNb25nbyA/ICdtb25nbydcbiAgICA6IGV4cG9ydHMuaXNCcm93c2VyID8gJ2Jyb3dzZXInXG4gICAgICA6ICd1bmtub3duJztcbiJdLCJuYW1lcyI6WyJleHBvcnRzIiwiaXNOb2RlIiwicHJvY2VzcyIsIm1vZHVsZSIsImdsb2JhbCIsIkJ1ZmZlciIsImFyZ3YiLCJpc01vbmdvIiwicHJpbnRqc29uIiwiT2JqZWN0SWQiLCJycyIsInNoIiwiaXNCcm93c2VyIiwidHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/env.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mquery/lib/mquery.js":
/*!*******************************************!*\
  !*** ./node_modules/mquery/lib/mquery.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n/**\n * Dependencies\n */ const assert = __webpack_require__(/*! assert */ \"assert\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mquery/lib/utils.js\");\nconst debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")(\"mquery\");\n/**\n * Query constructor used for building queries.\n *\n * #### Example:\n *\n *     var query = new Query({ name: 'mquery' });\n *     query.setOptions({ collection: moduleCollection })\n *     await query.where('age').gte(21).exec();\n *\n * @param {Object} [criteria] criteria for the query OR the collection instance to use\n * @param {Object} [options]\n * @api public\n */ function Query(criteria, options) {\n    if (!(this instanceof Query)) return new Query(criteria, options);\n    const proto = this.constructor.prototype;\n    this.op = proto.op || undefined;\n    this.options = Object.assign({}, proto.options);\n    this._conditions = proto._conditions ? utils.clone(proto._conditions) : {};\n    this._fields = proto._fields ? utils.clone(proto._fields) : undefined;\n    this._updateDoc = proto._updateDoc ? utils.clone(proto._updateDoc) : undefined;\n    this._path = proto._path || undefined;\n    this._distinctDoc = proto._distinctDoc || undefined;\n    this._collection = proto._collection || undefined;\n    this._traceFunction = proto._traceFunction || undefined;\n    if (options) {\n        this.setOptions(options);\n    }\n    if (criteria) {\n        this.find(criteria);\n    }\n}\n/**\n * This is a parameter that the user can set which determines if mquery\n * uses $within or $geoWithin for queries. It defaults to true which\n * means $geoWithin will be used. If using MongoDB < 2.4 you should\n * set this to false.\n *\n * @api public\n * @property use$geoWithin\n */ let $withinCmd = \"$geoWithin\";\nObject.defineProperty(Query, \"use$geoWithin\", {\n    get: function() {\n        return $withinCmd == \"$geoWithin\";\n    },\n    set: function(v) {\n        if (true === v) {\n            // mongodb >= 2.4\n            $withinCmd = \"$geoWithin\";\n        } else {\n            $withinCmd = \"$within\";\n        }\n    }\n});\n/**\n * Converts this query to a constructor function with all arguments and options retained.\n *\n * #### Example:\n *\n *     // Create a query that will read documents with a \"video\" category from\n *     // `aCollection` on the primary node in the replica-set unless it is down,\n *     // in which case we'll read from a secondary node.\n *     var query = mquery({ category: 'video' })\n *     query.setOptions({ collection: aCollection, read: 'primaryPreferred' });\n *\n *     // create a constructor based off these settings\n *     var Video = query.toConstructor();\n *\n *     // Video is now a subclass of mquery() and works the same way but with the\n *     // default query parameters and options set.\n *\n *     // run a query with the previous settings but filter for movies with names\n *     // that start with \"Life\".\n *     Video().where({ name: /^Life/ }).exec(cb);\n *\n * @return {Query} new Query\n * @api public\n */ Query.prototype.toConstructor = function toConstructor() {\n    function CustomQuery(criteria, options) {\n        if (!(this instanceof CustomQuery)) return new CustomQuery(criteria, options);\n        Query.call(this, criteria, options);\n    }\n    utils.inherits(CustomQuery, Query);\n    // set inherited defaults\n    const p = CustomQuery.prototype;\n    p.options = {};\n    p.setOptions(this.options);\n    p.op = this.op;\n    p._conditions = utils.clone(this._conditions);\n    p._fields = utils.clone(this._fields);\n    p._updateDoc = utils.clone(this._updateDoc);\n    p._path = this._path;\n    p._distinctDoc = this._distinctDoc;\n    p._collection = this._collection;\n    p._traceFunction = this._traceFunction;\n    return CustomQuery;\n};\n/**\n * Sets query options.\n *\n * #### Options:\n *\n * - [tailable](http://www.mongodb.org/display/DOCS/Tailable+Cursors) *\n * - [sort](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort(\\)%7D%7D) *\n * - [limit](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D) *\n * - [skip](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D) *\n * - [maxTime](http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS) *\n * - [batchSize](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D) *\n * - [comment](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment) *\n * - [hint](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint) *\n * - [slaveOk](http://docs.mongodb.org/manual/applications/replication/#read-preference) *\n * - [safe](http://www.mongodb.org/display/DOCS/getLastError+Command)\n * - collection the collection to query against\n *\n * _* denotes a query helper method is also available_\n *\n * @param {Object} options\n * @api public\n */ Query.prototype.setOptions = function(options) {\n    if (!(options && utils.isObject(options))) return this;\n    // set arbitrary options\n    const methods = utils.keys(options);\n    let method;\n    for(let i = 0; i < methods.length; ++i){\n        method = methods[i];\n        // use methods if exist (safer option manipulation)\n        if (\"function\" == typeof this[method]) {\n            const args = Array.isArray(options[method]) ? options[method] : [\n                options[method]\n            ];\n            this[method].apply(this, args);\n        } else {\n            this.options[method] = options[method];\n        }\n    }\n    return this;\n};\n/**\n * Sets this Querys collection.\n *\n * @param {Collection} coll\n * @return {Query} this\n */ Query.prototype.collection = function collection(coll) {\n    this._collection = new Query.Collection(coll);\n    return this;\n};\n/**\n * Adds a collation to this op (MongoDB 3.4 and up)\n *\n * #### Example:\n *\n *     query.find().collation({ locale: \"en_US\", strength: 1 })\n *\n * @param {Object} value\n * @return {Query} this\n * @see MongoDB docs https://docs.mongodb.com/manual/reference/method/cursor.collation/#cursor.collation\n * @api public\n */ Query.prototype.collation = function(value) {\n    this.options.collation = value;\n    return this;\n};\n/**\n * Specifies a `$where` condition\n *\n * Use `$where` when you need to select documents using a JavaScript expression.\n *\n * #### Example:\n *\n *     query.$where('this.comments.length > 10 || this.name.length > 5')\n *\n *     query.$where(function () {\n *       return this.comments.length > 10 || this.name.length > 5;\n *     })\n *\n * @param {String|Function} js javascript string or function\n * @return {Query} this\n * @memberOf Query\n * @method $where\n * @api public\n */ Query.prototype.$where = function(js) {\n    this._conditions.$where = js;\n    return this;\n};\n/**\n * Specifies a `path` for use with chaining.\n *\n * #### Example:\n *\n *     // instead of writing:\n *     await User.find({age: {$gte: 21, $lte: 65}});\n *\n *     // we can instead write:\n *     User.where('age').gte(21).lte(65);\n *\n *     // passing query conditions is permitted\n *     User.find().where({ name: 'vonderful' })\n *\n *     // chaining\n *     await User\n *       .where('age').gte(21).lte(65)\n *       .where('name', /^vonderful/i)\n *       .where('friends').slice(10)\n *       .exec()\n *\n * @param {String} [path]\n * @param {Object} [val]\n * @return {Query} this\n * @api public\n */ Query.prototype.where = function() {\n    if (!arguments.length) return this;\n    if (!this.op) this.op = \"find\";\n    const type = typeof arguments[0];\n    if (\"string\" == type) {\n        this._path = arguments[0];\n        if (2 === arguments.length) {\n            this._conditions[this._path] = arguments[1];\n        }\n        return this;\n    }\n    if (\"object\" == type && !Array.isArray(arguments[0])) {\n        return this.merge(arguments[0]);\n    }\n    throw new TypeError(\"path must be a string or object\");\n};\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n *\n * #### Example:\n *\n *     User.where('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @param {Object} val\n * @return {Query} this\n * @api public\n */ Query.prototype.equals = function equals(val) {\n    this._ensurePath(\"equals\");\n    const path = this._path;\n    this._conditions[path] = val;\n    return this;\n};\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n * This is alias of `equals`\n *\n * #### Example:\n *\n *     User.where('age').eq(49);\n *\n *     // is the same as\n *\n *     User.shere('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @param {Object} val\n * @return {Query} this\n * @api public\n */ Query.prototype.eq = function eq(val) {\n    this._ensurePath(\"eq\");\n    const path = this._path;\n    this._conditions[path] = val;\n    return this;\n};\n/**\n * Specifies arguments for an `$or` condition.\n *\n * #### Example:\n *\n *     query.or([{ color: 'red' }, { status: 'emergency' }])\n *\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */ Query.prototype.or = function or(array) {\n    const or = this._conditions.$or || (this._conditions.$or = []);\n    if (!Array.isArray(array)) array = [\n        array\n    ];\n    or.push.apply(or, array);\n    return this;\n};\n/**\n * Specifies arguments for a `$nor` condition.\n *\n * #### Example:\n *\n *     query.nor([{ color: 'green' }, { status: 'ok' }])\n *\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */ Query.prototype.nor = function nor(array) {\n    const nor = this._conditions.$nor || (this._conditions.$nor = []);\n    if (!Array.isArray(array)) array = [\n        array\n    ];\n    nor.push.apply(nor, array);\n    return this;\n};\n/**\n * Specifies arguments for a `$and` condition.\n *\n * #### Example:\n *\n *     query.and([{ color: 'green' }, { status: 'ok' }])\n *\n * @see $and http://docs.mongodb.org/manual/reference/operator/and/\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */ Query.prototype.and = function and(array) {\n    const and = this._conditions.$and || (this._conditions.$and = []);\n    if (!Array.isArray(array)) array = [\n        array\n    ];\n    and.push.apply(and, array);\n    return this;\n};\n/**\n * Specifies a $gt query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * #### Example:\n *\n *     Thing.find().where('age').gt(21)\n *\n *     // or\n *     Thing.find().gt('age', 21)\n *\n * @method gt\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies a $gte query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method gte\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies a $lt query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lt\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies a $lte query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lte\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies a $ne query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method ne\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies an $in query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method in\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies an $nin query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method nin\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies an $all query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method all\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies a $size query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method size\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies a $regex query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method regex\n * @memberOf Query\n * @param {String} [path]\n * @param {String|RegExp} val\n * @api public\n */ /**\n * Specifies a $maxDistance query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method maxDistance\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /*!\n * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance\n *\n *     Thing.where('type').nin(array)\n */ \"gt gte lt lte ne in nin all regex size maxDistance minDistance\".split(\" \").forEach(function($conditional) {\n    Query.prototype[$conditional] = function() {\n        let path, val;\n        if (1 === arguments.length) {\n            this._ensurePath($conditional);\n            val = arguments[0];\n            path = this._path;\n        } else {\n            val = arguments[1];\n            path = arguments[0];\n        }\n        const conds = this._conditions[path] === null || typeof this._conditions[path] === \"object\" ? this._conditions[path] : this._conditions[path] = {};\n        conds[\"$\" + $conditional] = val;\n        return this;\n    };\n});\n/**\n * Specifies a `$mod` condition\n *\n * @param {String} [path]\n * @param {Number} val\n * @return {Query} this\n * @api public\n */ Query.prototype.mod = function() {\n    let val, path;\n    if (1 === arguments.length) {\n        this._ensurePath(\"mod\");\n        val = arguments[0];\n        path = this._path;\n    } else if (2 === arguments.length && !Array.isArray(arguments[1])) {\n        this._ensurePath(\"mod\");\n        val = [\n            arguments[0],\n            arguments[1]\n        ];\n        path = this._path;\n    } else if (3 === arguments.length) {\n        val = [\n            arguments[1],\n            arguments[2]\n        ];\n        path = arguments[0];\n    } else {\n        val = arguments[1];\n        path = arguments[0];\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    conds.$mod = val;\n    return this;\n};\n/**\n * Specifies an `$exists` condition\n *\n * #### Example:\n *\n *     // { name: { $exists: true }}\n *     Thing.where('name').exists()\n *     Thing.where('name').exists(true)\n *     Thing.find().exists('name')\n *\n *     // { name: { $exists: false }}\n *     Thing.where('name').exists(false);\n *     Thing.find().exists('name', false);\n *\n * @param {String} [path]\n * @param {Number} val\n * @return {Query} this\n * @api public\n */ Query.prototype.exists = function() {\n    let path, val;\n    if (0 === arguments.length) {\n        this._ensurePath(\"exists\");\n        path = this._path;\n        val = true;\n    } else if (1 === arguments.length) {\n        if (\"boolean\" === typeof arguments[0]) {\n            this._ensurePath(\"exists\");\n            path = this._path;\n            val = arguments[0];\n        } else {\n            path = arguments[0];\n            val = true;\n        }\n    } else if (2 === arguments.length) {\n        path = arguments[0];\n        val = arguments[1];\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    conds.$exists = val;\n    return this;\n};\n/**\n * Specifies an `$elemMatch` condition\n *\n * #### Example:\n *\n *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})\n *\n *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})\n *\n *     query.elemMatch('comment', function (elem) {\n *       elem.where('author').equals('autobot');\n *       elem.where('votes').gte(5);\n *     })\n *\n *     query.where('comment').elemMatch(function (elem) {\n *       elem.where({ author: 'autobot' });\n *       elem.where('votes').gte(5);\n *     })\n *\n * @param {String|Object|Function} path\n * @param {Object|Function} criteria\n * @return {Query} this\n * @api public\n */ Query.prototype.elemMatch = function() {\n    if (null == arguments[0]) throw new TypeError(\"Invalid argument\");\n    let fn, path, criteria;\n    if (\"function\" === typeof arguments[0]) {\n        this._ensurePath(\"elemMatch\");\n        path = this._path;\n        fn = arguments[0];\n    } else if (utils.isObject(arguments[0])) {\n        this._ensurePath(\"elemMatch\");\n        path = this._path;\n        criteria = arguments[0];\n    } else if (\"function\" === typeof arguments[1]) {\n        path = arguments[0];\n        fn = arguments[1];\n    } else if (arguments[1] && utils.isObject(arguments[1])) {\n        path = arguments[0];\n        criteria = arguments[1];\n    } else {\n        throw new TypeError(\"Invalid argument\");\n    }\n    if (fn) {\n        criteria = new Query;\n        fn(criteria);\n        criteria = criteria._conditions;\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    conds.$elemMatch = criteria;\n    return this;\n};\n// Spatial queries\n/**\n * Sugar for geo-spatial queries.\n *\n * #### Example:\n *\n *     query.within().box()\n *     query.within().circle()\n *     query.within().geometry()\n *\n *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });\n *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });\n *     query.where('loc').within({ polygon: [[],[],[],[]] });\n *\n *     query.where('loc').within([], [], []) // polygon\n *     query.where('loc').within([], []) // box\n *     query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry\n *\n * #### Note:\n *\n * Must be used after `where()`.\n *\n * @memberOf Query\n * @return {Query} this\n * @api public\n */ Query.prototype.within = function within() {\n    // opinionated, must be used after where\n    this._ensurePath(\"within\");\n    this._geoComparison = $withinCmd;\n    if (0 === arguments.length) {\n        return this;\n    }\n    if (2 === arguments.length) {\n        return this.box.apply(this, arguments);\n    } else if (2 < arguments.length) {\n        return this.polygon.apply(this, arguments);\n    }\n    const area = arguments[0];\n    if (!area) throw new TypeError(\"Invalid argument\");\n    if (area.center) return this.circle(area);\n    if (area.box) return this.box.apply(this, area.box);\n    if (area.polygon) return this.polygon.apply(this, area.polygon);\n    if (area.type && area.coordinates) return this.geometry(area);\n    throw new TypeError(\"Invalid argument\");\n};\n/**\n * Specifies a $box condition\n *\n * #### Example:\n *\n *     var lowerLeft = [40.73083, -73.99756]\n *     var upperRight= [40.741404,  -73.988135]\n *\n *     query.where('loc').within().box(lowerLeft, upperRight)\n *     query.box('loc', lowerLeft, upperRight )\n *\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @see Query#within #query_Query-within\n * @param {String} path\n * @param {Object} val\n * @return {Query} this\n * @api public\n */ Query.prototype.box = function() {\n    let path, box;\n    if (3 === arguments.length) {\n        // box('loc', [], [])\n        path = arguments[0];\n        box = [\n            arguments[1],\n            arguments[2]\n        ];\n    } else if (2 === arguments.length) {\n        // box([], [])\n        this._ensurePath(\"box\");\n        path = this._path;\n        box = [\n            arguments[0],\n            arguments[1]\n        ];\n    } else {\n        throw new TypeError(\"Invalid argument\");\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    conds[this._geoComparison || $withinCmd] = {\n        $box: box\n    };\n    return this;\n};\n/**\n * Specifies a $polygon condition\n *\n * #### Example:\n *\n *     query.where('loc').within().polygon([10,20], [13, 25], [7,15])\n *     query.polygon('loc', [10,20], [13, 25], [7,15])\n *\n * @param {String|Array} [path]\n * @param {Array|Object} [val]\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */ Query.prototype.polygon = function() {\n    let val, path;\n    if (\"string\" == typeof arguments[0]) {\n        // polygon('loc', [],[],[])\n        val = Array.from(arguments);\n        path = val.shift();\n    } else {\n        // polygon([],[],[])\n        this._ensurePath(\"polygon\");\n        path = this._path;\n        val = Array.from(arguments);\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    conds[this._geoComparison || $withinCmd] = {\n        $polygon: val\n    };\n    return this;\n};\n/**\n * Specifies a $center or $centerSphere condition.\n *\n * #### Example:\n *\n *     var area = { center: [50, 50], radius: 10, unique: true }\n *     query.where('loc').within().circle(area)\n *     query.center('loc', area);\n *\n *     // for spherical calculations\n *     var area = { center: [50, 50], radius: 10, unique: true, spherical: true }\n *     query.where('loc').within().circle(area)\n *     query.center('loc', area);\n *\n * @param {String} [path]\n * @param {Object} area\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */ Query.prototype.circle = function() {\n    let path, val;\n    if (1 === arguments.length) {\n        this._ensurePath(\"circle\");\n        path = this._path;\n        val = arguments[0];\n    } else if (2 === arguments.length) {\n        path = arguments[0];\n        val = arguments[1];\n    } else {\n        throw new TypeError(\"Invalid argument\");\n    }\n    if (!(\"radius\" in val && val.center)) throw new Error(\"center and radius are required\");\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    const type = val.spherical ? \"$centerSphere\" : \"$center\";\n    const wKey = this._geoComparison || $withinCmd;\n    conds[wKey] = {};\n    conds[wKey][type] = [\n        val.center,\n        val.radius\n    ];\n    if (\"unique\" in val) conds[wKey].$uniqueDocs = !!val.unique;\n    return this;\n};\n/**\n * Specifies a `$near` or `$nearSphere` condition\n *\n * These operators return documents sorted by distance.\n *\n * #### Example:\n *\n *     query.where('loc').near({ center: [10, 10] });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });\n *     query.near('loc', { center: [10, 10], maxDistance: 5 });\n *     query.near({ center: { type: 'Point', coordinates: [..] }})\n *     query.near().geometry({ type: 'Point', coordinates: [..] })\n *\n * @param {String} [path]\n * @param {Object} val\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */ Query.prototype.near = function near() {\n    let path, val;\n    this._geoComparison = \"$near\";\n    if (0 === arguments.length) {\n        return this;\n    } else if (1 === arguments.length) {\n        this._ensurePath(\"near\");\n        path = this._path;\n        val = arguments[0];\n    } else if (2 === arguments.length) {\n        path = arguments[0];\n        val = arguments[1];\n    } else {\n        throw new TypeError(\"Invalid argument\");\n    }\n    if (!val.center) {\n        throw new Error(\"center is required\");\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    const type = val.spherical ? \"$nearSphere\" : \"$near\";\n    // center could be a GeoJSON object or an Array\n    if (Array.isArray(val.center)) {\n        conds[type] = val.center;\n        const radius = \"maxDistance\" in val ? val.maxDistance : null;\n        if (null != radius) {\n            conds.$maxDistance = radius;\n        }\n        if (null != val.minDistance) {\n            conds.$minDistance = val.minDistance;\n        }\n    } else {\n        // GeoJSON?\n        if (val.center.type != \"Point\" || !Array.isArray(val.center.coordinates)) {\n            throw new Error(util.format(\"Invalid GeoJSON specified for %s\", type));\n        }\n        conds[type] = {\n            $geometry: val.center\n        };\n        // MongoDB 2.6 insists on maxDistance being in $near / $nearSphere\n        if (\"maxDistance\" in val) {\n            conds[type][\"$maxDistance\"] = val.maxDistance;\n        }\n        if (\"minDistance\" in val) {\n            conds[type][\"$minDistance\"] = val.minDistance;\n        }\n    }\n    return this;\n};\n/**\n * Declares an intersects query for `geometry()`.\n *\n * #### Example:\n *\n *     query.where('path').intersects().geometry({\n *         type: 'LineString'\n *       , coordinates: [[180.0, 11.0], [180, 9.0]]\n *     })\n *\n *     query.where('path').intersects({\n *         type: 'LineString'\n *       , coordinates: [[180.0, 11.0], [180, 9.0]]\n *     })\n *\n * @param {Object} [arg]\n * @return {Query} this\n * @api public\n */ Query.prototype.intersects = function intersects() {\n    // opinionated, must be used after where\n    this._ensurePath(\"intersects\");\n    this._geoComparison = \"$geoIntersects\";\n    if (0 === arguments.length) {\n        return this;\n    }\n    const area = arguments[0];\n    if (null != area && area.type && area.coordinates) return this.geometry(area);\n    throw new TypeError(\"Invalid argument\");\n};\n/**\n * Specifies a `$geometry` condition\n *\n * #### Example:\n *\n *     var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]\n *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })\n *\n *     // or\n *     var polyB = [[ 0, 0 ], [ 1, 1 ]]\n *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })\n *\n *     // or\n *     var polyC = [ 0, 0 ]\n *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })\n *\n *     // or\n *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })\n *\n * #### Note:\n *\n * `geometry()` **must** come after either `intersects()` or `within()`.\n *\n * The `object` argument must contain `type` and `coordinates` properties.\n * - type {String}\n * - coordinates {Array}\n *\n * The most recent path passed to `where()` is used.\n *\n * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.\n * @return {Query} this\n * @see http://docs.mongodb.org/manual/release-notes/2.4/#new-geospatial-indexes-with-geojson-and-improved-spherical-geometry\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/\n * @api public\n */ Query.prototype.geometry = function geometry() {\n    if (!(\"$within\" == this._geoComparison || \"$geoWithin\" == this._geoComparison || \"$near\" == this._geoComparison || \"$geoIntersects\" == this._geoComparison)) {\n        throw new Error(\"geometry() must come after `within()`, `intersects()`, or `near()\");\n    }\n    let val, path;\n    if (1 === arguments.length) {\n        this._ensurePath(\"geometry\");\n        path = this._path;\n        val = arguments[0];\n    } else {\n        throw new TypeError(\"Invalid argument\");\n    }\n    if (!(val.type && Array.isArray(val.coordinates))) {\n        throw new TypeError(\"Invalid argument\");\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    conds[this._geoComparison] = {\n        $geometry: val\n    };\n    return this;\n};\n// end spatial\n/**\n * Specifies which document fields to include or exclude\n *\n * #### String syntax\n *\n * When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.\n *\n * #### Example:\n *\n *     // include a and b, exclude c\n *     query.select('a b -c');\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     query.select({a: 1, b: 1, c: 0});\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Object|String} arg\n * @return {Query} this\n * @see SchemaType\n * @api public\n */ Query.prototype.select = function select() {\n    let arg = arguments[0];\n    if (!arg) return this;\n    if (arguments.length !== 1) {\n        throw new Error(\"Invalid select: select only takes 1 argument\");\n    }\n    this._validate(\"select\");\n    const fields = this._fields || (this._fields = {});\n    const type = typeof arg;\n    let i, len;\n    if ((\"string\" == type || utils.isArgumentsObject(arg)) && \"number\" == typeof arg.length || Array.isArray(arg)) {\n        if (\"string\" == type) arg = arg.split(/\\s+/);\n        for(i = 0, len = arg.length; i < len; ++i){\n            let field = arg[i];\n            if (!field) continue;\n            const include = \"-\" == field[0] ? 0 : 1;\n            if (include === 0) field = field.substring(1);\n            fields[field] = include;\n        }\n        return this;\n    }\n    if (utils.isObject(arg)) {\n        const keys = utils.keys(arg);\n        for(i = 0; i < keys.length; ++i){\n            fields[keys[i]] = arg[keys[i]];\n        }\n        return this;\n    }\n    throw new TypeError(\"Invalid select() argument. Must be string or object.\");\n};\n/**\n * Specifies a $slice condition for a `path`\n *\n * #### Example:\n *\n *     query.slice('comments', 5)\n *     query.slice('comments', -5)\n *     query.slice('comments', [10, 5])\n *     query.where('comments').slice(5)\n *     query.where('comments').slice([-10, 5])\n *\n * @param {String} [path]\n * @param {Number} val number/range of elements to slice\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields#RetrievingaSubsetofFields-RetrievingaSubrangeofArrayElements\n * @api public\n */ Query.prototype.slice = function() {\n    if (0 === arguments.length) return this;\n    this._validate(\"slice\");\n    let path, val;\n    if (1 === arguments.length) {\n        const arg = arguments[0];\n        if (typeof arg === \"object\" && !Array.isArray(arg)) {\n            const keys = Object.keys(arg);\n            const numKeys = keys.length;\n            for(let i = 0; i < numKeys; ++i){\n                this.slice(keys[i], arg[keys[i]]);\n            }\n            return this;\n        }\n        this._ensurePath(\"slice\");\n        path = this._path;\n        val = arguments[0];\n    } else if (2 === arguments.length) {\n        if (\"number\" === typeof arguments[0]) {\n            this._ensurePath(\"slice\");\n            path = this._path;\n            val = [\n                arguments[0],\n                arguments[1]\n            ];\n        } else {\n            path = arguments[0];\n            val = arguments[1];\n        }\n    } else if (3 === arguments.length) {\n        path = arguments[0];\n        val = [\n            arguments[1],\n            arguments[2]\n        ];\n    }\n    const myFields = this._fields || (this._fields = {});\n    myFields[path] = {\n        $slice: val\n    };\n    return this;\n};\n/**\n * Sets the sort order\n *\n * If an object is passed, values allowed are 'asc', 'desc', 'ascending', 'descending', 1, and -1.\n *\n * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n *\n * #### Example:\n *\n *     // these are equivalent\n *     query.sort({ field: 'asc', test: -1 });\n *     query.sort('field -test');\n *     query.sort([['field', 1], ['test', -1]]);\n *\n * #### Note:\n *\n *  - The array syntax `.sort([['field', 1], ['test', -1]])` can only be used with [mongodb driver >= 2.0.46](https://github.com/mongodb/node-mongodb-native/blob/2.1/HISTORY.md#2046-2015-10-15).\n *  - Cannot be used with `distinct()`\n *\n * @param {Object|String|Array} arg\n * @return {Query} this\n * @api public\n */ Query.prototype.sort = function(arg) {\n    if (!arg) return this;\n    let i, len, field;\n    this._validate(\"sort\");\n    const type = typeof arg;\n    // .sort([['field', 1], ['test', -1]])\n    if (Array.isArray(arg)) {\n        len = arg.length;\n        for(i = 0; i < arg.length; ++i){\n            if (!Array.isArray(arg[i])) {\n                throw new Error(\"Invalid sort() argument, must be array of arrays\");\n            }\n            _pushArr(this.options, arg[i][0], arg[i][1]);\n        }\n        return this;\n    }\n    // .sort('field -test')\n    if (1 === arguments.length && \"string\" == type) {\n        arg = arg.split(/\\s+/);\n        len = arg.length;\n        for(i = 0; i < len; ++i){\n            field = arg[i];\n            if (!field) continue;\n            const ascend = \"-\" == field[0] ? -1 : 1;\n            if (ascend === -1) field = field.substring(1);\n            push(this.options, field, ascend);\n        }\n        return this;\n    }\n    // .sort({ field: 1, test: -1 })\n    if (utils.isObject(arg)) {\n        const keys = utils.keys(arg);\n        for(i = 0; i < keys.length; ++i){\n            field = keys[i];\n            push(this.options, field, arg[field]);\n        }\n        return this;\n    }\n    if (typeof Map !== \"undefined\" && arg instanceof Map) {\n        _pushMap(this.options, arg);\n        return this;\n    }\n    throw new TypeError(\"Invalid sort() argument. Must be a string, object, or array.\");\n};\n/*!\n * @ignore\n */ const _validSortValue = {\n    1: 1,\n    \"-1\": -1,\n    asc: 1,\n    ascending: 1,\n    desc: -1,\n    descending: -1\n};\nfunction push(opts, field, value) {\n    if (Array.isArray(opts.sort)) {\n        throw new TypeError(\"Can't mix sort syntaxes. Use either array or object:\" + \"\\n- `.sort([['field', 1], ['test', -1]])`\" + \"\\n- `.sort({ field: 1, test: -1 })`\");\n    }\n    let s;\n    if (value && value.$meta) {\n        s = opts.sort || (opts.sort = {});\n        s[field] = {\n            $meta: value.$meta\n        };\n        return;\n    }\n    s = opts.sort || (opts.sort = {});\n    let val = String(value || 1).toLowerCase();\n    val = _validSortValue[val];\n    if (!val) throw new TypeError(\"Invalid sort value: { \" + field + \": \" + value + \" }\");\n    s[field] = val;\n}\nfunction _pushArr(opts, field, value) {\n    opts.sort = opts.sort || [];\n    if (!Array.isArray(opts.sort)) {\n        throw new TypeError(\"Can't mix sort syntaxes. Use either array or object:\" + \"\\n- `.sort([['field', 1], ['test', -1]])`\" + \"\\n- `.sort({ field: 1, test: -1 })`\");\n    }\n    let val = String(value || 1).toLowerCase();\n    val = _validSortValue[val];\n    if (!val) throw new TypeError(\"Invalid sort value: [ \" + field + \", \" + value + \" ]\");\n    opts.sort.push([\n        field,\n        val\n    ]);\n}\nfunction _pushMap(opts, map) {\n    opts.sort = opts.sort || new Map();\n    if (!(opts.sort instanceof Map)) {\n        throw new TypeError(\"Can't mix sort syntaxes. Use either array or \" + \"object or map consistently\");\n    }\n    map.forEach(function(value, key) {\n        let val = String(value || 1).toLowerCase();\n        val = _validSortValue[val];\n        if (!val) throw new TypeError(\"Invalid sort value: < \" + key + \": \" + value + \" >\");\n        opts.sort.set(key, val);\n    });\n}\n/**\n * Specifies the limit option.\n *\n * #### Example:\n *\n *     query.limit(20)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method limit\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D\n * @api public\n */ /**\n * Specifies the skip option.\n *\n * #### Example:\n *\n *     query.skip(100).limit(20)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method skip\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D\n * @api public\n */ /**\n * Specifies the batchSize option.\n *\n * #### Example:\n *\n *     query.batchSize(100)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method batchSize\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D\n * @api public\n */ /**\n * Specifies the `comment` option.\n *\n * #### Example:\n *\n *     query.comment('login query')\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method comment\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment\n * @api public\n */ /*!\n * limit, skip, batchSize, comment\n *\n * Sets these associated options.\n *\n *     query.comment('feed query');\n */ [\n    \"limit\",\n    \"skip\",\n    \"batchSize\",\n    \"comment\"\n].forEach(function(method) {\n    Query.prototype[method] = function(v) {\n        this._validate(method);\n        this.options[method] = v;\n        return this;\n    };\n});\n/**\n * Specifies the maxTimeMS option.\n *\n * #### Example:\n *\n *     query.maxTime(100)\n *     query.maxTimeMS(100)\n *\n * @method maxTime\n * @memberOf Query\n * @param {Number} ms\n * @see mongodb http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS\n * @api public\n */ Query.prototype.maxTime = Query.prototype.maxTimeMS = function(ms) {\n    this._validate(\"maxTime\");\n    this.options.maxTimeMS = ms;\n    return this;\n};\n/**\n * Sets query hints.\n *\n * #### Example:\n *\n *     query.hint({ indexA: 1, indexB: -1});\n *     query.hint('indexA_1_indexB_1');\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Object|string} val a hint object or the index name\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint\n * @api public\n */ Query.prototype.hint = function() {\n    if (0 === arguments.length) return this;\n    this._validate(\"hint\");\n    const arg = arguments[0];\n    if (utils.isObject(arg)) {\n        const hint = this.options.hint || (this.options.hint = {});\n        // must keep object keys in order so don't use Object.keys()\n        for(const k in arg){\n            hint[k] = arg[k];\n        }\n        return this;\n    }\n    if (typeof arg === \"string\") {\n        this.options.hint = arg;\n        return this;\n    }\n    throw new TypeError(\"Invalid hint. \" + arg);\n};\n/**\n * Requests acknowledgement that this operation has been persisted to MongoDB's\n * on-disk journal.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the `j` value if it is specified in writeConcern options\n *\n * #### Example:\n *\n *     mquery().w(2).j(true).wtimeout(2000);\n *\n * @method j\n * @memberOf Query\n * @instance\n * @param {boolean} val\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#j-option\n * @return {Query} this\n * @api public\n */ Query.prototype.j = function j(val) {\n    this.options.j = val;\n    return this;\n};\n/**\n * Sets the slaveOk option. _Deprecated_ in MongoDB 2.2 in favor of read preferences.\n *\n * #### Example:\n *\n *     query.slaveOk() // true\n *     query.slaveOk(true)\n *     query.slaveOk(false)\n *\n * @deprecated use read() preferences instead if on mongodb >= 2.2\n * @param {Boolean} v defaults to true\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see read()\n * @return {Query} this\n * @api public\n */ Query.prototype.slaveOk = function(v) {\n    this.options.slaveOk = arguments.length ? !!v : true;\n    return this;\n};\n/**\n * Sets the readPreference option for the query.\n *\n * #### Example:\n *\n *     new Query().read('primary')\n *     new Query().read('p')  // same as primary\n *\n *     new Query().read('primaryPreferred')\n *     new Query().read('pp') // same as primaryPreferred\n *\n *     new Query().read('secondary')\n *     new Query().read('s')  // same as secondary\n *\n *     new Query().read('secondaryPreferred')\n *     new Query().read('sp') // same as secondaryPreferred\n *\n *     new Query().read('nearest')\n *     new Query().read('n')  // same as nearest\n *\n *     // you can also use mongodb.ReadPreference class to also specify tags\n *     new Query().read(mongodb.ReadPreference('secondary', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }]))\n *\n *     new Query().setReadPreference('primary') // alias of .read()\n *\n * #### Preferences:\n *\n *     primary - (default)  Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.\n *     secondary            Read from secondary if available, otherwise error.\n *     primaryPreferred     Read from primary if available, otherwise a secondary.\n *     secondaryPreferred   Read from a secondary if available, otherwise read from the primary.\n *     nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.\n *\n * Aliases\n *\n *     p   primary\n *     pp  primaryPreferred\n *     s   secondary\n *     sp  secondaryPreferred\n *     n   nearest\n *\n * Read more about how to use read preferences [here](http://docs.mongodb.org/manual/applications/replication/#read-preference) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).\n *\n * @param {String|ReadPreference} pref one of the listed preference options or their aliases\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences\n * @return {Query} this\n * @api public\n */ Query.prototype.read = Query.prototype.setReadPreference = function(pref) {\n    if (arguments.length > 1 && !Query.prototype.read.deprecationWarningIssued) {\n        console.error(\"Deprecation warning: 'tags' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead.\");\n        Query.prototype.read.deprecationWarningIssued = true;\n    }\n    this.options.readPreference = utils.readPref(pref);\n    return this;\n};\n/**\n * Sets the readConcern option for the query.\n *\n * #### Example:\n *\n *     new Query().readConcern('local')\n *     new Query().readConcern('l')  // same as local\n *\n *     new Query().readConcern('available')\n *     new Query().readConcern('a')  // same as available\n *\n *     new Query().readConcern('majority')\n *     new Query().readConcern('m')  // same as majority\n *\n *     new Query().readConcern('linearizable')\n *     new Query().readConcern('lz') // same as linearizable\n *\n *     new Query().readConcern('snapshot')\n *     new Query().readConcern('s')  // same as snapshot\n *\n *     new Query().r('s') // r is alias of readConcern\n *\n *\n * #### Read Concern Level:\n *\n *     local         MongoDB 3.2+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n *     available     MongoDB 3.6+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n *     majority      MongoDB 3.2+ The query returns the data that has been acknowledged by a majority of the replica set members. The documents returned by the read operation are durable, even in the event of failure.\n *     linearizable  MongoDB 3.4+ The query returns data that reflects all successful majority-acknowledged writes that completed prior to the start of the read operation. The query may wait for concurrently executing writes to propagate to a majority of replica set members before returning results.\n *     snapshot      MongoDB 4.0+ Only available for operations within multi-document transactions. Upon transaction commit with write concern \"majority\", the transaction operations are guaranteed to have read from a snapshot of majority-committed data.\n *\n * Aliases\n *\n *     l   local\n *     a   available\n *     m   majority\n *     lz  linearizable\n *     s   snapshot\n *\n * Read more about how to use read concern [here](https://docs.mongodb.com/manual/reference/read-concern/).\n *\n * @param {String} level one of the listed read concern level or their aliases\n * @see mongodb https://docs.mongodb.com/manual/reference/read-concern/\n * @return {Query} this\n * @api public\n */ Query.prototype.readConcern = Query.prototype.r = function(level) {\n    this.options.readConcern = utils.readConcern(level);\n    return this;\n};\n/**\n * Sets tailable option.\n *\n * #### Example:\n *\n *     query.tailable() <== true\n *     query.tailable(true)\n *     query.tailable(false)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Boolean} v defaults to true\n * @see mongodb http://www.mongodb.org/display/DOCS/Tailable+Cursors\n * @api public\n */ Query.prototype.tailable = function() {\n    this._validate(\"tailable\");\n    this.options.tailable = arguments.length ? !!arguments[0] : true;\n    return this;\n};\n/**\n * Sets the specified number of `mongod` servers, or tag set of `mongod` servers,\n * that must acknowledge this write before this write is considered successful.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the `w` value if it is specified in writeConcern options\n *\n * #### Example:\n *\n *     mquery().writeConcern(0)\n *     mquery().writeConcern(1)\n *     mquery().writeConcern({ w: 1, j: true, wtimeout: 2000 })\n *     mquery().writeConcern('majority')\n *     mquery().writeConcern('m') // same as majority\n *     mquery().writeConcern('tagSetName') // if the tag set is 'm', use .writeConcern({ w: 'm' }) instead\n *     mquery().w(1) // w is alias of writeConcern\n *\n * @method writeConcern\n * @memberOf Query\n * @instance\n * @param {String|number|object} concern 0 for fire-and-forget, 1 for acknowledged by one server, 'majority' for majority of the replica set, or [any of the more advanced options](https://docs.mongodb.com/manual/reference/write-concern/#w-option).\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#w-option\n * @return {Query} this\n * @api public\n */ Query.prototype.writeConcern = Query.prototype.w = function writeConcern(concern) {\n    if (\"object\" === typeof concern) {\n        if (\"undefined\" !== typeof concern.j) this.options.j = concern.j;\n        if (\"undefined\" !== typeof concern.w) this.options.w = concern.w;\n        if (\"undefined\" !== typeof concern.wtimeout) this.options.wtimeout = concern.wtimeout;\n    } else {\n        this.options.w = \"m\" === concern ? \"majority\" : concern;\n    }\n    return this;\n};\n/**\n * Specifies a time limit, in milliseconds, for the write concern.\n * If `ms > 1`, it is maximum amount of time to wait for this write\n * to propagate through the replica set before this operation fails.\n * The default is `0`, which means no timeout.\n *\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to `wtimeout` value if it is specified in writeConcern\n *\n * #### Example:\n *\n *     mquery().w(2).j(true).wtimeout(2000)\n *\n * @method wtimeout\n * @memberOf Query\n * @instance\n * @param {number} ms number of milliseconds to wait\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#wtimeout\n * @return {Query} this\n * @api public\n */ Query.prototype.wtimeout = Query.prototype.wTimeout = function wtimeout(ms) {\n    this.options.wtimeout = ms;\n    return this;\n};\n/**\n * Merges another Query or conditions object into this one.\n *\n * When a Query is passed, conditions, field selection and options are merged.\n *\n * @param {Query|Object} source\n * @return {Query} this\n */ Query.prototype.merge = function(source) {\n    if (!source) return this;\n    if (!Query.canMerge(source)) throw new TypeError(\"Invalid argument. Expected instanceof mquery or plain object\");\n    if (source instanceof Query) {\n        // if source has a feature, apply it to ourselves\n        if (source._conditions) {\n            utils.merge(this._conditions, source._conditions);\n        }\n        if (source._fields) {\n            this._fields || (this._fields = {});\n            utils.merge(this._fields, source._fields);\n        }\n        if (source.options) {\n            this.options || (this.options = {});\n            utils.merge(this.options, source.options);\n        }\n        if (source._updateDoc) {\n            this._updateDoc || (this._updateDoc = {});\n            utils.mergeClone(this._updateDoc, source._updateDoc);\n        }\n        if (source._distinctDoc) {\n            this._distinctDoc = source._distinctDoc;\n        }\n        return this;\n    }\n    // plain object\n    utils.merge(this._conditions, source);\n    return this;\n};\n/**\n * Finds documents.\n *\n * #### Example:\n *\n *     query.find()\n *     await query.find()\n *     await query.find({ name: 'Burning Lights' })\n *\n * @param {Object} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */ Query.prototype.find = function(criteria) {\n    this.op = \"find\";\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    return this;\n};\n/**\n * Executes a `find` Query\n * @returns the result\n */ Query.prototype._find = async function _find() {\n    const conds = this._conditions;\n    const options = this._optionsForExec();\n    if (this.$useProjection) {\n        options.projection = this._fieldsForExec();\n    } else {\n        options.fields = this._fieldsForExec();\n    }\n    debug(\"_find\", this._collection.collectionName, conds, options);\n    return this._collection.find(conds, options);\n};\n/**\n * Returns the query cursor\n *\n * #### Examples:\n *\n *     query.find().cursor();\n *     query.cursor({ name: 'Burning Lights' });\n *\n * @param {Object} [criteria] mongodb selector\n * @return {Object} cursor\n * @api public\n */ Query.prototype.cursor = function cursor(criteria) {\n    if (this.op) {\n        if (this.op !== \"find\") {\n            throw new TypeError(\".cursor only support .find method\");\n        }\n    } else {\n        this.find(criteria);\n    }\n    const conds = this._conditions;\n    const options = this._optionsForExec();\n    if (this.$useProjection) {\n        options.projection = this._fieldsForExec();\n    } else {\n        options.fields = this._fieldsForExec();\n    }\n    debug(\"findCursor\", this._collection.collectionName, conds, options);\n    return this._collection.findCursor(conds, options);\n};\n/**\n * Executes the query as a findOne() operation.\n *\n * #### Example:\n *\n *     query.findOne().where('name', /^Burning/);\n *\n *     query.findOne({ name: /^Burning/ })\n *\n *     await query.findOne({ name: /^Burning/ }); // executes\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */ Query.prototype.findOne = function(criteria) {\n    this.op = \"findOne\";\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    return this;\n};\n/**\n * Executes a `findOne` Query\n * @returns the results\n */ Query.prototype._findOne = async function _findOne() {\n    const conds = this._conditions;\n    const options = this._optionsForExec();\n    if (this.$useProjection) {\n        options.projection = this._fieldsForExec();\n    } else {\n        options.fields = this._fieldsForExec();\n    }\n    debug(\"findOne\", this._collection.collectionName, conds, options);\n    return this._collection.findOne(conds, options);\n};\n/**\n * Exectues the query as a count() operation.\n *\n * #### Example:\n *\n *     query.count().where('color', 'black').exec();\n *\n *     query.count({ color: 'black' })\n *\n *     await query.count({ color: 'black' });\n *\n *     const doc = await query.where('color', 'black').count();\n *     console.log('there are %d kittens', count);\n *\n * @param {Object} [criteria] mongodb selector\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Count\n * @api public\n */ Query.prototype.count = function(criteria) {\n    this.op = \"count\";\n    this._validate();\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    return this;\n};\n/**\n * Executes a `count` Query\n * @returns the results\n */ Query.prototype._count = async function _count() {\n    const conds = this._conditions, options = this._optionsForExec();\n    debug(\"count\", this._collection.collectionName, conds, options);\n    return this._collection.count(conds, options);\n};\n/**\n * Declares or executes a distinct() operation.\n *\n * #### Example:\n *\n *     await distinct(criteria, field)\n *     distinct(criteria, field)\n *     await distinct(field)\n *     distinct(field)\n *     await distinct()\n *     distinct()\n *\n * @param {Object|Query} [criteria]\n * @param {String} [field]\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Distinct\n * @api public\n */ Query.prototype.distinct = function(criteria, field) {\n    this.op = \"distinct\";\n    this._validate();\n    if (!field && typeof criteria === \"string\") {\n        field = criteria;\n        criteria = undefined;\n    }\n    if (\"string\" == typeof field) {\n        this._distinctDoc = field;\n    }\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    return this;\n};\n/**\n * Executes a `distinct` Query\n * @returns the results\n */ Query.prototype._distinct = async function _distinct() {\n    if (!this._distinctDoc) {\n        throw new Error(\"No value for `distinct` has been declared\");\n    }\n    const conds = this._conditions, options = this._optionsForExec();\n    debug(\"distinct\", this._collection.collectionName, conds, options);\n    return this._collection.distinct(this._distinctDoc, conds, options);\n};\n/**\n * Declare and/or execute this query as an `updateMany()` operation. This function will update _all_ documents that match\n * `criteria`, rather than just the first one.\n *\n * _All paths passed that are not $atomic operations will become $set ops._\n *\n * #### Example:\n *\n *     // Update every document whose `title` contains 'test'\n *     mquery().updateMany({ title: /test/ }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @return {Query} this\n * @api public\n */ Query.prototype.updateMany = function updateMany(criteria, doc, options) {\n    if (arguments.length === 1) {\n        doc = criteria;\n        criteria = options = undefined;\n    }\n    return _update(this, \"updateMany\", criteria, doc, options);\n};\n/**\n * Executes a `updateMany` Query\n * @returns the results\n */ Query.prototype._updateMany = async function() {\n    return _updateExec(this, \"updateMany\");\n};\n/**\n * Declare and/or execute this query as an `updateOne()` operation. This function will _always_ update just one document,\n * regardless of the `multi` option.\n *\n * _All paths passed that are not $atomic operations will become $set ops._\n *\n * #### Example:\n *\n *     // Update the first document whose `title` contains 'test'\n *     mquery().updateMany({ title: /test/ }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @return {Query} this\n * @api public\n */ Query.prototype.updateOne = function updateOne(criteria, doc, options) {\n    if (arguments.length === 1) {\n        doc = criteria;\n        criteria = options = undefined;\n    }\n    return _update(this, \"updateOne\", criteria, doc, options);\n};\n/**\n * Executes a `updateOne` Query\n * @returns the results\n */ Query.prototype._updateOne = async function() {\n    return _updateExec(this, \"updateOne\");\n};\n/**\n * Declare and/or execute this query as an `replaceOne()` operation. Similar\n * to `updateOne()`, except `replaceOne()` is not allowed to use atomic\n * modifiers (`$set`, `$push`, etc.). Calling `replaceOne()` will always\n * replace the existing doc.\n *\n * #### Example:\n *\n *     // Replace the document with `_id` 1 with `{ _id: 1, year: 2017 }`\n *     mquery().replaceOne({ _id: 1 }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @return {Query} this\n * @api public\n */ Query.prototype.replaceOne = function replaceOne(criteria, doc, options) {\n    if (arguments.length === 1) {\n        doc = criteria;\n        criteria = options = undefined;\n    }\n    this.setOptions({\n        overwrite: true\n    });\n    return _update(this, \"replaceOne\", criteria, doc, options);\n};\n/**\n * Executes a `replaceOne` Query\n * @returns the results\n */ Query.prototype._replaceOne = async function() {\n    return _updateExec(this, \"replaceOne\");\n};\n/*!\n * Internal helper for updateMany, updateOne\n */ function _update(query, op, criteria, doc, options) {\n    query.op = op;\n    if (Query.canMerge(criteria)) {\n        query.merge(criteria);\n    }\n    if (doc) {\n        query._mergeUpdate(doc);\n    }\n    if (utils.isObject(options)) {\n        // { overwrite: true }\n        query.setOptions(options);\n    }\n    return query;\n}\n/**\n * Helper for de-duplicating \"update*\" functions\n * @param {Query} query The Query Object (replacement for \"this\")\n * @param {String} op The Operation to be done\n * @returns the results\n */ async function _updateExec(query, op) {\n    const options = query._optionsForExec();\n    const criteria = query._conditions;\n    const doc = query._updateForExec();\n    debug(\"update\", query._collection.collectionName, criteria, doc, options);\n    return query._collection[op](criteria, doc, options);\n}\n/**\n * Declare and/or execute this query as a `deleteOne()` operation.\n *\n * #### Example:\n *\n *     await mquery(collection).deleteOne({ artist: 'Anne Murray' })\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */ Query.prototype.deleteOne = function(criteria) {\n    this.op = \"deleteOne\";\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    return this;\n};\n/**\n * Executes a `deleteOne` Query\n * @returns the results\n */ Query.prototype._deleteOne = async function() {\n    const options = this._optionsForExec();\n    delete options.justOne;\n    const conds = this._conditions;\n    debug(\"deleteOne\", this._collection.collectionName, conds, options);\n    return this._collection.deleteOne(conds, options);\n};\n/**\n * Declare and/or execute this query as a `deleteMany()` operation. Always deletes\n * _every_ document that matches `criteria`.\n *\n * #### Example:\n *\n *     await mquery(collection).deleteMany({ artist: 'Anne Murray' })\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */ Query.prototype.deleteMany = function(criteria) {\n    this.op = \"deleteMany\";\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    return this;\n};\n/**\n * Executes a `deleteMany` Query\n * @returns the results\n */ Query.prototype._deleteMany = async function() {\n    const options = this._optionsForExec();\n    delete options.justOne;\n    const conds = this._conditions;\n    debug(\"deleteOne\", this._collection.collectionName, conds, options);\n    return this._collection.deleteMany(conds, options);\n};\n/**\n * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) update command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any).\n *\n * #### Available options\n *\n * - `new`: bool - true to return the modified document rather than the original. defaults to true\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n *\n * #### Examples:\n *\n *     await query.findOneAndUpdate(conditions, update, options) // executes\n *     query.findOneAndUpdate(conditions, update, options)  // returns Query\n *     await query.findOneAndUpdate(conditions, update) // executes\n *     query.findOneAndUpdate(conditions, update)           // returns Query\n *     await query.findOneAndUpdate(update)             // returns Query\n *     query.findOneAndUpdate(update)                       // returns Query\n *     await query.findOneAndUpdate()                     // executes\n *     query.findOneAndUpdate()                             // returns Query\n *\n * @param {Object|Query} [query]\n * @param {Object} [doc]\n * @param {Object} [options]\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @return {Query} this\n * @api public\n */ Query.prototype.findOneAndUpdate = function(criteria, doc, options) {\n    this.op = \"findOneAndUpdate\";\n    this._validate();\n    if (arguments.length === 1) {\n        doc = criteria;\n        criteria = options = undefined;\n    }\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    // apply doc\n    if (doc) {\n        this._mergeUpdate(doc);\n    }\n    options && this.setOptions(options);\n    return this;\n};\n/**\n * Executes a `findOneAndUpdate` Query\n * @returns the results\n */ Query.prototype._findOneAndUpdate = async function() {\n    const conds = this._conditions;\n    const update = this._updateForExec();\n    const options = this._optionsForExec();\n    return this._collection.findOneAndUpdate(conds, update, options);\n};\n/**\n * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) remove command.\n *\n * Finds a matching document, removes it, returning the found document (if any).\n *\n * #### Available options\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n *\n * #### Examples:\n *\n *     await A.where().findOneAndRemove(conditions, options) // executes\n *     A.where().findOneAndRemove(conditions, options)  // return Query\n *     await A.where().findOneAndRemove(conditions) // executes\n *     A.where().findOneAndRemove(conditions) // returns Query\n *     await A.where().findOneAndRemove()   // executes\n *     A.where().findOneAndRemove()           // returns Query\n *     A.where().findOneAndDelete()           // alias of .findOneAndRemove()\n *\n * @param {Object} [conditions]\n * @param {Object} [options]\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @api public\n */ Query.prototype.findOneAndRemove = Query.prototype.findOneAndDelete = function(conditions, options) {\n    this.op = \"findOneAndRemove\";\n    this._validate();\n    // apply conditions\n    if (Query.canMerge(conditions)) {\n        this.merge(conditions);\n    }\n    // apply options\n    options && this.setOptions(options);\n    return this;\n};\n/**\n * Executes a `findOneAndRemove` Query\n * @returns the results\n */ Query.prototype._findOneAndRemove = async function() {\n    const options = this._optionsForExec();\n    const conds = this._conditions;\n    return this._collection.findOneAndDelete(conds, options);\n};\n/**\n * Add trace function that gets called when the query is executed.\n * The function will be called with (method, queryInfo, query) and\n * should return a callback function which will be called\n * with (err, result, millis) when the query is complete.\n *\n * queryInfo is an object containing: {\n *   collectionName: <name of the collection>,\n *   conditions: <query criteria>,\n *   options: <comment, fields, readPreference, etc>,\n *   doc: [document to update, if applicable]\n * }\n *\n * NOTE: Does not trace stream queries.\n *\n * @param {Function} traceFunction\n * @return {Query} this\n * @api public\n */ Query.prototype.setTraceFunction = function(traceFunction) {\n    this._traceFunction = traceFunction;\n    return this;\n};\n/**\n * Executes the query\n *\n * #### Examples:\n *\n *     query.exec();\n *     await query.exec();\n *     query.exec('update');\n *     await query.exec('find');\n *\n * @param {String|Function} [operation]\n * @api public\n */ Query.prototype.exec = async function exec(op) {\n    if (typeof op === \"string\") {\n        this.op = op;\n    }\n    assert.ok(this.op, \"Missing query type: (find, etc)\");\n    const fnName = \"_\" + this.op;\n    // better error, because default would list it as \"this[fnName] is not a function\"\n    if (typeof this[fnName] !== \"function\") {\n        throw new TypeError(`this[${fnName}] is not a function`);\n    }\n    return this[fnName]();\n};\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n *\n * @param {Function} [resolve]\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */ Query.prototype.then = async function(res, rej) {\n    return this.exec().then(res, rej);\n};\n/**\n * Returns a cursor for the given `find` query.\n *\n * @throws Error if operation is not a find\n * @returns {Cursor} MongoDB driver cursor\n */ Query.prototype.cursor = function() {\n    if (\"find\" != this.op) throw new Error(\"cursor() is only available for find\");\n    const conds = this._conditions;\n    const options = this._optionsForExec();\n    if (this.$useProjection) {\n        options.projection = this._fieldsForExec();\n    } else {\n        options.fields = this._fieldsForExec();\n    }\n    debug(\"cursor\", this._collection.collectionName, conds, options);\n    return this._collection.findCursor(conds, options);\n};\n/**\n * Determines if field selection has been made.\n *\n * @return {Boolean}\n * @api public\n */ Query.prototype.selected = function selected() {\n    return !!(this._fields && Object.keys(this._fields).length > 0);\n};\n/**\n * Determines if inclusive field selection has been made.\n *\n *     query.selectedInclusively() // false\n *     query.select('name')\n *     query.selectedInclusively() // true\n *     query.selectedExlusively() // false\n *\n * @returns {Boolean}\n */ Query.prototype.selectedInclusively = function selectedInclusively() {\n    if (!this._fields) return false;\n    const keys = Object.keys(this._fields);\n    if (0 === keys.length) return false;\n    for(let i = 0; i < keys.length; ++i){\n        const key = keys[i];\n        if (0 === this._fields[key]) return false;\n        if (this._fields[key] && typeof this._fields[key] === \"object\" && this._fields[key].$meta) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Determines if exclusive field selection has been made.\n *\n *     query.selectedExlusively() // false\n *     query.select('-name')\n *     query.selectedExlusively() // true\n *     query.selectedInclusively() // false\n *\n * @returns {Boolean}\n */ Query.prototype.selectedExclusively = function selectedExclusively() {\n    if (!this._fields) return false;\n    const keys = Object.keys(this._fields);\n    if (0 === keys.length) return false;\n    for(let i = 0; i < keys.length; ++i){\n        const key = keys[i];\n        if (0 === this._fields[key]) return true;\n    }\n    return false;\n};\n/**\n * Merges `doc` with the current update object.\n *\n * @param {Object} doc\n */ Query.prototype._mergeUpdate = function(doc) {\n    if (!this._updateDoc) this._updateDoc = {};\n    if (doc instanceof Query) {\n        if (doc._updateDoc) {\n            utils.mergeClone(this._updateDoc, doc._updateDoc);\n        }\n    } else {\n        utils.mergeClone(this._updateDoc, doc);\n    }\n};\n/**\n * Returns default options.\n *\n * @return {Object}\n * @api private\n */ Query.prototype._optionsForExec = function() {\n    const options = utils.clone(this.options);\n    return options;\n};\n/**\n * Returns fields selection for this query.\n *\n * @return {Object}\n * @api private\n */ Query.prototype._fieldsForExec = function() {\n    return utils.clone(this._fields);\n};\n/**\n * Return an update document with corrected $set operations.\n *\n * @api private\n */ Query.prototype._updateForExec = function() {\n    const update = utils.clone(this._updateDoc);\n    const ops = utils.keys(update);\n    const ret = {};\n    for (const op of ops){\n        if (this.options.overwrite) {\n            ret[op] = update[op];\n            continue;\n        }\n        if (\"$\" !== op[0]) {\n            // fix up $set sugar\n            if (!ret.$set) {\n                if (update.$set) {\n                    ret.$set = update.$set;\n                } else {\n                    ret.$set = {};\n                }\n            }\n            ret.$set[op] = update[op];\n            if (!~ops.indexOf(\"$set\")) ops.push(\"$set\");\n        } else if (\"$set\" === op) {\n            if (!ret.$set) {\n                ret[op] = update[op];\n            }\n        } else {\n            ret[op] = update[op];\n        }\n    }\n    this._compiledUpdate = ret;\n    return ret;\n};\n/**\n * Make sure _path is set.\n *\n * @parmam {String} method\n */ Query.prototype._ensurePath = function(method) {\n    if (!this._path) {\n        const msg = method + \"() must be used after where() \" + \"when called with these arguments\";\n        throw new Error(msg);\n    }\n};\n/*!\n * Permissions\n */ Query.permissions = __webpack_require__(/*! ./permissions */ \"(ssr)/./node_modules/mquery/lib/permissions.js\");\nQuery._isPermitted = function(a, b) {\n    const denied = Query.permissions[b];\n    if (!denied) return true;\n    return true !== denied[a];\n};\nQuery.prototype._validate = function(action) {\n    let fail;\n    let validator;\n    if (undefined === action) {\n        validator = Query.permissions[this.op];\n        if (\"function\" != typeof validator) return true;\n        fail = validator(this);\n    } else if (!Query._isPermitted(action, this.op)) {\n        fail = action;\n    }\n    if (fail) {\n        throw new Error(fail + \" cannot be used with \" + this.op);\n    }\n};\n/**\n * Determines if `conds` can be merged using `mquery().merge()`\n *\n * @param {Object} conds\n * @return {Boolean}\n */ Query.canMerge = function(conds) {\n    return conds instanceof Query || utils.isObject(conds);\n};\n/**\n * Set a trace function that will get called whenever a\n * query is executed.\n *\n * See `setTraceFunction()` for details.\n *\n * @param {Object} conds\n * @return {Boolean}\n */ Query.setGlobalTraceFunction = function(traceFunction) {\n    Query.traceFunction = traceFunction;\n};\n/*!\n * Exports.\n */ Query.utils = utils;\nQuery.env = __webpack_require__(/*! ./env */ \"(ssr)/./node_modules/mquery/lib/env.js\");\nQuery.Collection = __webpack_require__(/*! ./collection */ \"(ssr)/./node_modules/mquery/lib/collection/index.js\");\nQuery.BaseCollection = __webpack_require__(/*! ./collection/collection */ \"(ssr)/./node_modules/mquery/lib/collection/collection.js\");\nmodule.exports = exports = Query; // TODO\n // test utils\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9tcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Q0FFQyxHQUVELE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1FLFFBQVFGLG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU1HLFFBQVFILG1CQUFPQSxDQUFDLHdEQUFTO0FBRS9COzs7Ozs7Ozs7Ozs7Q0FZQyxHQUVELFNBQVNJLE1BQU1DLFFBQVEsRUFBRUMsT0FBTztJQUM5QixJQUFJLENBQUUsS0FBSSxZQUFZRixLQUFJLEdBQ3hCLE9BQU8sSUFBSUEsTUFBTUMsVUFBVUM7SUFFN0IsTUFBTUMsUUFBUSxJQUFJLENBQUNDLFdBQVcsQ0FBQ0MsU0FBUztJQUV4QyxJQUFJLENBQUNDLEVBQUUsR0FBR0gsTUFBTUcsRUFBRSxJQUFJQztJQUV0QixJQUFJLENBQUNMLE9BQU8sR0FBR00sT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR04sTUFBTUQsT0FBTztJQUU5QyxJQUFJLENBQUNRLFdBQVcsR0FBR1AsTUFBTU8sV0FBVyxHQUNoQ1osTUFBTWEsS0FBSyxDQUFDUixNQUFNTyxXQUFXLElBQzdCLENBQUM7SUFFTCxJQUFJLENBQUNFLE9BQU8sR0FBR1QsTUFBTVMsT0FBTyxHQUN4QmQsTUFBTWEsS0FBSyxDQUFDUixNQUFNUyxPQUFPLElBQ3pCTDtJQUVKLElBQUksQ0FBQ00sVUFBVSxHQUFHVixNQUFNVSxVQUFVLEdBQzlCZixNQUFNYSxLQUFLLENBQUNSLE1BQU1VLFVBQVUsSUFDNUJOO0lBRUosSUFBSSxDQUFDTyxLQUFLLEdBQUdYLE1BQU1XLEtBQUssSUFBSVA7SUFDNUIsSUFBSSxDQUFDUSxZQUFZLEdBQUdaLE1BQU1ZLFlBQVksSUFBSVI7SUFDMUMsSUFBSSxDQUFDUyxXQUFXLEdBQUdiLE1BQU1hLFdBQVcsSUFBSVQ7SUFDeEMsSUFBSSxDQUFDVSxjQUFjLEdBQUdkLE1BQU1j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MEMsVUFBVSxHQUFHOUMsbUJBQU9BLENBQUM7QUFDM0JJLE1BQU1rTyxjQUFjLEdBQUd0TyxtQkFBT0EsQ0FBQztBQUMvQnVPLE9BQU9DLE9BQU8sR0FBR0EsVUFBVXBPLE9BRTNCLE9BQU87Q0FDUCxhQUFhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hdXRoLXJlZ2lzdGVyLy4vbm9kZV9tb2R1bGVzL21xdWVyeS9saWIvbXF1ZXJ5LmpzPzdiNTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICovXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtcXVlcnknKTtcblxuLyoqXG4gKiBRdWVyeSBjb25zdHJ1Y3RvciB1c2VkIGZvciBidWlsZGluZyBxdWVyaWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgdmFyIHF1ZXJ5ID0gbmV3IFF1ZXJ5KHsgbmFtZTogJ21xdWVyeScgfSk7XG4gKiAgICAgcXVlcnkuc2V0T3B0aW9ucyh7IGNvbGxlY3Rpb246IG1vZHVsZUNvbGxlY3Rpb24gfSlcbiAqICAgICBhd2FpdCBxdWVyeS53aGVyZSgnYWdlJykuZ3RlKDIxKS5leGVjKCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjcml0ZXJpYV0gY3JpdGVyaWEgZm9yIHRoZSBxdWVyeSBPUiB0aGUgY29sbGVjdGlvbiBpbnN0YW5jZSB0byB1c2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUXVlcnkoY3JpdGVyaWEsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFF1ZXJ5KSlcbiAgICByZXR1cm4gbmV3IFF1ZXJ5KGNyaXRlcmlhLCBvcHRpb25zKTtcblxuICBjb25zdCBwcm90byA9IHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gIHRoaXMub3AgPSBwcm90by5vcCB8fCB1bmRlZmluZWQ7XG5cbiAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvdG8ub3B0aW9ucyk7XG5cbiAgdGhpcy5fY29uZGl0aW9ucyA9IHByb3RvLl9jb25kaXRpb25zXG4gICAgPyB1dGlscy5jbG9uZShwcm90by5fY29uZGl0aW9ucylcbiAgICA6IHt9O1xuXG4gIHRoaXMuX2ZpZWxkcyA9IHByb3RvLl9maWVsZHNcbiAgICA/IHV0aWxzLmNsb25lKHByb3RvLl9maWVsZHMpXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdGhpcy5fdXBkYXRlRG9jID0gcHJvdG8uX3VwZGF0ZURvY1xuICAgID8gdXRpbHMuY2xvbmUocHJvdG8uX3VwZGF0ZURvYylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB0aGlzLl9wYXRoID0gcHJvdG8uX3BhdGggfHwgdW5kZWZpbmVkO1xuICB0aGlzLl9kaXN0aW5jdERvYyA9IHByb3RvLl9kaXN0aW5jdERvYyB8fCB1bmRlZmluZWQ7XG4gIHRoaXMuX2NvbGxlY3Rpb24gPSBwcm90by5fY29sbGVjdGlvbiB8fCB1bmRlZmluZWQ7XG4gIHRoaXMuX3RyYWNlRnVuY3Rpb24gPSBwcm90by5fdHJhY2VGdW5jdGlvbiB8fCB1bmRlZmluZWQ7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICBpZiAoY3JpdGVyaWEpIHtcbiAgICB0aGlzLmZpbmQoY3JpdGVyaWEpO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHBhcmFtZXRlciB0aGF0IHRoZSB1c2VyIGNhbiBzZXQgd2hpY2ggZGV0ZXJtaW5lcyBpZiBtcXVlcnlcbiAqIHVzZXMgJHdpdGhpbiBvciAkZ2VvV2l0aGluIGZvciBxdWVyaWVzLiBJdCBkZWZhdWx0cyB0byB0cnVlIHdoaWNoXG4gKiBtZWFucyAkZ2VvV2l0aGluIHdpbGwgYmUgdXNlZC4gSWYgdXNpbmcgTW9uZ29EQiA8IDIuNCB5b3Ugc2hvdWxkXG4gKiBzZXQgdGhpcyB0byBmYWxzZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHVzZSRnZW9XaXRoaW5cbiAqL1xuXG5sZXQgJHdpdGhpbkNtZCA9ICckZ2VvV2l0aGluJztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeSwgJ3VzZSRnZW9XaXRoaW4nLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiAkd2l0aGluQ21kID09ICckZ2VvV2l0aGluJzsgfSxcbiAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgaWYgKHRydWUgPT09IHYpIHtcbiAgICAgIC8vIG1vbmdvZGIgPj0gMi40XG4gICAgICAkd2l0aGluQ21kID0gJyRnZW9XaXRoaW4nO1xuICAgIH0gZWxzZSB7XG4gICAgICAkd2l0aGluQ21kID0gJyR3aXRoaW4nO1xuICAgIH1cbiAgfVxufSk7XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBxdWVyeSB0byBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHdpdGggYWxsIGFyZ3VtZW50cyBhbmQgb3B0aW9ucyByZXRhaW5lZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIENyZWF0ZSBhIHF1ZXJ5IHRoYXQgd2lsbCByZWFkIGRvY3VtZW50cyB3aXRoIGEgXCJ2aWRlb1wiIGNhdGVnb3J5IGZyb21cbiAqICAgICAvLyBgYUNvbGxlY3Rpb25gIG9uIHRoZSBwcmltYXJ5IG5vZGUgaW4gdGhlIHJlcGxpY2Etc2V0IHVubGVzcyBpdCBpcyBkb3duLFxuICogICAgIC8vIGluIHdoaWNoIGNhc2Ugd2UnbGwgcmVhZCBmcm9tIGEgc2Vjb25kYXJ5IG5vZGUuXG4gKiAgICAgdmFyIHF1ZXJ5ID0gbXF1ZXJ5KHsgY2F0ZWdvcnk6ICd2aWRlbycgfSlcbiAqICAgICBxdWVyeS5zZXRPcHRpb25zKHsgY29sbGVjdGlvbjogYUNvbGxlY3Rpb24sIHJlYWQ6ICdwcmltYXJ5UHJlZmVycmVkJyB9KTtcbiAqXG4gKiAgICAgLy8gY3JlYXRlIGEgY29uc3RydWN0b3IgYmFzZWQgb2ZmIHRoZXNlIHNldHRpbmdzXG4gKiAgICAgdmFyIFZpZGVvID0gcXVlcnkudG9Db25zdHJ1Y3RvcigpO1xuICpcbiAqICAgICAvLyBWaWRlbyBpcyBub3cgYSBzdWJjbGFzcyBvZiBtcXVlcnkoKSBhbmQgd29ya3MgdGhlIHNhbWUgd2F5IGJ1dCB3aXRoIHRoZVxuICogICAgIC8vIGRlZmF1bHQgcXVlcnkgcGFyYW1ldGVycyBhbmQgb3B0aW9ucyBzZXQuXG4gKlxuICogICAgIC8vIHJ1biBhIHF1ZXJ5IHdpdGggdGhlIHByZXZpb3VzIHNldHRpbmdzIGJ1dCBmaWx0ZXIgZm9yIG1vdmllcyB3aXRoIG5hbWVzXG4gKiAgICAgLy8gdGhhdCBzdGFydCB3aXRoIFwiTGlmZVwiLlxuICogICAgIFZpZGVvKCkud2hlcmUoeyBuYW1lOiAvXkxpZmUvIH0pLmV4ZWMoY2IpO1xuICpcbiAqIEByZXR1cm4ge1F1ZXJ5fSBuZXcgUXVlcnlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnRvQ29uc3RydWN0b3IgPSBmdW5jdGlvbiB0b0NvbnN0cnVjdG9yKCkge1xuICBmdW5jdGlvbiBDdXN0b21RdWVyeShjcml0ZXJpYSwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDdXN0b21RdWVyeSkpXG4gICAgICByZXR1cm4gbmV3IEN1c3RvbVF1ZXJ5KGNyaXRlcmlhLCBvcHRpb25zKTtcbiAgICBRdWVyeS5jYWxsKHRoaXMsIGNyaXRlcmlhLCBvcHRpb25zKTtcbiAgfVxuXG4gIHV0aWxzLmluaGVyaXRzKEN1c3RvbVF1ZXJ5LCBRdWVyeSk7XG5cbiAgLy8gc2V0IGluaGVyaXRlZCBkZWZhdWx0c1xuICBjb25zdCBwID0gQ3VzdG9tUXVlcnkucHJvdG90eXBlO1xuXG4gIHAub3B0aW9ucyA9IHt9O1xuICBwLnNldE9wdGlvbnModGhpcy5vcHRpb25zKTtcblxuICBwLm9wID0gdGhpcy5vcDtcbiAgcC5fY29uZGl0aW9ucyA9IHV0aWxzLmNsb25lKHRoaXMuX2NvbmRpdGlvbnMpO1xuICBwLl9maWVsZHMgPSB1dGlscy5jbG9uZSh0aGlzLl9maWVsZHMpO1xuICBwLl91cGRhdGVEb2MgPSB1dGlscy5jbG9uZSh0aGlzLl91cGRhdGVEb2MpO1xuICBwLl9wYXRoID0gdGhpcy5fcGF0aDtcbiAgcC5fZGlzdGluY3REb2MgPSB0aGlzLl9kaXN0aW5jdERvYztcbiAgcC5fY29sbGVjdGlvbiA9IHRoaXMuX2NvbGxlY3Rpb247XG4gIHAuX3RyYWNlRnVuY3Rpb24gPSB0aGlzLl90cmFjZUZ1bmN0aW9uO1xuXG4gIHJldHVybiBDdXN0b21RdWVyeTtcbn07XG5cbi8qKlxuICogU2V0cyBxdWVyeSBvcHRpb25zLlxuICpcbiAqICMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIFt0YWlsYWJsZV0oaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvVGFpbGFibGUrQ3Vyc29ycykgKlxuICogLSBbc29ydF0oaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTdCJTdCc29ydChcXCklN0QlN0QpICpcbiAqIC0gW2xpbWl0XShodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lN0IlN0JsaW1pdCUyOCUyOSU3RCU3RCkgKlxuICogLSBbc2tpcF0oaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTdCJTdCc2tpcCUyOCUyOSU3RCU3RCkgKlxuICogLSBbbWF4VGltZV0oaHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9tZXRhL21heFRpbWVNUy8jb3AuX1NfbWF4VGltZU1TKSAqXG4gKiAtIFtiYXRjaFNpemVdKGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSU3QiU3QmJhdGNoU2l6ZSUyOCUyOSU3RCU3RCkgKlxuICogLSBbY29tbWVudF0oaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTI0Y29tbWVudCkgKlxuICogLSBbaGludF0oaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTI0aGludCkgKlxuICogLSBbc2xhdmVPa10oaHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL2FwcGxpY2F0aW9ucy9yZXBsaWNhdGlvbi8jcmVhZC1wcmVmZXJlbmNlKSAqXG4gKiAtIFtzYWZlXShodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9nZXRMYXN0RXJyb3IrQ29tbWFuZClcbiAqIC0gY29sbGVjdGlvbiB0aGUgY29sbGVjdGlvbiB0byBxdWVyeSBhZ2FpbnN0XG4gKlxuICogXyogZGVub3RlcyBhIHF1ZXJ5IGhlbHBlciBtZXRob2QgaXMgYWxzbyBhdmFpbGFibGVfXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmICghKG9wdGlvbnMgJiYgdXRpbHMuaXNPYmplY3Qob3B0aW9ucykpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIHNldCBhcmJpdHJhcnkgb3B0aW9uc1xuICBjb25zdCBtZXRob2RzID0gdXRpbHMua2V5cyhvcHRpb25zKTtcbiAgbGV0IG1ldGhvZDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyArK2kpIHtcbiAgICBtZXRob2QgPSBtZXRob2RzW2ldO1xuXG4gICAgLy8gdXNlIG1ldGhvZHMgaWYgZXhpc3QgKHNhZmVyIG9wdGlvbiBtYW5pcHVsYXRpb24pXG4gICAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHRoaXNbbWV0aG9kXSkge1xuICAgICAgY29uc3QgYXJncyA9IEFycmF5LmlzQXJyYXkob3B0aW9uc1ttZXRob2RdKVxuICAgICAgICA/IG9wdGlvbnNbbWV0aG9kXVxuICAgICAgICA6IFtvcHRpb25zW21ldGhvZF1dO1xuICAgICAgdGhpc1ttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wdGlvbnNbbWV0aG9kXSA9IG9wdGlvbnNbbWV0aG9kXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGlzIFF1ZXJ5cyBjb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Q29sbGVjdGlvbn0gY29sbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY29sbGVjdGlvbiA9IGZ1bmN0aW9uIGNvbGxlY3Rpb24oY29sbCkge1xuICB0aGlzLl9jb2xsZWN0aW9uID0gbmV3IFF1ZXJ5LkNvbGxlY3Rpb24oY29sbCk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBjb2xsYXRpb24gdG8gdGhpcyBvcCAoTW9uZ29EQiAzLjQgYW5kIHVwKVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuZmluZCgpLmNvbGxhdGlvbih7IGxvY2FsZTogXCJlbl9VU1wiLCBzdHJlbmd0aDogMSB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgTW9uZ29EQiBkb2NzIGh0dHBzOi8vZG9jcy5tb25nb2RiLmNvbS9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3IuY29sbGF0aW9uLyNjdXJzb3IuY29sbGF0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5jb2xsYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLm9wdGlvbnMuY29sbGF0aW9uID0gdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJHdoZXJlYCBjb25kaXRpb25cbiAqXG4gKiBVc2UgYCR3aGVyZWAgd2hlbiB5b3UgbmVlZCB0byBzZWxlY3QgZG9jdW1lbnRzIHVzaW5nIGEgSmF2YVNjcmlwdCBleHByZXNzaW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuJHdoZXJlKCd0aGlzLmNvbW1lbnRzLmxlbmd0aCA+IDEwIHx8IHRoaXMubmFtZS5sZW5ndGggPiA1JylcbiAqXG4gKiAgICAgcXVlcnkuJHdoZXJlKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgIHJldHVybiB0aGlzLmNvbW1lbnRzLmxlbmd0aCA+IDEwIHx8IHRoaXMubmFtZS5sZW5ndGggPiA1O1xuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IGpzIGphdmFzY3JpcHQgc3RyaW5nIG9yIGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAbWV0aG9kICR3aGVyZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuJHdoZXJlID0gZnVuY3Rpb24oanMpIHtcbiAgdGhpcy5fY29uZGl0aW9ucy4kd2hlcmUgPSBqcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGBwYXRoYCBmb3IgdXNlIHdpdGggY2hhaW5pbmcuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBpbnN0ZWFkIG9mIHdyaXRpbmc6XG4gKiAgICAgYXdhaXQgVXNlci5maW5kKHthZ2U6IHskZ3RlOiAyMSwgJGx0ZTogNjV9fSk7XG4gKlxuICogICAgIC8vIHdlIGNhbiBpbnN0ZWFkIHdyaXRlOlxuICogICAgIFVzZXIud2hlcmUoJ2FnZScpLmd0ZSgyMSkubHRlKDY1KTtcbiAqXG4gKiAgICAgLy8gcGFzc2luZyBxdWVyeSBjb25kaXRpb25zIGlzIHBlcm1pdHRlZFxuICogICAgIFVzZXIuZmluZCgpLndoZXJlKHsgbmFtZTogJ3ZvbmRlcmZ1bCcgfSlcbiAqXG4gKiAgICAgLy8gY2hhaW5pbmdcbiAqICAgICBhd2FpdCBVc2VyXG4gKiAgICAgICAud2hlcmUoJ2FnZScpLmd0ZSgyMSkubHRlKDY1KVxuICogICAgICAgLndoZXJlKCduYW1lJywgL152b25kZXJmdWwvaSlcbiAqICAgICAgIC53aGVyZSgnZnJpZW5kcycpLnNsaWNlKDEwKVxuICogICAgICAgLmV4ZWMoKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbdmFsXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLndoZXJlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXM7XG4gIGlmICghdGhpcy5vcCkgdGhpcy5vcCA9ICdmaW5kJztcblxuICBjb25zdCB0eXBlID0gdHlwZW9mIGFyZ3VtZW50c1swXTtcblxuICBpZiAoJ3N0cmluZycgPT0gdHlwZSkge1xuICAgIHRoaXMuX3BhdGggPSBhcmd1bWVudHNbMF07XG5cbiAgICBpZiAoMiA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fY29uZGl0aW9uc1t0aGlzLl9wYXRoXSA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICgnb2JqZWN0JyA9PSB0eXBlICYmICFBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICByZXR1cm4gdGhpcy5tZXJnZShhcmd1bWVudHNbMF0pO1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0aCBtdXN0IGJlIGEgc3RyaW5nIG9yIG9iamVjdCcpO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGNvbXBsZW1lbnRhcnkgY29tcGFyaXNvbiB2YWx1ZSBmb3IgcGF0aHMgc3BlY2lmaWVkIHdpdGggYHdoZXJlKClgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBVc2VyLndoZXJlKCdhZ2UnKS5lcXVhbHMoNDkpO1xuICpcbiAqICAgICAvLyBpcyB0aGUgc2FtZSBhc1xuICpcbiAqICAgICBVc2VyLndoZXJlKCdhZ2UnLCA0OSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyh2YWwpIHtcbiAgdGhpcy5fZW5zdXJlUGF0aCgnZXF1YWxzJyk7XG4gIGNvbnN0IHBhdGggPSB0aGlzLl9wYXRoO1xuICB0aGlzLl9jb25kaXRpb25zW3BhdGhdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBjb21wbGVtZW50YXJ5IGNvbXBhcmlzb24gdmFsdWUgZm9yIHBhdGhzIHNwZWNpZmllZCB3aXRoIGB3aGVyZSgpYFxuICogVGhpcyBpcyBhbGlhcyBvZiBgZXF1YWxzYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgVXNlci53aGVyZSgnYWdlJykuZXEoNDkpO1xuICpcbiAqICAgICAvLyBpcyB0aGUgc2FtZSBhc1xuICpcbiAqICAgICBVc2VyLnNoZXJlKCdhZ2UnKS5lcXVhbHMoNDkpO1xuICpcbiAqICAgICAvLyBpcyB0aGUgc2FtZSBhc1xuICpcbiAqICAgICBVc2VyLndoZXJlKCdhZ2UnLCA0OSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEodmFsKSB7XG4gIHRoaXMuX2Vuc3VyZVBhdGgoJ2VxJyk7XG4gIGNvbnN0IHBhdGggPSB0aGlzLl9wYXRoO1xuICB0aGlzLl9jb25kaXRpb25zW3BhdGhdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGFyZ3VtZW50cyBmb3IgYW4gYCRvcmAgY29uZGl0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkub3IoW3sgY29sb3I6ICdyZWQnIH0sIHsgc3RhdHVzOiAnZW1lcmdlbmN5JyB9XSlcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBhcnJheSBvZiBjb25kaXRpb25zXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvcihhcnJheSkge1xuICBjb25zdCBvciA9IHRoaXMuX2NvbmRpdGlvbnMuJG9yIHx8ICh0aGlzLl9jb25kaXRpb25zLiRvciA9IFtdKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkgYXJyYXkgPSBbYXJyYXldO1xuICBvci5wdXNoLmFwcGx5KG9yLCBhcnJheSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYXJndW1lbnRzIGZvciBhIGAkbm9yYCBjb25kaXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5ub3IoW3sgY29sb3I6ICdncmVlbicgfSwgeyBzdGF0dXM6ICdvaycgfV0pXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgYXJyYXkgb2YgY29uZGl0aW9uc1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLm5vciA9IGZ1bmN0aW9uIG5vcihhcnJheSkge1xuICBjb25zdCBub3IgPSB0aGlzLl9jb25kaXRpb25zLiRub3IgfHwgKHRoaXMuX2NvbmRpdGlvbnMuJG5vciA9IFtdKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkgYXJyYXkgPSBbYXJyYXldO1xuICBub3IucHVzaC5hcHBseShub3IsIGFycmF5KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhcmd1bWVudHMgZm9yIGEgYCRhbmRgIGNvbmRpdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmFuZChbeyBjb2xvcjogJ2dyZWVuJyB9LCB7IHN0YXR1czogJ29rJyB9XSlcbiAqXG4gKiBAc2VlICRhbmQgaHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9hbmQvXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBhcnJheSBvZiBjb25kaXRpb25zXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kKGFycmF5KSB7XG4gIGNvbnN0IGFuZCA9IHRoaXMuX2NvbmRpdGlvbnMuJGFuZCB8fCAodGhpcy5fY29uZGl0aW9ucy4kYW5kID0gW10pO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSBhcnJheSA9IFthcnJheV07XG4gIGFuZC5wdXNoLmFwcGx5KGFuZCwgYXJyYXkpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJGd0IHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgVGhpbmcuZmluZCgpLndoZXJlKCdhZ2UnKS5ndCgyMSlcbiAqXG4gKiAgICAgLy8gb3JcbiAqICAgICBUaGluZy5maW5kKCkuZ3QoJ2FnZScsIDIxKVxuICpcbiAqIEBtZXRob2QgZ3RcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRndGUgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBndGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRsdCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIGx0XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkbHRlIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgbHRlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkbmUgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBuZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGFuICRpbiBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIGluXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYW4gJG5pbiBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIG5pblxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGFuICRhbGwgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBhbGxcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRzaXplIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2Qgc2l6ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJHJlZ2V4IHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgcmVnZXhcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkbWF4RGlzdGFuY2UgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBtYXhEaXN0YW5jZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qIVxuICogZ3QsIGd0ZSwgbHQsIGx0ZSwgbmUsIGluLCBuaW4sIGFsbCwgcmVnZXgsIHNpemUsIG1heERpc3RhbmNlXG4gKlxuICogICAgIFRoaW5nLndoZXJlKCd0eXBlJykubmluKGFycmF5KVxuICovXG5cbidndCBndGUgbHQgbHRlIG5lIGluIG5pbiBhbGwgcmVnZXggc2l6ZSBtYXhEaXN0YW5jZSBtaW5EaXN0YW5jZScuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKCRjb25kaXRpb25hbCkge1xuICBRdWVyeS5wcm90b3R5cGVbJGNvbmRpdGlvbmFsXSA9IGZ1bmN0aW9uKCkge1xuICAgIGxldCBwYXRoLCB2YWw7XG5cbiAgICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fZW5zdXJlUGF0aCgkY29uZGl0aW9uYWwpO1xuICAgICAgdmFsID0gYXJndW1lbnRzWzBdO1xuICAgICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgfVxuXG4gICAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zW3BhdGhdID09PSBudWxsIHx8IHR5cGVvZiB0aGlzLl9jb25kaXRpb25zW3BhdGhdID09PSAnb2JqZWN0JyA/XG4gICAgICB0aGlzLl9jb25kaXRpb25zW3BhdGhdIDpcbiAgICAgICh0aGlzLl9jb25kaXRpb25zW3BhdGhdID0ge30pO1xuICAgIGNvbmRzWyckJyArICRjb25kaXRpb25hbF0gPSB2YWw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59KTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJG1vZGAgY29uZGl0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uKCkge1xuICBsZXQgdmFsLCBwYXRoO1xuXG4gIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnbW9kJyk7XG4gICAgdmFsID0gYXJndW1lbnRzWzBdO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICB9IGVsc2UgaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGggJiYgIUFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzFdKSkge1xuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ21vZCcpO1xuICAgIHZhbCA9IFthcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXV07XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gIH0gZWxzZSBpZiAoMyA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHZhbCA9IFthcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXV07XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBhcmd1bWVudHNbMV07XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSB8fCAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcbiAgY29uZHMuJG1vZCA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhbiBgJGV4aXN0c2AgY29uZGl0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyB7IG5hbWU6IHsgJGV4aXN0czogdHJ1ZSB9fVxuICogICAgIFRoaW5nLndoZXJlKCduYW1lJykuZXhpc3RzKClcbiAqICAgICBUaGluZy53aGVyZSgnbmFtZScpLmV4aXN0cyh0cnVlKVxuICogICAgIFRoaW5nLmZpbmQoKS5leGlzdHMoJ25hbWUnKVxuICpcbiAqICAgICAvLyB7IG5hbWU6IHsgJGV4aXN0czogZmFsc2UgfX1cbiAqICAgICBUaGluZy53aGVyZSgnbmFtZScpLmV4aXN0cyhmYWxzZSk7XG4gKiAgICAgVGhpbmcuZmluZCgpLmV4aXN0cygnbmFtZScsIGZhbHNlKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24oKSB7XG4gIGxldCBwYXRoLCB2YWw7XG5cbiAgaWYgKDAgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdleGlzdHMnKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICB2YWwgPSB0cnVlO1xuICB9IGVsc2UgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBpZiAoJ2Jvb2xlYW4nID09PSB0eXBlb2YgYXJndW1lbnRzWzBdKSB7XG4gICAgICB0aGlzLl9lbnN1cmVQYXRoKCdleGlzdHMnKTtcbiAgICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgICAgdmFsID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFsID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoMiA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsID0gYXJndW1lbnRzWzFdO1xuICB9XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zW3BhdGhdIHx8ICh0aGlzLl9jb25kaXRpb25zW3BhdGhdID0ge30pO1xuICBjb25kcy4kZXhpc3RzID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGFuIGAkZWxlbU1hdGNoYCBjb25kaXRpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmVsZW1NYXRjaCgnY29tbWVudCcsIHsgYXV0aG9yOiAnYXV0b2JvdCcsIHZvdGVzOiB7JGd0ZTogNX19KVxuICpcbiAqICAgICBxdWVyeS53aGVyZSgnY29tbWVudCcpLmVsZW1NYXRjaCh7IGF1dGhvcjogJ2F1dG9ib3QnLCB2b3RlczogeyRndGU6IDV9fSlcbiAqXG4gKiAgICAgcXVlcnkuZWxlbU1hdGNoKCdjb21tZW50JywgZnVuY3Rpb24gKGVsZW0pIHtcbiAqICAgICAgIGVsZW0ud2hlcmUoJ2F1dGhvcicpLmVxdWFscygnYXV0b2JvdCcpO1xuICogICAgICAgZWxlbS53aGVyZSgndm90ZXMnKS5ndGUoNSk7XG4gKiAgICAgfSlcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2NvbW1lbnQnKS5lbGVtTWF0Y2goZnVuY3Rpb24gKGVsZW0pIHtcbiAqICAgICAgIGVsZW0ud2hlcmUoeyBhdXRob3I6ICdhdXRvYm90JyB9KTtcbiAqICAgICAgIGVsZW0ud2hlcmUoJ3ZvdGVzJykuZ3RlKDUpO1xuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fEZ1bmN0aW9ufSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gY3JpdGVyaWFcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5lbGVtTWF0Y2ggPSBmdW5jdGlvbigpIHtcbiAgaWYgKG51bGwgPT0gYXJndW1lbnRzWzBdKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcblxuICBsZXQgZm4sIHBhdGgsIGNyaXRlcmlhO1xuXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYXJndW1lbnRzWzBdKSB7XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnZWxlbU1hdGNoJyk7XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgZm4gPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QoYXJndW1lbnRzWzBdKSkge1xuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ2VsZW1NYXRjaCcpO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIGNyaXRlcmlhID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhcmd1bWVudHNbMV0pIHtcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIGZuID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1sxXSAmJiB1dGlscy5pc09iamVjdChhcmd1bWVudHNbMV0pKSB7XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICBjcml0ZXJpYSA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBpZiAoZm4pIHtcbiAgICBjcml0ZXJpYSA9IG5ldyBRdWVyeTtcbiAgICBmbihjcml0ZXJpYSk7XG4gICAgY3JpdGVyaWEgPSBjcml0ZXJpYS5fY29uZGl0aW9ucztcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSB8fCAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcbiAgY29uZHMuJGVsZW1NYXRjaCA9IGNyaXRlcmlhO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFNwYXRpYWwgcXVlcmllc1xuXG4vKipcbiAqIFN1Z2FyIGZvciBnZW8tc3BhdGlhbCBxdWVyaWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkud2l0aGluKCkuYm94KClcbiAqICAgICBxdWVyeS53aXRoaW4oKS5jaXJjbGUoKVxuICogICAgIHF1ZXJ5LndpdGhpbigpLmdlb21ldHJ5KClcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbih7IGNlbnRlcjogWzUwLDUwXSwgcmFkaXVzOiAxMCwgdW5pcXVlOiB0cnVlLCBzcGhlcmljYWw6IHRydWUgfSk7XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbih7IGJveDogW1s0MC43MywgLTczLjldLCBbNDAuNywgLTczLjk4OF1dIH0pO1xuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oeyBwb2x5Z29uOiBbW10sW10sW10sW11dIH0pO1xuICpcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKFtdLCBbXSwgW10pIC8vIHBvbHlnb25cbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKFtdLCBbXSkgLy8gYm94XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbih7IHR5cGU6ICdMaW5lU3RyaW5nJywgY29vcmRpbmF0ZXM6IFsuLi5dIH0pOyAvLyBnZW9tZXRyeVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBNdXN0IGJlIHVzZWQgYWZ0ZXIgYHdoZXJlKClgLlxuICpcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLndpdGhpbiA9IGZ1bmN0aW9uIHdpdGhpbigpIHtcbiAgLy8gb3BpbmlvbmF0ZWQsIG11c3QgYmUgdXNlZCBhZnRlciB3aGVyZVxuICB0aGlzLl9lbnN1cmVQYXRoKCd3aXRoaW4nKTtcbiAgdGhpcy5fZ2VvQ29tcGFyaXNvbiA9ICR3aXRoaW5DbWQ7XG5cbiAgaWYgKDAgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICgyID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm94LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0gZWxzZSBpZiAoMiA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5wb2x5Z29uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBjb25zdCBhcmVhID0gYXJndW1lbnRzWzBdO1xuXG4gIGlmICghYXJlYSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG5cbiAgaWYgKGFyZWEuY2VudGVyKVxuICAgIHJldHVybiB0aGlzLmNpcmNsZShhcmVhKTtcblxuICBpZiAoYXJlYS5ib3gpXG4gICAgcmV0dXJuIHRoaXMuYm94LmFwcGx5KHRoaXMsIGFyZWEuYm94KTtcblxuICBpZiAoYXJlYS5wb2x5Z29uKVxuICAgIHJldHVybiB0aGlzLnBvbHlnb24uYXBwbHkodGhpcywgYXJlYS5wb2x5Z29uKTtcblxuICBpZiAoYXJlYS50eXBlICYmIGFyZWEuY29vcmRpbmF0ZXMpXG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkoYXJlYSk7XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkYm94IGNvbmRpdGlvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgdmFyIGxvd2VyTGVmdCA9IFs0MC43MzA4MywgLTczLjk5NzU2XVxuICogICAgIHZhciB1cHBlclJpZ2h0PSBbNDAuNzQxNDA0LCAgLTczLjk4ODEzNV1cbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmJveChsb3dlckxlZnQsIHVwcGVyUmlnaHQpXG4gKiAgICAgcXVlcnkuYm94KCdsb2MnLCBsb3dlckxlZnQsIHVwcGVyUmlnaHQgKVxuICpcbiAqIEBzZWUgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvR2Vvc3BhdGlhbCtJbmRleGluZ1xuICogQHNlZSBRdWVyeSN3aXRoaW4gI3F1ZXJ5X1F1ZXJ5LXdpdGhpblxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWxcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5ib3ggPSBmdW5jdGlvbigpIHtcbiAgbGV0IHBhdGgsIGJveDtcblxuICBpZiAoMyA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIC8vIGJveCgnbG9jJywgW10sIFtdKVxuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgYm94ID0gW2FyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdXTtcbiAgfSBlbHNlIGlmICgyID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgLy8gYm94KFtdLCBbXSlcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdib3gnKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICBib3ggPSBbYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV1dO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSB8fCAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcbiAgY29uZHNbdGhpcy5fZ2VvQ29tcGFyaXNvbiB8fCAkd2l0aGluQ21kXSA9IHsgJGJveDogYm94IH07XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkcG9seWdvbiBjb25kaXRpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5wb2x5Z29uKFsxMCwyMF0sIFsxMywgMjVdLCBbNywxNV0pXG4gKiAgICAgcXVlcnkucG9seWdvbignbG9jJywgWzEwLDIwXSwgWzEzLCAyNV0sIFs3LDE1XSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gW3BhdGhdXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gW3ZhbF1cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0dlb3NwYXRpYWwrSW5kZXhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnBvbHlnb24gPSBmdW5jdGlvbigpIHtcbiAgbGV0IHZhbCwgcGF0aDtcblxuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGFyZ3VtZW50c1swXSkge1xuICAgIC8vIHBvbHlnb24oJ2xvYycsIFtdLFtdLFtdKVxuICAgIHZhbCA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcbiAgICBwYXRoID0gdmFsLnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcG9seWdvbihbXSxbXSxbXSlcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdwb2x5Z29uJyk7XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgdmFsID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICB9XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zW3BhdGhdIHx8ICh0aGlzLl9jb25kaXRpb25zW3BhdGhdID0ge30pO1xuICBjb25kc1t0aGlzLl9nZW9Db21wYXJpc29uIHx8ICR3aXRoaW5DbWRdID0geyAkcG9seWdvbjogdmFsIH07XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkY2VudGVyIG9yICRjZW50ZXJTcGhlcmUgY29uZGl0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgdmFyIGFyZWEgPSB7IGNlbnRlcjogWzUwLCA1MF0sIHJhZGl1czogMTAsIHVuaXF1ZTogdHJ1ZSB9XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmNpcmNsZShhcmVhKVxuICogICAgIHF1ZXJ5LmNlbnRlcignbG9jJywgYXJlYSk7XG4gKlxuICogICAgIC8vIGZvciBzcGhlcmljYWwgY2FsY3VsYXRpb25zXG4gKiAgICAgdmFyIGFyZWEgPSB7IGNlbnRlcjogWzUwLCA1MF0sIHJhZGl1czogMTAsIHVuaXF1ZTogdHJ1ZSwgc3BoZXJpY2FsOiB0cnVlIH1cbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKCkuY2lyY2xlKGFyZWEpXG4gKiAgICAgcXVlcnkuY2VudGVyKCdsb2MnLCBhcmVhKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge09iamVjdH0gYXJlYVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvR2Vvc3BhdGlhbCtJbmRleGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY2lyY2xlID0gZnVuY3Rpb24oKSB7XG4gIGxldCBwYXRoLCB2YWw7XG5cbiAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdjaXJjbGUnKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICB2YWwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAoMiA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGlmICghKCdyYWRpdXMnIGluIHZhbCAmJiB2YWwuY2VudGVyKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NlbnRlciBhbmQgcmFkaXVzIGFyZSByZXF1aXJlZCcpO1xuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSB8fCAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcblxuICBjb25zdCB0eXBlID0gdmFsLnNwaGVyaWNhbFxuICAgID8gJyRjZW50ZXJTcGhlcmUnXG4gICAgOiAnJGNlbnRlcic7XG5cbiAgY29uc3Qgd0tleSA9IHRoaXMuX2dlb0NvbXBhcmlzb24gfHwgJHdpdGhpbkNtZDtcbiAgY29uZHNbd0tleV0gPSB7fTtcbiAgY29uZHNbd0tleV1bdHlwZV0gPSBbdmFsLmNlbnRlciwgdmFsLnJhZGl1c107XG5cbiAgaWYgKCd1bmlxdWUnIGluIHZhbClcbiAgICBjb25kc1t3S2V5XS4kdW5pcXVlRG9jcyA9ICEhdmFsLnVuaXF1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRuZWFyYCBvciBgJG5lYXJTcGhlcmVgIGNvbmRpdGlvblxuICpcbiAqIFRoZXNlIG9wZXJhdG9ycyByZXR1cm4gZG9jdW1lbnRzIHNvcnRlZCBieSBkaXN0YW5jZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS5uZWFyKHsgY2VudGVyOiBbMTAsIDEwXSB9KTtcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykubmVhcih7IGNlbnRlcjogWzEwLCAxMF0sIG1heERpc3RhbmNlOiA1IH0pO1xuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS5uZWFyKHsgY2VudGVyOiBbMTAsIDEwXSwgbWF4RGlzdGFuY2U6IDUsIHNwaGVyaWNhbDogdHJ1ZSB9KTtcbiAqICAgICBxdWVyeS5uZWFyKCdsb2MnLCB7IGNlbnRlcjogWzEwLCAxMF0sIG1heERpc3RhbmNlOiA1IH0pO1xuICogICAgIHF1ZXJ5Lm5lYXIoeyBjZW50ZXI6IHsgdHlwZTogJ1BvaW50JywgY29vcmRpbmF0ZXM6IFsuLl0gfX0pXG4gKiAgICAgcXVlcnkubmVhcigpLmdlb21ldHJ5KHsgdHlwZTogJ1BvaW50JywgY29vcmRpbmF0ZXM6IFsuLl0gfSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9HZW9zcGF0aWFsK0luZGV4aW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5uZWFyID0gZnVuY3Rpb24gbmVhcigpIHtcbiAgbGV0IHBhdGgsIHZhbDtcblxuICB0aGlzLl9nZW9Db21wYXJpc29uID0gJyRuZWFyJztcblxuICBpZiAoMCA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2UgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCduZWFyJyk7XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgdmFsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBpZiAoIXZhbC5jZW50ZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NlbnRlciBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zW3BhdGhdIHx8ICh0aGlzLl9jb25kaXRpb25zW3BhdGhdID0ge30pO1xuXG4gIGNvbnN0IHR5cGUgPSB2YWwuc3BoZXJpY2FsXG4gICAgPyAnJG5lYXJTcGhlcmUnXG4gICAgOiAnJG5lYXInO1xuXG4gIC8vIGNlbnRlciBjb3VsZCBiZSBhIEdlb0pTT04gb2JqZWN0IG9yIGFuIEFycmF5XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbC5jZW50ZXIpKSB7XG4gICAgY29uZHNbdHlwZV0gPSB2YWwuY2VudGVyO1xuXG4gICAgY29uc3QgcmFkaXVzID0gJ21heERpc3RhbmNlJyBpbiB2YWxcbiAgICAgID8gdmFsLm1heERpc3RhbmNlXG4gICAgICA6IG51bGw7XG5cbiAgICBpZiAobnVsbCAhPSByYWRpdXMpIHtcbiAgICAgIGNvbmRzLiRtYXhEaXN0YW5jZSA9IHJhZGl1cztcbiAgICB9XG4gICAgaWYgKG51bGwgIT0gdmFsLm1pbkRpc3RhbmNlKSB7XG4gICAgICBjb25kcy4kbWluRGlzdGFuY2UgPSB2YWwubWluRGlzdGFuY2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEdlb0pTT04/XG4gICAgaWYgKHZhbC5jZW50ZXIudHlwZSAhPSAnUG9pbnQnIHx8ICFBcnJheS5pc0FycmF5KHZhbC5jZW50ZXIuY29vcmRpbmF0ZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbC5mb3JtYXQoJ0ludmFsaWQgR2VvSlNPTiBzcGVjaWZpZWQgZm9yICVzJywgdHlwZSkpO1xuICAgIH1cbiAgICBjb25kc1t0eXBlXSA9IHsgJGdlb21ldHJ5OiB2YWwuY2VudGVyIH07XG5cbiAgICAvLyBNb25nb0RCIDIuNiBpbnNpc3RzIG9uIG1heERpc3RhbmNlIGJlaW5nIGluICRuZWFyIC8gJG5lYXJTcGhlcmVcbiAgICBpZiAoJ21heERpc3RhbmNlJyBpbiB2YWwpIHtcbiAgICAgIGNvbmRzW3R5cGVdWyckbWF4RGlzdGFuY2UnXSA9IHZhbC5tYXhEaXN0YW5jZTtcbiAgICB9XG4gICAgaWYgKCdtaW5EaXN0YW5jZScgaW4gdmFsKSB7XG4gICAgICBjb25kc1t0eXBlXVsnJG1pbkRpc3RhbmNlJ10gPSB2YWwubWluRGlzdGFuY2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlY2xhcmVzIGFuIGludGVyc2VjdHMgcXVlcnkgZm9yIGBnZW9tZXRyeSgpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdwYXRoJykuaW50ZXJzZWN0cygpLmdlb21ldHJ5KHtcbiAqICAgICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnXG4gKiAgICAgICAsIGNvb3JkaW5hdGVzOiBbWzE4MC4wLCAxMS4wXSwgWzE4MCwgOS4wXV1cbiAqICAgICB9KVxuICpcbiAqICAgICBxdWVyeS53aGVyZSgncGF0aCcpLmludGVyc2VjdHMoe1xuICogICAgICAgICB0eXBlOiAnTGluZVN0cmluZydcbiAqICAgICAgICwgY29vcmRpbmF0ZXM6IFtbMTgwLjAsIDExLjBdLCBbMTgwLCA5LjBdXVxuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFthcmddXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIGludGVyc2VjdHMoKSB7XG4gIC8vIG9waW5pb25hdGVkLCBtdXN0IGJlIHVzZWQgYWZ0ZXIgd2hlcmVcbiAgdGhpcy5fZW5zdXJlUGF0aCgnaW50ZXJzZWN0cycpO1xuXG4gIHRoaXMuX2dlb0NvbXBhcmlzb24gPSAnJGdlb0ludGVyc2VjdHMnO1xuXG4gIGlmICgwID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb25zdCBhcmVhID0gYXJndW1lbnRzWzBdO1xuXG4gIGlmIChudWxsICE9IGFyZWEgJiYgYXJlYS50eXBlICYmIGFyZWEuY29vcmRpbmF0ZXMpXG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkoYXJlYSk7XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJGdlb21ldHJ5YCBjb25kaXRpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHZhciBwb2x5QSA9IFtbWyAxMCwgMjAgXSwgWyAxMCwgNDAgXSwgWyAzMCwgNDAgXSwgWyAzMCwgMjAgXV1dXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmdlb21ldHJ5KHsgdHlwZTogJ1BvbHlnb24nLCBjb29yZGluYXRlczogcG9seUEgfSlcbiAqXG4gKiAgICAgLy8gb3JcbiAqICAgICB2YXIgcG9seUIgPSBbWyAwLCAwIF0sIFsgMSwgMSBdXVxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5nZW9tZXRyeSh7IHR5cGU6ICdMaW5lU3RyaW5nJywgY29vcmRpbmF0ZXM6IHBvbHlCIH0pXG4gKlxuICogICAgIC8vIG9yXG4gKiAgICAgdmFyIHBvbHlDID0gWyAwLCAwIF1cbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKCkuZ2VvbWV0cnkoeyB0eXBlOiAnUG9pbnQnLCBjb29yZGluYXRlczogcG9seUMgfSlcbiAqXG4gKiAgICAgLy8gb3JcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykuaW50ZXJzZWN0cygpLmdlb21ldHJ5KHsgdHlwZTogJ1BvaW50JywgY29vcmRpbmF0ZXM6IHBvbHlDIH0pXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIGBnZW9tZXRyeSgpYCAqKm11c3QqKiBjb21lIGFmdGVyIGVpdGhlciBgaW50ZXJzZWN0cygpYCBvciBgd2l0aGluKClgLlxuICpcbiAqIFRoZSBgb2JqZWN0YCBhcmd1bWVudCBtdXN0IGNvbnRhaW4gYHR5cGVgIGFuZCBgY29vcmRpbmF0ZXNgIHByb3BlcnRpZXMuXG4gKiAtIHR5cGUge1N0cmluZ31cbiAqIC0gY29vcmRpbmF0ZXMge0FycmF5fVxuICpcbiAqIFRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE11c3QgY29udGFpbiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBpcyBhIFN0cmluZyBhbmQgYSBgY29vcmRpbmF0ZXNgIHByb3BlcnR5IHdoaWNoIGlzIGFuIEFycmF5LiBTZWUgdGhlIGV4YW1wbGVzLlxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgaHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL3JlbGVhc2Utbm90ZXMvMi40LyNuZXctZ2Vvc3BhdGlhbC1pbmRleGVzLXdpdGgtZ2VvanNvbi1hbmQtaW1wcm92ZWQtc3BoZXJpY2FsLWdlb21ldHJ5XG4gKiBAc2VlIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0dlb3NwYXRpYWwrSW5kZXhpbmdcbiAqIEBzZWUgJGdlb21ldHJ5IGh0dHA6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvZ2VvbWV0cnkvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5nZW9tZXRyeSA9IGZ1bmN0aW9uIGdlb21ldHJ5KCkge1xuICBpZiAoISgnJHdpdGhpbicgPT0gdGhpcy5fZ2VvQ29tcGFyaXNvbiB8fFxuICAgICAgICAnJGdlb1dpdGhpbicgPT0gdGhpcy5fZ2VvQ29tcGFyaXNvbiB8fFxuICAgICAgICAnJG5lYXInID09IHRoaXMuX2dlb0NvbXBhcmlzb24gfHxcbiAgICAgICAgJyRnZW9JbnRlcnNlY3RzJyA9PSB0aGlzLl9nZW9Db21wYXJpc29uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2VvbWV0cnkoKSBtdXN0IGNvbWUgYWZ0ZXIgYHdpdGhpbigpYCwgYGludGVyc2VjdHMoKWAsIG9yIGBuZWFyKCknKTtcbiAgfVxuXG4gIGxldCB2YWwsIHBhdGg7XG5cbiAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdnZW9tZXRyeScpO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIHZhbCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBpZiAoISh2YWwudHlwZSAmJiBBcnJheS5pc0FycmF5KHZhbC5jb29yZGluYXRlcykpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zW3BhdGhdIHx8ICh0aGlzLl9jb25kaXRpb25zW3BhdGhdID0ge30pO1xuICBjb25kc1t0aGlzLl9nZW9Db21wYXJpc29uXSA9IHsgJGdlb21ldHJ5OiB2YWwgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVuZCBzcGF0aWFsXG5cbi8qKlxuICogU3BlY2lmaWVzIHdoaWNoIGRvY3VtZW50IGZpZWxkcyB0byBpbmNsdWRlIG9yIGV4Y2x1ZGVcbiAqXG4gKiAjIyMjIFN0cmluZyBzeW50YXhcbiAqXG4gKiBXaGVuIHBhc3NpbmcgYSBzdHJpbmcsIHByZWZpeGluZyBhIHBhdGggd2l0aCBgLWAgd2lsbCBmbGFnIHRoYXQgcGF0aCBhcyBleGNsdWRlZC4gV2hlbiBhIHBhdGggZG9lcyBub3QgaGF2ZSB0aGUgYC1gIHByZWZpeCwgaXQgaXMgaW5jbHVkZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBpbmNsdWRlIGEgYW5kIGIsIGV4Y2x1ZGUgY1xuICogICAgIHF1ZXJ5LnNlbGVjdCgnYSBiIC1jJyk7XG4gKlxuICogICAgIC8vIG9yIHlvdSBtYXkgdXNlIG9iamVjdCBub3RhdGlvbiwgdXNlZnVsIHdoZW5cbiAqICAgICAvLyB5b3UgaGF2ZSBrZXlzIGFscmVhZHkgcHJlZml4ZWQgd2l0aCBhIFwiLVwiXG4gKiAgICAgcXVlcnkuc2VsZWN0KHthOiAxLCBiOiAxLCBjOiAwfSk7XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBhcmdcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIFNjaGVtYVR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIHNlbGVjdCgpIHtcbiAgbGV0IGFyZyA9IGFyZ3VtZW50c1swXTtcbiAgaWYgKCFhcmcpIHJldHVybiB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdDogc2VsZWN0IG9ubHkgdGFrZXMgMSBhcmd1bWVudCcpO1xuICB9XG5cbiAgdGhpcy5fdmFsaWRhdGUoJ3NlbGVjdCcpO1xuXG4gIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkcyB8fCAodGhpcy5fZmllbGRzID0ge30pO1xuICBjb25zdCB0eXBlID0gdHlwZW9mIGFyZztcbiAgbGV0IGksIGxlbjtcblxuICBpZiAoKCdzdHJpbmcnID09IHR5cGUgfHwgdXRpbHMuaXNBcmd1bWVudHNPYmplY3QoYXJnKSkgJiZcbiAgICAnbnVtYmVyJyA9PSB0eXBlb2YgYXJnLmxlbmd0aCB8fCBBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICBpZiAoJ3N0cmluZycgPT0gdHlwZSlcbiAgICAgIGFyZyA9IGFyZy5zcGxpdCgvXFxzKy8pO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gYXJnLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBsZXQgZmllbGQgPSBhcmdbaV07XG4gICAgICBpZiAoIWZpZWxkKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IGluY2x1ZGUgPSAnLScgPT0gZmllbGRbMF0gPyAwIDogMTtcbiAgICAgIGlmIChpbmNsdWRlID09PSAwKSBmaWVsZCA9IGZpZWxkLnN1YnN0cmluZygxKTtcbiAgICAgIGZpZWxkc1tmaWVsZF0gPSBpbmNsdWRlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzT2JqZWN0KGFyZykpIHtcbiAgICBjb25zdCBrZXlzID0gdXRpbHMua2V5cyhhcmcpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBmaWVsZHNba2V5c1tpXV0gPSBhcmdba2V5c1tpXV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzZWxlY3QoKSBhcmd1bWVudC4gTXVzdCBiZSBzdHJpbmcgb3Igb2JqZWN0LicpO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkc2xpY2UgY29uZGl0aW9uIGZvciBhIGBwYXRoYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuc2xpY2UoJ2NvbW1lbnRzJywgNSlcbiAqICAgICBxdWVyeS5zbGljZSgnY29tbWVudHMnLCAtNSlcbiAqICAgICBxdWVyeS5zbGljZSgnY29tbWVudHMnLCBbMTAsIDVdKVxuICogICAgIHF1ZXJ5LndoZXJlKCdjb21tZW50cycpLnNsaWNlKDUpXG4gKiAgICAgcXVlcnkud2hlcmUoJ2NvbW1lbnRzJykuc2xpY2UoWy0xMCwgNV0pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbCBudW1iZXIvcmFuZ2Ugb2YgZWxlbWVudHMgdG8gc2xpY2VcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvUmV0cmlldmluZythK1N1YnNldCtvZitGaWVsZHMjUmV0cmlldmluZ2FTdWJzZXRvZkZpZWxkcy1SZXRyaWV2aW5nYVN1YnJhbmdlb2ZBcnJheUVsZW1lbnRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoMCA9PT0gYXJndW1lbnRzLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcztcblxuICB0aGlzLl92YWxpZGF0ZSgnc2xpY2UnKTtcblxuICBsZXQgcGF0aCwgdmFsO1xuXG4gIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY29uc3QgYXJnID0gYXJndW1lbnRzWzBdO1xuICAgIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXJnKTtcbiAgICAgIGNvbnN0IG51bUtleXMgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtS2V5czsgKytpKSB7XG4gICAgICAgIHRoaXMuc2xpY2Uoa2V5c1tpXSwgYXJnW2tleXNbaV1dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdzbGljZScpO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIHZhbCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmICgyID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgYXJndW1lbnRzWzBdKSB7XG4gICAgICB0aGlzLl9lbnN1cmVQYXRoKCdzbGljZScpO1xuICAgICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgICB2YWwgPSBbYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV1dO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFsID0gYXJndW1lbnRzWzFdO1xuICAgIH1cbiAgfSBlbHNlIGlmICgzID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWwgPSBbYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl1dO1xuICB9XG5cbiAgY29uc3QgbXlGaWVsZHMgPSB0aGlzLl9maWVsZHMgfHwgKHRoaXMuX2ZpZWxkcyA9IHt9KTtcbiAgbXlGaWVsZHNbcGF0aF0gPSB7ICRzbGljZTogdmFsIH07XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzb3J0IG9yZGVyXG4gKlxuICogSWYgYW4gb2JqZWN0IGlzIHBhc3NlZCwgdmFsdWVzIGFsbG93ZWQgYXJlICdhc2MnLCAnZGVzYycsICdhc2NlbmRpbmcnLCAnZGVzY2VuZGluZycsIDEsIGFuZCAtMS5cbiAqXG4gKiBJZiBhIHN0cmluZyBpcyBwYXNzZWQsIGl0IG11c3QgYmUgYSBzcGFjZSBkZWxpbWl0ZWQgbGlzdCBvZiBwYXRoIG5hbWVzLiBUaGUgc29ydCBvcmRlciBvZiBlYWNoIHBhdGggaXMgYXNjZW5kaW5nIHVubGVzcyB0aGUgcGF0aCBuYW1lIGlzIHByZWZpeGVkIHdpdGggYC1gIHdoaWNoIHdpbGwgYmUgdHJlYXRlZCBhcyBkZXNjZW5kaW5nLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gdGhlc2UgYXJlIGVxdWl2YWxlbnRcbiAqICAgICBxdWVyeS5zb3J0KHsgZmllbGQ6ICdhc2MnLCB0ZXN0OiAtMSB9KTtcbiAqICAgICBxdWVyeS5zb3J0KCdmaWVsZCAtdGVzdCcpO1xuICogICAgIHF1ZXJ5LnNvcnQoW1snZmllbGQnLCAxXSwgWyd0ZXN0JywgLTFdXSk7XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqICAtIFRoZSBhcnJheSBzeW50YXggYC5zb3J0KFtbJ2ZpZWxkJywgMV0sIFsndGVzdCcsIC0xXV0pYCBjYW4gb25seSBiZSB1c2VkIHdpdGggW21vbmdvZGIgZHJpdmVyID49IDIuMC40Nl0oaHR0cHM6Ly9naXRodWIuY29tL21vbmdvZGIvbm9kZS1tb25nb2RiLW5hdGl2ZS9ibG9iLzIuMS9ISVNUT1JZLm1kIzIwNDYtMjAxNS0xMC0xNSkuXG4gKiAgLSBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xBcnJheX0gYXJnXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKGFyZykge1xuICBpZiAoIWFyZykgcmV0dXJuIHRoaXM7XG4gIGxldCBpLCBsZW4sIGZpZWxkO1xuXG4gIHRoaXMuX3ZhbGlkYXRlKCdzb3J0Jyk7XG5cbiAgY29uc3QgdHlwZSA9IHR5cGVvZiBhcmc7XG5cbiAgLy8gLnNvcnQoW1snZmllbGQnLCAxXSwgWyd0ZXN0JywgLTFdXSlcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgIGxlbiA9IGFyZy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyZy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ1tpXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNvcnQoKSBhcmd1bWVudCwgbXVzdCBiZSBhcnJheSBvZiBhcnJheXMnKTtcbiAgICAgIH1cbiAgICAgIF9wdXNoQXJyKHRoaXMub3B0aW9ucywgYXJnW2ldWzBdLCBhcmdbaV1bMV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIC5zb3J0KCdmaWVsZCAtdGVzdCcpXG4gIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoICYmICdzdHJpbmcnID09IHR5cGUpIHtcbiAgICBhcmcgPSBhcmcuc3BsaXQoL1xccysvKTtcbiAgICBsZW4gPSBhcmcubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgZmllbGQgPSBhcmdbaV07XG4gICAgICBpZiAoIWZpZWxkKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IGFzY2VuZCA9ICctJyA9PSBmaWVsZFswXSA/IC0xIDogMTtcbiAgICAgIGlmIChhc2NlbmQgPT09IC0xKSBmaWVsZCA9IGZpZWxkLnN1YnN0cmluZygxKTtcbiAgICAgIHB1c2godGhpcy5vcHRpb25zLCBmaWVsZCwgYXNjZW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIC5zb3J0KHsgZmllbGQ6IDEsIHRlc3Q6IC0xIH0pXG4gIGlmICh1dGlscy5pc09iamVjdChhcmcpKSB7XG4gICAgY29uc3Qga2V5cyA9IHV0aWxzLmtleXMoYXJnKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgZmllbGQgPSBrZXlzW2ldO1xuICAgICAgcHVzaCh0aGlzLm9wdGlvbnMsIGZpZWxkLCBhcmdbZmllbGRdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICh0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJyAmJiBhcmcgaW5zdGFuY2VvZiBNYXApIHtcbiAgICBfcHVzaE1hcCh0aGlzLm9wdGlvbnMsIGFyZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzb3J0KCkgYXJndW1lbnQuIE11c3QgYmUgYSBzdHJpbmcsIG9iamVjdCwgb3IgYXJyYXkuJyk7XG59O1xuXG4vKiFcbiAqIEBpZ25vcmVcbiAqL1xuXG5jb25zdCBfdmFsaWRTb3J0VmFsdWUgPSB7XG4gIDE6IDEsXG4gICctMSc6IC0xLFxuICBhc2M6IDEsXG4gIGFzY2VuZGluZzogMSxcbiAgZGVzYzogLTEsXG4gIGRlc2NlbmRpbmc6IC0xXG59O1xuXG5mdW5jdGlvbiBwdXNoKG9wdHMsIGZpZWxkLCB2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShvcHRzLnNvcnQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2FuXFwndCBtaXggc29ydCBzeW50YXhlcy4gVXNlIGVpdGhlciBhcnJheSBvciBvYmplY3Q6JyArXG4gICAgICAnXFxuLSBgLnNvcnQoW1tcXCdmaWVsZFxcJywgMV0sIFtcXCd0ZXN0XFwnLCAtMV1dKWAnICtcbiAgICAgICdcXG4tIGAuc29ydCh7IGZpZWxkOiAxLCB0ZXN0OiAtMSB9KWAnKTtcbiAgfVxuXG4gIGxldCBzO1xuICBpZiAodmFsdWUgJiYgdmFsdWUuJG1ldGEpIHtcbiAgICBzID0gb3B0cy5zb3J0IHx8IChvcHRzLnNvcnQgPSB7fSk7XG4gICAgc1tmaWVsZF0gPSB7ICRtZXRhOiB2YWx1ZS4kbWV0YSB9O1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHMgPSBvcHRzLnNvcnQgfHwgKG9wdHMuc29ydCA9IHt9KTtcbiAgbGV0IHZhbCA9IFN0cmluZyh2YWx1ZSB8fCAxKS50b0xvd2VyQ2FzZSgpO1xuICB2YWwgPSBfdmFsaWRTb3J0VmFsdWVbdmFsXTtcbiAgaWYgKCF2YWwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc29ydCB2YWx1ZTogeyAnICsgZmllbGQgKyAnOiAnICsgdmFsdWUgKyAnIH0nKTtcblxuICBzW2ZpZWxkXSA9IHZhbDtcbn1cblxuZnVuY3Rpb24gX3B1c2hBcnIob3B0cywgZmllbGQsIHZhbHVlKSB7XG4gIG9wdHMuc29ydCA9IG9wdHMuc29ydCB8fCBbXTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG9wdHMuc29ydCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5cXCd0IG1peCBzb3J0IHN5bnRheGVzLiBVc2UgZWl0aGVyIGFycmF5IG9yIG9iamVjdDonICtcbiAgICAgICdcXG4tIGAuc29ydChbW1xcJ2ZpZWxkXFwnLCAxXSwgW1xcJ3Rlc3RcXCcsIC0xXV0pYCcgK1xuICAgICAgJ1xcbi0gYC5zb3J0KHsgZmllbGQ6IDEsIHRlc3Q6IC0xIH0pYCcpO1xuICB9XG5cbiAgbGV0IHZhbCA9IFN0cmluZyh2YWx1ZSB8fCAxKS50b0xvd2VyQ2FzZSgpO1xuICB2YWwgPSBfdmFsaWRTb3J0VmFsdWVbdmFsXTtcbiAgaWYgKCF2YWwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc29ydCB2YWx1ZTogWyAnICsgZmllbGQgKyAnLCAnICsgdmFsdWUgKyAnIF0nKTtcblxuICBvcHRzLnNvcnQucHVzaChbZmllbGQsIHZhbF0pO1xufVxuXG5mdW5jdGlvbiBfcHVzaE1hcChvcHRzLCBtYXApIHtcbiAgb3B0cy5zb3J0ID0gb3B0cy5zb3J0IHx8IG5ldyBNYXAoKTtcbiAgaWYgKCEob3B0cy5zb3J0IGluc3RhbmNlb2YgTWFwKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NhblxcJ3QgbWl4IHNvcnQgc3ludGF4ZXMuIFVzZSBlaXRoZXIgYXJyYXkgb3IgJyArXG4gICAgICAnb2JqZWN0IG9yIG1hcCBjb25zaXN0ZW50bHknKTtcbiAgfVxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgbGV0IHZhbCA9IFN0cmluZyh2YWx1ZSB8fCAxKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IF92YWxpZFNvcnRWYWx1ZVt2YWxdO1xuICAgIGlmICghdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNvcnQgdmFsdWU6IDwgJyArIGtleSArICc6ICcgKyB2YWx1ZSArICcgPicpO1xuXG4gICAgb3B0cy5zb3J0LnNldChrZXksIHZhbCk7XG4gIH0pO1xufVxuXG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBsaW1pdCBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5saW1pdCgyMClcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAbWV0aG9kIGxpbWl0XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lN0IlN0JsaW1pdCUyOCUyOSU3RCU3RFxuICogQGFwaSBwdWJsaWNcbiAqL1xuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIHNraXAgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuc2tpcCgxMDApLmxpbWl0KDIwKVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBtZXRob2Qgc2tpcFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTdCJTdCc2tpcCUyOCUyOSU3RCU3RFxuICogQGFwaSBwdWJsaWNcbiAqL1xuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGJhdGNoU2l6ZSBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5iYXRjaFNpemUoMTAwKVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBtZXRob2QgYmF0Y2hTaXplXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lN0IlN0JiYXRjaFNpemUlMjglMjklN0QlN0RcbiAqIEBhcGkgcHVibGljXG4gKi9cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBgY29tbWVudGAgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuY29tbWVudCgnbG9naW4gcXVlcnknKVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBtZXRob2QgY29tbWVudFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTI0Y29tbWVudFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKiFcbiAqIGxpbWl0LCBza2lwLCBiYXRjaFNpemUsIGNvbW1lbnRcbiAqXG4gKiBTZXRzIHRoZXNlIGFzc29jaWF0ZWQgb3B0aW9ucy5cbiAqXG4gKiAgICAgcXVlcnkuY29tbWVudCgnZmVlZCBxdWVyeScpO1xuICovXG5cblsnbGltaXQnLCAnc2tpcCcsICdiYXRjaFNpemUnLCAnY29tbWVudCddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIFF1ZXJ5LnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odikge1xuICAgIHRoaXMuX3ZhbGlkYXRlKG1ldGhvZCk7XG4gICAgdGhpcy5vcHRpb25zW21ldGhvZF0gPSB2O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufSk7XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBtYXhUaW1lTVMgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkubWF4VGltZSgxMDApXG4gKiAgICAgcXVlcnkubWF4VGltZU1TKDEwMClcbiAqXG4gKiBAbWV0aG9kIG1heFRpbWVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9tZXRhL21heFRpbWVNUy8jb3AuX1NfbWF4VGltZU1TXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5tYXhUaW1lID0gUXVlcnkucHJvdG90eXBlLm1heFRpbWVNUyA9IGZ1bmN0aW9uKG1zKSB7XG4gIHRoaXMuX3ZhbGlkYXRlKCdtYXhUaW1lJyk7XG4gIHRoaXMub3B0aW9ucy5tYXhUaW1lTVMgPSBtcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgcXVlcnkgaGludHMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5oaW50KHsgaW5kZXhBOiAxLCBpbmRleEI6IC0xfSk7XG4gKiAgICAgcXVlcnkuaGludCgnaW5kZXhBXzFfaW5kZXhCXzEnKTtcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IHZhbCBhIGhpbnQgb2JqZWN0IG9yIHRoZSBpbmRleCBuYW1lXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSUyNGhpbnRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmhpbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKDAgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzO1xuXG4gIHRoaXMuX3ZhbGlkYXRlKCdoaW50Jyk7XG5cbiAgY29uc3QgYXJnID0gYXJndW1lbnRzWzBdO1xuICBpZiAodXRpbHMuaXNPYmplY3QoYXJnKSkge1xuICAgIGNvbnN0IGhpbnQgPSB0aGlzLm9wdGlvbnMuaGludCB8fCAodGhpcy5vcHRpb25zLmhpbnQgPSB7fSk7XG5cbiAgICAvLyBtdXN0IGtlZXAgb2JqZWN0IGtleXMgaW4gb3JkZXIgc28gZG9uJ3QgdXNlIE9iamVjdC5rZXlzKClcbiAgICBmb3IgKGNvbnN0IGsgaW4gYXJnKSB7XG4gICAgICBoaW50W2tdID0gYXJnW2tdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMub3B0aW9ucy5oaW50ID0gYXJnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoaW50LiAnICsgYXJnKTtcbn07XG5cbi8qKlxuICogUmVxdWVzdHMgYWNrbm93bGVkZ2VtZW50IHRoYXQgdGhpcyBvcGVyYXRpb24gaGFzIGJlZW4gcGVyc2lzdGVkIHRvIE1vbmdvREInc1xuICogb24tZGlzayBqb3VybmFsLlxuICogVGhpcyBvcHRpb24gaXMgb25seSB2YWxpZCBmb3Igb3BlcmF0aW9ucyB0aGF0IHdyaXRlIHRvIHRoZSBkYXRhYmFzZTpcbiAqXG4gKiAtIGBkZWxldGVPbmUoKWBcbiAqIC0gYGRlbGV0ZU1hbnkoKWBcbiAqIC0gYGZpbmRPbmVBbmREZWxldGUoKWBcbiAqIC0gYGZpbmRPbmVBbmRVcGRhdGUoKWBcbiAqIC0gYHVwZGF0ZU9uZSgpYFxuICogLSBgdXBkYXRlTWFueSgpYFxuICpcbiAqIERlZmF1bHRzIHRvIHRoZSBgamAgdmFsdWUgaWYgaXQgaXMgc3BlY2lmaWVkIGluIHdyaXRlQ29uY2VybiBvcHRpb25zXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBtcXVlcnkoKS53KDIpLmoodHJ1ZSkud3RpbWVvdXQoMjAwMCk7XG4gKlxuICogQG1ldGhvZCBqXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtib29sZWFufSB2YWxcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL2RvY3MubW9uZ29kYi5jb20vbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyNqLW9wdGlvblxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmogPSBmdW5jdGlvbiBqKHZhbCkge1xuICB0aGlzLm9wdGlvbnMuaiA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHNsYXZlT2sgb3B0aW9uLiBfRGVwcmVjYXRlZF8gaW4gTW9uZ29EQiAyLjIgaW4gZmF2b3Igb2YgcmVhZCBwcmVmZXJlbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LnNsYXZlT2soKSAvLyB0cnVlXG4gKiAgICAgcXVlcnkuc2xhdmVPayh0cnVlKVxuICogICAgIHF1ZXJ5LnNsYXZlT2soZmFsc2UpXG4gKlxuICogQGRlcHJlY2F0ZWQgdXNlIHJlYWQoKSBwcmVmZXJlbmNlcyBpbnN0ZWFkIGlmIG9uIG1vbmdvZGIgPj0gMi4yXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHYgZGVmYXVsdHMgdG8gdHJ1ZVxuICogQHNlZSBtb25nb2RiIGh0dHA6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9hcHBsaWNhdGlvbnMvcmVwbGljYXRpb24vI3JlYWQtcHJlZmVyZW5jZVxuICogQHNlZSByZWFkKClcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zbGF2ZU9rID0gZnVuY3Rpb24odikge1xuICB0aGlzLm9wdGlvbnMuc2xhdmVPayA9IGFyZ3VtZW50cy5sZW5ndGggPyAhIXYgOiB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcmVhZFByZWZlcmVuY2Ugb3B0aW9uIGZvciB0aGUgcXVlcnkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdwcmltYXJ5JylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdwJykgIC8vIHNhbWUgYXMgcHJpbWFyeVxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdwcmltYXJ5UHJlZmVycmVkJylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdwcCcpIC8vIHNhbWUgYXMgcHJpbWFyeVByZWZlcnJlZFxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdzZWNvbmRhcnknKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3MnKSAgLy8gc2FtZSBhcyBzZWNvbmRhcnlcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgnc2Vjb25kYXJ5UHJlZmVycmVkJylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdzcCcpIC8vIHNhbWUgYXMgc2Vjb25kYXJ5UHJlZmVycmVkXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ25lYXJlc3QnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ24nKSAgLy8gc2FtZSBhcyBuZWFyZXN0XG4gKlxuICogICAgIC8vIHlvdSBjYW4gYWxzbyB1c2UgbW9uZ29kYi5SZWFkUHJlZmVyZW5jZSBjbGFzcyB0byBhbHNvIHNwZWNpZnkgdGFnc1xuICogICAgIG5ldyBRdWVyeSgpLnJlYWQobW9uZ29kYi5SZWFkUHJlZmVyZW5jZSgnc2Vjb25kYXJ5JywgW3sgZGM6J3NmJywgczogMSB9LHsgZGM6J21hJywgczogMiB9XSkpXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnNldFJlYWRQcmVmZXJlbmNlKCdwcmltYXJ5JykgLy8gYWxpYXMgb2YgLnJlYWQoKVxuICpcbiAqICMjIyMgUHJlZmVyZW5jZXM6XG4gKlxuICogICAgIHByaW1hcnkgLSAoZGVmYXVsdCkgIFJlYWQgZnJvbSBwcmltYXJ5IG9ubHkuIE9wZXJhdGlvbnMgd2lsbCBwcm9kdWNlIGFuIGVycm9yIGlmIHByaW1hcnkgaXMgdW5hdmFpbGFibGUuIENhbm5vdCBiZSBjb21iaW5lZCB3aXRoIHRhZ3MuXG4gKiAgICAgc2Vjb25kYXJ5ICAgICAgICAgICAgUmVhZCBmcm9tIHNlY29uZGFyeSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBlcnJvci5cbiAqICAgICBwcmltYXJ5UHJlZmVycmVkICAgICBSZWFkIGZyb20gcHJpbWFyeSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBhIHNlY29uZGFyeS5cbiAqICAgICBzZWNvbmRhcnlQcmVmZXJyZWQgICBSZWFkIGZyb20gYSBzZWNvbmRhcnkgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgcmVhZCBmcm9tIHRoZSBwcmltYXJ5LlxuICogICAgIG5lYXJlc3QgICAgICAgICAgICAgIEFsbCBvcGVyYXRpb25zIHJlYWQgZnJvbSBhbW9uZyB0aGUgbmVhcmVzdCBjYW5kaWRhdGVzLCBidXQgdW5saWtlIG90aGVyIG1vZGVzLCB0aGlzIG9wdGlvbiB3aWxsIGluY2x1ZGUgYm90aCB0aGUgcHJpbWFyeSBhbmQgYWxsIHNlY29uZGFyaWVzIGluIHRoZSByYW5kb20gc2VsZWN0aW9uLlxuICpcbiAqIEFsaWFzZXNcbiAqXG4gKiAgICAgcCAgIHByaW1hcnlcbiAqICAgICBwcCAgcHJpbWFyeVByZWZlcnJlZFxuICogICAgIHMgICBzZWNvbmRhcnlcbiAqICAgICBzcCAgc2Vjb25kYXJ5UHJlZmVycmVkXG4gKiAgICAgbiAgIG5lYXJlc3RcbiAqXG4gKiBSZWFkIG1vcmUgYWJvdXQgaG93IHRvIHVzZSByZWFkIHByZWZlcmVuY2VzIFtoZXJlXShodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvYXBwbGljYXRpb25zL3JlcGxpY2F0aW9uLyNyZWFkLXByZWZlcmVuY2UpIGFuZCBbaGVyZV0oaHR0cDovL21vbmdvZGIuZ2l0aHViLmNvbS9ub2RlLW1vbmdvZGItbmF0aXZlL2RyaXZlci1hcnRpY2xlcy9hbmludHJvZHVjdGlvbnRvMV8xYW5kMl8yLmh0bWwjcmVhZC1wcmVmZXJlbmNlcykuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8UmVhZFByZWZlcmVuY2V9IHByZWYgb25lIG9mIHRoZSBsaXN0ZWQgcHJlZmVyZW5jZSBvcHRpb25zIG9yIHRoZWlyIGFsaWFzZXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvYXBwbGljYXRpb25zL3JlcGxpY2F0aW9uLyNyZWFkLXByZWZlcmVuY2VcbiAqIEBzZWUgZHJpdmVyIGh0dHA6Ly9tb25nb2RiLmdpdGh1Yi5jb20vbm9kZS1tb25nb2RiLW5hdGl2ZS9kcml2ZXItYXJ0aWNsZXMvYW5pbnRyb2R1Y3Rpb250bzFfMWFuZDJfMi5odG1sI3JlYWQtcHJlZmVyZW5jZXNcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5yZWFkID0gUXVlcnkucHJvdG90eXBlLnNldFJlYWRQcmVmZXJlbmNlID0gZnVuY3Rpb24ocHJlZikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgIVF1ZXJ5LnByb3RvdHlwZS5yZWFkLmRlcHJlY2F0aW9uV2FybmluZ0lzc3VlZCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0RlcHJlY2F0aW9uIHdhcm5pbmc6IFxcJ3RhZ3NcXCcgYXJndW1lbnQgaXMgbm90IHN1cHBvcnRlZCBhbnltb3JlIGluIFF1ZXJ5LnJlYWQoKSBtZXRob2QuIFBsZWFzZSB1c2UgbW9uZ29kYi5SZWFkUHJlZmVyZW5jZSBvYmplY3QgaW5zdGVhZC4nKTtcbiAgICBRdWVyeS5wcm90b3R5cGUucmVhZC5kZXByZWNhdGlvbldhcm5pbmdJc3N1ZWQgPSB0cnVlO1xuICB9XG4gIHRoaXMub3B0aW9ucy5yZWFkUHJlZmVyZW5jZSA9IHV0aWxzLnJlYWRQcmVmKHByZWYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcmVhZENvbmNlcm4gb3B0aW9uIGZvciB0aGUgcXVlcnkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbG9jYWwnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdsJykgIC8vIHNhbWUgYXMgbG9jYWxcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ2F2YWlsYWJsZScpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ2EnKSAgLy8gc2FtZSBhcyBhdmFpbGFibGVcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ21ham9yaXR5JylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbScpICAvLyBzYW1lIGFzIG1ham9yaXR5XG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdsaW5lYXJpemFibGUnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdseicpIC8vIHNhbWUgYXMgbGluZWFyaXphYmxlXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdzbmFwc2hvdCcpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ3MnKSAgLy8gc2FtZSBhcyBzbmFwc2hvdFxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yKCdzJykgLy8gciBpcyBhbGlhcyBvZiByZWFkQ29uY2VyblxuICpcbiAqXG4gKiAjIyMjIFJlYWQgQ29uY2VybiBMZXZlbDpcbiAqXG4gKiAgICAgbG9jYWwgICAgICAgICBNb25nb0RCIDMuMisgVGhlIHF1ZXJ5IHJldHVybnMgZnJvbSB0aGUgaW5zdGFuY2Ugd2l0aCBubyBndWFyYW50ZWUgZ3VhcmFudGVlIHRoYXQgdGhlIGRhdGEgaGFzIGJlZW4gd3JpdHRlbiB0byBhIG1ham9yaXR5IG9mIHRoZSByZXBsaWNhIHNldCBtZW1iZXJzIChpLmUuIG1heSBiZSByb2xsZWQgYmFjaykuXG4gKiAgICAgYXZhaWxhYmxlICAgICBNb25nb0RCIDMuNisgVGhlIHF1ZXJ5IHJldHVybnMgZnJvbSB0aGUgaW5zdGFuY2Ugd2l0aCBubyBndWFyYW50ZWUgZ3VhcmFudGVlIHRoYXQgdGhlIGRhdGEgaGFzIGJlZW4gd3JpdHRlbiB0byBhIG1ham9yaXR5IG9mIHRoZSByZXBsaWNhIHNldCBtZW1iZXJzIChpLmUuIG1heSBiZSByb2xsZWQgYmFjaykuXG4gKiAgICAgbWFqb3JpdHkgICAgICBNb25nb0RCIDMuMisgVGhlIHF1ZXJ5IHJldHVybnMgdGhlIGRhdGEgdGhhdCBoYXMgYmVlbiBhY2tub3dsZWRnZWQgYnkgYSBtYWpvcml0eSBvZiB0aGUgcmVwbGljYSBzZXQgbWVtYmVycy4gVGhlIGRvY3VtZW50cyByZXR1cm5lZCBieSB0aGUgcmVhZCBvcGVyYXRpb24gYXJlIGR1cmFibGUsIGV2ZW4gaW4gdGhlIGV2ZW50IG9mIGZhaWx1cmUuXG4gKiAgICAgbGluZWFyaXphYmxlICBNb25nb0RCIDMuNCsgVGhlIHF1ZXJ5IHJldHVybnMgZGF0YSB0aGF0IHJlZmxlY3RzIGFsbCBzdWNjZXNzZnVsIG1ham9yaXR5LWFja25vd2xlZGdlZCB3cml0ZXMgdGhhdCBjb21wbGV0ZWQgcHJpb3IgdG8gdGhlIHN0YXJ0IG9mIHRoZSByZWFkIG9wZXJhdGlvbi4gVGhlIHF1ZXJ5IG1heSB3YWl0IGZvciBjb25jdXJyZW50bHkgZXhlY3V0aW5nIHdyaXRlcyB0byBwcm9wYWdhdGUgdG8gYSBtYWpvcml0eSBvZiByZXBsaWNhIHNldCBtZW1iZXJzIGJlZm9yZSByZXR1cm5pbmcgcmVzdWx0cy5cbiAqICAgICBzbmFwc2hvdCAgICAgIE1vbmdvREIgNC4wKyBPbmx5IGF2YWlsYWJsZSBmb3Igb3BlcmF0aW9ucyB3aXRoaW4gbXVsdGktZG9jdW1lbnQgdHJhbnNhY3Rpb25zLiBVcG9uIHRyYW5zYWN0aW9uIGNvbW1pdCB3aXRoIHdyaXRlIGNvbmNlcm4gXCJtYWpvcml0eVwiLCB0aGUgdHJhbnNhY3Rpb24gb3BlcmF0aW9ucyBhcmUgZ3VhcmFudGVlZCB0byBoYXZlIHJlYWQgZnJvbSBhIHNuYXBzaG90IG9mIG1ham9yaXR5LWNvbW1pdHRlZCBkYXRhLlxuICpcbiAqIEFsaWFzZXNcbiAqXG4gKiAgICAgbCAgIGxvY2FsXG4gKiAgICAgYSAgIGF2YWlsYWJsZVxuICogICAgIG0gICBtYWpvcml0eVxuICogICAgIGx6ICBsaW5lYXJpemFibGVcbiAqICAgICBzICAgc25hcHNob3RcbiAqXG4gKiBSZWFkIG1vcmUgYWJvdXQgaG93IHRvIHVzZSByZWFkIGNvbmNlcm4gW2hlcmVdKGh0dHBzOi8vZG9jcy5tb25nb2RiLmNvbS9tYW51YWwvcmVmZXJlbmNlL3JlYWQtY29uY2Vybi8pLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBsZXZlbCBvbmUgb2YgdGhlIGxpc3RlZCByZWFkIGNvbmNlcm4gbGV2ZWwgb3IgdGhlaXIgYWxpYXNlc1xuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vZG9jcy5tb25nb2RiLmNvbS9tYW51YWwvcmVmZXJlbmNlL3JlYWQtY29uY2Vybi9cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5yZWFkQ29uY2VybiA9IFF1ZXJ5LnByb3RvdHlwZS5yID0gZnVuY3Rpb24obGV2ZWwpIHtcbiAgdGhpcy5vcHRpb25zLnJlYWRDb25jZXJuID0gdXRpbHMucmVhZENvbmNlcm4obGV2ZWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0YWlsYWJsZSBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS50YWlsYWJsZSgpIDw9PSB0cnVlXG4gKiAgICAgcXVlcnkudGFpbGFibGUodHJ1ZSlcbiAqICAgICBxdWVyeS50YWlsYWJsZShmYWxzZSlcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHYgZGVmYXVsdHMgdG8gdHJ1ZVxuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL1RhaWxhYmxlK0N1cnNvcnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnRhaWxhYmxlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3ZhbGlkYXRlKCd0YWlsYWJsZScpO1xuXG4gIHRoaXMub3B0aW9ucy50YWlsYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICA/ICEhYXJndW1lbnRzWzBdXG4gICAgOiB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGBtb25nb2RgIHNlcnZlcnMsIG9yIHRhZyBzZXQgb2YgYG1vbmdvZGAgc2VydmVycyxcbiAqIHRoYXQgbXVzdCBhY2tub3dsZWRnZSB0aGlzIHdyaXRlIGJlZm9yZSB0aGlzIHdyaXRlIGlzIGNvbnNpZGVyZWQgc3VjY2Vzc2Z1bC5cbiAqIFRoaXMgb3B0aW9uIGlzIG9ubHkgdmFsaWQgZm9yIG9wZXJhdGlvbnMgdGhhdCB3cml0ZSB0byB0aGUgZGF0YWJhc2U6XG4gKlxuICogLSBgZGVsZXRlT25lKClgXG4gKiAtIGBkZWxldGVNYW55KClgXG4gKiAtIGBmaW5kT25lQW5kRGVsZXRlKClgXG4gKiAtIGBmaW5kT25lQW5kVXBkYXRlKClgXG4gKiAtIGB1cGRhdGVPbmUoKWBcbiAqIC0gYHVwZGF0ZU1hbnkoKWBcbiAqXG4gKiBEZWZhdWx0cyB0byB0aGUgYHdgIHZhbHVlIGlmIGl0IGlzIHNwZWNpZmllZCBpbiB3cml0ZUNvbmNlcm4gb3B0aW9uc1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbXF1ZXJ5KCkud3JpdGVDb25jZXJuKDApXG4gKiAgICAgbXF1ZXJ5KCkud3JpdGVDb25jZXJuKDEpXG4gKiAgICAgbXF1ZXJ5KCkud3JpdGVDb25jZXJuKHsgdzogMSwgajogdHJ1ZSwgd3RpbWVvdXQ6IDIwMDAgfSlcbiAqICAgICBtcXVlcnkoKS53cml0ZUNvbmNlcm4oJ21ham9yaXR5JylcbiAqICAgICBtcXVlcnkoKS53cml0ZUNvbmNlcm4oJ20nKSAvLyBzYW1lIGFzIG1ham9yaXR5XG4gKiAgICAgbXF1ZXJ5KCkud3JpdGVDb25jZXJuKCd0YWdTZXROYW1lJykgLy8gaWYgdGhlIHRhZyBzZXQgaXMgJ20nLCB1c2UgLndyaXRlQ29uY2Vybih7IHc6ICdtJyB9KSBpbnN0ZWFkXG4gKiAgICAgbXF1ZXJ5KCkudygxKSAvLyB3IGlzIGFsaWFzIG9mIHdyaXRlQ29uY2VyblxuICpcbiAqIEBtZXRob2Qgd3JpdGVDb25jZXJuXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd8bnVtYmVyfG9iamVjdH0gY29uY2VybiAwIGZvciBmaXJlLWFuZC1mb3JnZXQsIDEgZm9yIGFja25vd2xlZGdlZCBieSBvbmUgc2VydmVyLCAnbWFqb3JpdHknIGZvciBtYWpvcml0eSBvZiB0aGUgcmVwbGljYSBzZXQsIG9yIFthbnkgb2YgdGhlIG1vcmUgYWR2YW5jZWQgb3B0aW9uc10oaHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jdy1vcHRpb24pLlxuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vZG9jcy5tb25nb2RiLmNvbS9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI3ctb3B0aW9uXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUud3JpdGVDb25jZXJuID0gUXVlcnkucHJvdG90eXBlLncgPSBmdW5jdGlvbiB3cml0ZUNvbmNlcm4oY29uY2Vybikge1xuICBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBjb25jZXJuKSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgY29uY2Vybi5qKSB0aGlzLm9wdGlvbnMuaiA9IGNvbmNlcm4uajtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBjb25jZXJuLncpIHRoaXMub3B0aW9ucy53ID0gY29uY2Vybi53O1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGNvbmNlcm4ud3RpbWVvdXQpIHRoaXMub3B0aW9ucy53dGltZW91dCA9IGNvbmNlcm4ud3RpbWVvdXQ7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLncgPSAnbScgPT09IGNvbmNlcm4gPyAnbWFqb3JpdHknIDogY29uY2VybjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgdGltZSBsaW1pdCwgaW4gbWlsbGlzZWNvbmRzLCBmb3IgdGhlIHdyaXRlIGNvbmNlcm4uXG4gKiBJZiBgbXMgPiAxYCwgaXQgaXMgbWF4aW11bSBhbW91bnQgb2YgdGltZSB0byB3YWl0IGZvciB0aGlzIHdyaXRlXG4gKiB0byBwcm9wYWdhdGUgdGhyb3VnaCB0aGUgcmVwbGljYSBzZXQgYmVmb3JlIHRoaXMgb3BlcmF0aW9uIGZhaWxzLlxuICogVGhlIGRlZmF1bHQgaXMgYDBgLCB3aGljaCBtZWFucyBubyB0aW1lb3V0LlxuICpcbiAqIFRoaXMgb3B0aW9uIGlzIG9ubHkgdmFsaWQgZm9yIG9wZXJhdGlvbnMgdGhhdCB3cml0ZSB0byB0aGUgZGF0YWJhc2U6XG4gKlxuICogLSBgZGVsZXRlT25lKClgXG4gKiAtIGBkZWxldGVNYW55KClgXG4gKiAtIGBmaW5kT25lQW5kRGVsZXRlKClgXG4gKiAtIGBmaW5kT25lQW5kVXBkYXRlKClgXG4gKiAtIGB1cGRhdGVPbmUoKWBcbiAqIC0gYHVwZGF0ZU1hbnkoKWBcbiAqXG4gKiBEZWZhdWx0cyB0byBgd3RpbWVvdXRgIHZhbHVlIGlmIGl0IGlzIHNwZWNpZmllZCBpbiB3cml0ZUNvbmNlcm5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1xdWVyeSgpLncoMikuaih0cnVlKS53dGltZW91dCgyMDAwKVxuICpcbiAqIEBtZXRob2Qgd3RpbWVvdXRcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gbXMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0XG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jd3RpbWVvdXRcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS53dGltZW91dCA9IFF1ZXJ5LnByb3RvdHlwZS53VGltZW91dCA9IGZ1bmN0aW9uIHd0aW1lb3V0KG1zKSB7XG4gIHRoaXMub3B0aW9ucy53dGltZW91dCA9IG1zO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWVyZ2VzIGFub3RoZXIgUXVlcnkgb3IgY29uZGl0aW9ucyBvYmplY3QgaW50byB0aGlzIG9uZS5cbiAqXG4gKiBXaGVuIGEgUXVlcnkgaXMgcGFzc2VkLCBjb25kaXRpb25zLCBmaWVsZCBzZWxlY3Rpb24gYW5kIG9wdGlvbnMgYXJlIG1lcmdlZC5cbiAqXG4gKiBAcGFyYW0ge1F1ZXJ5fE9iamVjdH0gc291cmNlXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICBpZiAoIXNvdXJjZSlcbiAgICByZXR1cm4gdGhpcztcblxuICBpZiAoIVF1ZXJ5LmNhbk1lcmdlKHNvdXJjZSkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudC4gRXhwZWN0ZWQgaW5zdGFuY2VvZiBtcXVlcnkgb3IgcGxhaW4gb2JqZWN0Jyk7XG5cbiAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFF1ZXJ5KSB7XG4gICAgLy8gaWYgc291cmNlIGhhcyBhIGZlYXR1cmUsIGFwcGx5IGl0IHRvIG91cnNlbHZlc1xuXG4gICAgaWYgKHNvdXJjZS5fY29uZGl0aW9ucykge1xuICAgICAgdXRpbHMubWVyZ2UodGhpcy5fY29uZGl0aW9ucywgc291cmNlLl9jb25kaXRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlLl9maWVsZHMpIHtcbiAgICAgIHRoaXMuX2ZpZWxkcyB8fCAodGhpcy5fZmllbGRzID0ge30pO1xuICAgICAgdXRpbHMubWVyZ2UodGhpcy5fZmllbGRzLCBzb3VyY2UuX2ZpZWxkcyk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZS5vcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgfHwgKHRoaXMub3B0aW9ucyA9IHt9KTtcbiAgICAgIHV0aWxzLm1lcmdlKHRoaXMub3B0aW9ucywgc291cmNlLm9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UuX3VwZGF0ZURvYykge1xuICAgICAgdGhpcy5fdXBkYXRlRG9jIHx8ICh0aGlzLl91cGRhdGVEb2MgPSB7fSk7XG4gICAgICB1dGlscy5tZXJnZUNsb25lKHRoaXMuX3VwZGF0ZURvYywgc291cmNlLl91cGRhdGVEb2MpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UuX2Rpc3RpbmN0RG9jKSB7XG4gICAgICB0aGlzLl9kaXN0aW5jdERvYyA9IHNvdXJjZS5fZGlzdGluY3REb2M7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBwbGFpbiBvYmplY3RcbiAgdXRpbHMubWVyZ2UodGhpcy5fY29uZGl0aW9ucywgc291cmNlKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmluZHMgZG9jdW1lbnRzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuZmluZCgpXG4gKiAgICAgYXdhaXQgcXVlcnkuZmluZCgpXG4gKiAgICAgYXdhaXQgcXVlcnkuZmluZCh7IG5hbWU6ICdCdXJuaW5nIExpZ2h0cycgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NyaXRlcmlhXSBtb25nb2RiIHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKGNyaXRlcmlhKSB7XG4gIHRoaXMub3AgPSAnZmluZCc7XG5cbiAgaWYgKFF1ZXJ5LmNhbk1lcmdlKGNyaXRlcmlhKSkge1xuICAgIHRoaXMubWVyZ2UoY3JpdGVyaWEpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYGZpbmRgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fZmluZCA9IGFzeW5jIGZ1bmN0aW9uIF9maW5kKCkge1xuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnM7XG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuXG4gIGlmICh0aGlzLiR1c2VQcm9qZWN0aW9uKSB7XG4gICAgb3B0aW9ucy5wcm9qZWN0aW9uID0gdGhpcy5fZmllbGRzRm9yRXhlYygpO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuZmllbGRzID0gdGhpcy5fZmllbGRzRm9yRXhlYygpO1xuICB9XG5cbiAgZGVidWcoJ19maW5kJywgdGhpcy5fY29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSwgY29uZHMsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmZpbmQoY29uZHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBxdWVyeSBjdXJzb3JcbiAqXG4gKiAjIyMjIEV4YW1wbGVzOlxuICpcbiAqICAgICBxdWVyeS5maW5kKCkuY3Vyc29yKCk7XG4gKiAgICAgcXVlcnkuY3Vyc29yKHsgbmFtZTogJ0J1cm5pbmcgTGlnaHRzJyB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NyaXRlcmlhXSBtb25nb2RiIHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtPYmplY3R9IGN1cnNvclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY3Vyc29yID0gZnVuY3Rpb24gY3Vyc29yKGNyaXRlcmlhKSB7XG4gIGlmICh0aGlzLm9wKSB7XG4gICAgaWYgKHRoaXMub3AgIT09ICdmaW5kJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignLmN1cnNvciBvbmx5IHN1cHBvcnQgLmZpbmQgbWV0aG9kJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuZmluZChjcml0ZXJpYSk7XG4gIH1cblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnM7XG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuXG4gIGlmICh0aGlzLiR1c2VQcm9qZWN0aW9uKSB7XG4gICAgb3B0aW9ucy5wcm9qZWN0aW9uID0gdGhpcy5fZmllbGRzRm9yRXhlYygpO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuZmllbGRzID0gdGhpcy5fZmllbGRzRm9yRXhlYygpO1xuICB9XG5cbiAgZGVidWcoJ2ZpbmRDdXJzb3InLCB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBjb25kcywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmZpbmRDdXJzb3IoY29uZHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcXVlcnkgYXMgYSBmaW5kT25lKCkgb3BlcmF0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuZmluZE9uZSgpLndoZXJlKCduYW1lJywgL15CdXJuaW5nLyk7XG4gKlxuICogICAgIHF1ZXJ5LmZpbmRPbmUoeyBuYW1lOiAvXkJ1cm5pbmcvIH0pXG4gKlxuICogICAgIGF3YWl0IHF1ZXJ5LmZpbmRPbmUoeyBuYW1lOiAvXkJ1cm5pbmcvIH0pOyAvLyBleGVjdXRlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFF1ZXJ5fSBbY3JpdGVyaWFdIG1vbmdvZGIgc2VsZWN0b3JcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5maW5kT25lID0gZnVuY3Rpb24oY3JpdGVyaWEpIHtcbiAgdGhpcy5vcCA9ICdmaW5kT25lJztcblxuICBpZiAoUXVlcnkuY2FuTWVyZ2UoY3JpdGVyaWEpKSB7XG4gICAgdGhpcy5tZXJnZShjcml0ZXJpYSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgZmluZE9uZWAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fZmluZE9uZSA9IGFzeW5jIGZ1bmN0aW9uIF9maW5kT25lKCkge1xuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnM7XG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuXG4gIGlmICh0aGlzLiR1c2VQcm9qZWN0aW9uKSB7XG4gICAgb3B0aW9ucy5wcm9qZWN0aW9uID0gdGhpcy5fZmllbGRzRm9yRXhlYygpO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuZmllbGRzID0gdGhpcy5fZmllbGRzRm9yRXhlYygpO1xuICB9XG5cbiAgZGVidWcoJ2ZpbmRPbmUnLCB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBjb25kcywgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uZmluZE9uZShjb25kcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEV4ZWN0dWVzIHRoZSBxdWVyeSBhcyBhIGNvdW50KCkgb3BlcmF0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuY291bnQoKS53aGVyZSgnY29sb3InLCAnYmxhY2snKS5leGVjKCk7XG4gKlxuICogICAgIHF1ZXJ5LmNvdW50KHsgY29sb3I6ICdibGFjaycgfSlcbiAqXG4gKiAgICAgYXdhaXQgcXVlcnkuY291bnQoeyBjb2xvcjogJ2JsYWNrJyB9KTtcbiAqXG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgcXVlcnkud2hlcmUoJ2NvbG9yJywgJ2JsYWNrJykuY291bnQoKTtcbiAqICAgICBjb25zb2xlLmxvZygndGhlcmUgYXJlICVkIGtpdHRlbnMnLCBjb3VudCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjcml0ZXJpYV0gbW9uZ29kYiBzZWxlY3RvclxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZ2dyZWdhdGlvbiNBZ2dyZWdhdGlvbi1Db3VudFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbihjcml0ZXJpYSkge1xuICB0aGlzLm9wID0gJ2NvdW50JztcbiAgdGhpcy5fdmFsaWRhdGUoKTtcblxuICBpZiAoUXVlcnkuY2FuTWVyZ2UoY3JpdGVyaWEpKSB7XG4gICAgdGhpcy5tZXJnZShjcml0ZXJpYSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgY291bnRgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5RdWVyeS5wcm90b3R5cGUuX2NvdW50ID0gYXN5bmMgZnVuY3Rpb24gX2NvdW50KCkge1xuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnMsXG4gICAgICBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcblxuICBkZWJ1ZygnY291bnQnLCB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBjb25kcywgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uY291bnQoY29uZHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyBvciBleGVjdXRlcyBhIGRpc3RpbmN0KCkgb3BlcmF0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgZGlzdGluY3QoY3JpdGVyaWEsIGZpZWxkKVxuICogICAgIGRpc3RpbmN0KGNyaXRlcmlhLCBmaWVsZClcbiAqICAgICBhd2FpdCBkaXN0aW5jdChmaWVsZClcbiAqICAgICBkaXN0aW5jdChmaWVsZClcbiAqICAgICBhd2FpdCBkaXN0aW5jdCgpXG4gKiAgICAgZGlzdGluY3QoKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFF1ZXJ5fSBbY3JpdGVyaWFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZpZWxkXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZ2dyZWdhdGlvbiNBZ2dyZWdhdGlvbi1EaXN0aW5jdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZGlzdGluY3QgPSBmdW5jdGlvbihjcml0ZXJpYSwgZmllbGQpIHtcbiAgdGhpcy5vcCA9ICdkaXN0aW5jdCc7XG4gIHRoaXMuX3ZhbGlkYXRlKCk7XG5cbiAgaWYgKCFmaWVsZCAmJiB0eXBlb2YgY3JpdGVyaWEgPT09ICdzdHJpbmcnKSB7XG4gICAgZmllbGQgPSBjcml0ZXJpYTtcbiAgICBjcml0ZXJpYSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZmllbGQpIHtcbiAgICB0aGlzLl9kaXN0aW5jdERvYyA9IGZpZWxkO1xuICB9XG5cbiAgaWYgKFF1ZXJ5LmNhbk1lcmdlKGNyaXRlcmlhKSkge1xuICAgIHRoaXMubWVyZ2UoY3JpdGVyaWEpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYGRpc3RpbmN0YCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9kaXN0aW5jdCA9IGFzeW5jIGZ1bmN0aW9uIF9kaXN0aW5jdCgpIHtcbiAgaWYgKCF0aGlzLl9kaXN0aW5jdERvYykge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsdWUgZm9yIGBkaXN0aW5jdGAgaGFzIGJlZW4gZGVjbGFyZWQnKTtcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucyxcbiAgICAgIG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuXG4gIGRlYnVnKCdkaXN0aW5jdCcsIHRoaXMuX2NvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsIGNvbmRzLCBvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5kaXN0aW5jdCh0aGlzLl9kaXN0aW5jdERvYywgY29uZHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlIGFuZC9vciBleGVjdXRlIHRoaXMgcXVlcnkgYXMgYW4gYHVwZGF0ZU1hbnkoKWAgb3BlcmF0aW9uLiBUaGlzIGZ1bmN0aW9uIHdpbGwgdXBkYXRlIF9hbGxfIGRvY3VtZW50cyB0aGF0IG1hdGNoXG4gKiBgY3JpdGVyaWFgLCByYXRoZXIgdGhhbiBqdXN0IHRoZSBmaXJzdCBvbmUuXG4gKlxuICogX0FsbCBwYXRocyBwYXNzZWQgdGhhdCBhcmUgbm90ICRhdG9taWMgb3BlcmF0aW9ucyB3aWxsIGJlY29tZSAkc2V0IG9wcy5fXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBVcGRhdGUgZXZlcnkgZG9jdW1lbnQgd2hvc2UgYHRpdGxlYCBjb250YWlucyAndGVzdCdcbiAqICAgICBtcXVlcnkoKS51cGRhdGVNYW55KHsgdGl0bGU6IC90ZXN0LyB9LCB7IHllYXI6IDIwMTcgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NyaXRlcmlhXVxuICogQHBhcmFtIHtPYmplY3R9IFtkb2NdIHRoZSB1cGRhdGUgY29tbWFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnVwZGF0ZU1hbnkgPSBmdW5jdGlvbiB1cGRhdGVNYW55KGNyaXRlcmlhLCBkb2MsIG9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBkb2MgPSBjcml0ZXJpYTtcbiAgICBjcml0ZXJpYSA9IG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gX3VwZGF0ZSh0aGlzLCAndXBkYXRlTWFueScsIGNyaXRlcmlhLCBkb2MsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGB1cGRhdGVNYW55YCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuUXVlcnkucHJvdG90eXBlLl91cGRhdGVNYW55ID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBfdXBkYXRlRXhlYyh0aGlzLCAndXBkYXRlTWFueScpO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlIGFuZC9vciBleGVjdXRlIHRoaXMgcXVlcnkgYXMgYW4gYHVwZGF0ZU9uZSgpYCBvcGVyYXRpb24uIFRoaXMgZnVuY3Rpb24gd2lsbCBfYWx3YXlzXyB1cGRhdGUganVzdCBvbmUgZG9jdW1lbnQsXG4gKiByZWdhcmRsZXNzIG9mIHRoZSBgbXVsdGlgIG9wdGlvbi5cbiAqXG4gKiBfQWxsIHBhdGhzIHBhc3NlZCB0aGF0IGFyZSBub3QgJGF0b21pYyBvcGVyYXRpb25zIHdpbGwgYmVjb21lICRzZXQgb3BzLl9cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFVwZGF0ZSB0aGUgZmlyc3QgZG9jdW1lbnQgd2hvc2UgYHRpdGxlYCBjb250YWlucyAndGVzdCdcbiAqICAgICBtcXVlcnkoKS51cGRhdGVNYW55KHsgdGl0bGU6IC90ZXN0LyB9LCB7IHllYXI6IDIwMTcgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NyaXRlcmlhXVxuICogQHBhcmFtIHtPYmplY3R9IFtkb2NdIHRoZSB1cGRhdGUgY29tbWFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnVwZGF0ZU9uZSA9IGZ1bmN0aW9uIHVwZGF0ZU9uZShjcml0ZXJpYSwgZG9jLCBvcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgZG9jID0gY3JpdGVyaWE7XG4gICAgY3JpdGVyaWEgPSBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIF91cGRhdGUodGhpcywgJ3VwZGF0ZU9uZScsIGNyaXRlcmlhLCBkb2MsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGB1cGRhdGVPbmVgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5RdWVyeS5wcm90b3R5cGUuX3VwZGF0ZU9uZSA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICByZXR1cm4gX3VwZGF0ZUV4ZWModGhpcywgJ3VwZGF0ZU9uZScpO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlIGFuZC9vciBleGVjdXRlIHRoaXMgcXVlcnkgYXMgYW4gYHJlcGxhY2VPbmUoKWAgb3BlcmF0aW9uLiBTaW1pbGFyXG4gKiB0byBgdXBkYXRlT25lKClgLCBleGNlcHQgYHJlcGxhY2VPbmUoKWAgaXMgbm90IGFsbG93ZWQgdG8gdXNlIGF0b21pY1xuICogbW9kaWZpZXJzIChgJHNldGAsIGAkcHVzaGAsIGV0Yy4pLiBDYWxsaW5nIGByZXBsYWNlT25lKClgIHdpbGwgYWx3YXlzXG4gKiByZXBsYWNlIHRoZSBleGlzdGluZyBkb2MuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBSZXBsYWNlIHRoZSBkb2N1bWVudCB3aXRoIGBfaWRgIDEgd2l0aCBgeyBfaWQ6IDEsIHllYXI6IDIwMTcgfWBcbiAqICAgICBtcXVlcnkoKS5yZXBsYWNlT25lKHsgX2lkOiAxIH0sIHsgeWVhcjogMjAxNyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY3JpdGVyaWFdXG4gKiBAcGFyYW0ge09iamVjdH0gW2RvY10gdGhlIHVwZGF0ZSBjb21tYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUucmVwbGFjZU9uZSA9IGZ1bmN0aW9uIHJlcGxhY2VPbmUoY3JpdGVyaWEsIGRvYywgb3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGRvYyA9IGNyaXRlcmlhO1xuICAgIGNyaXRlcmlhID0gb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRoaXMuc2V0T3B0aW9ucyh7IG92ZXJ3cml0ZTogdHJ1ZSB9KTtcbiAgcmV0dXJuIF91cGRhdGUodGhpcywgJ3JlcGxhY2VPbmUnLCBjcml0ZXJpYSwgZG9jLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgcmVwbGFjZU9uZWAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fcmVwbGFjZU9uZSA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICByZXR1cm4gX3VwZGF0ZUV4ZWModGhpcywgJ3JlcGxhY2VPbmUnKTtcbn07XG5cbi8qIVxuICogSW50ZXJuYWwgaGVscGVyIGZvciB1cGRhdGVNYW55LCB1cGRhdGVPbmVcbiAqL1xuXG5mdW5jdGlvbiBfdXBkYXRlKHF1ZXJ5LCBvcCwgY3JpdGVyaWEsIGRvYywgb3B0aW9ucykge1xuICBxdWVyeS5vcCA9IG9wO1xuXG4gIGlmIChRdWVyeS5jYW5NZXJnZShjcml0ZXJpYSkpIHtcbiAgICBxdWVyeS5tZXJnZShjcml0ZXJpYSk7XG4gIH1cblxuICBpZiAoZG9jKSB7XG4gICAgcXVlcnkuX21lcmdlVXBkYXRlKGRvYyk7XG4gIH1cblxuICBpZiAodXRpbHMuaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAvLyB7IG92ZXJ3cml0ZTogdHJ1ZSB9XG4gICAgcXVlcnkuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBxdWVyeTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIGRlLWR1cGxpY2F0aW5nIFwidXBkYXRlKlwiIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtRdWVyeX0gcXVlcnkgVGhlIFF1ZXJ5IE9iamVjdCAocmVwbGFjZW1lbnQgZm9yIFwidGhpc1wiKVxuICogQHBhcmFtIHtTdHJpbmd9IG9wIFRoZSBPcGVyYXRpb24gdG8gYmUgZG9uZVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3VwZGF0ZUV4ZWMocXVlcnksIG9wKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBxdWVyeS5fb3B0aW9uc0ZvckV4ZWMoKTtcblxuICBjb25zdCBjcml0ZXJpYSA9IHF1ZXJ5Ll9jb25kaXRpb25zO1xuICBjb25zdCBkb2MgPSBxdWVyeS5fdXBkYXRlRm9yRXhlYygpO1xuXG4gIGRlYnVnKCd1cGRhdGUnLCBxdWVyeS5fY29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSwgY3JpdGVyaWEsIGRvYywgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHF1ZXJ5Ll9jb2xsZWN0aW9uW29wXShjcml0ZXJpYSwgZG9jLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBEZWNsYXJlIGFuZC9vciBleGVjdXRlIHRoaXMgcXVlcnkgYXMgYSBgZGVsZXRlT25lKClgIG9wZXJhdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IG1xdWVyeShjb2xsZWN0aW9uKS5kZWxldGVPbmUoeyBhcnRpc3Q6ICdBbm5lIE11cnJheScgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxRdWVyeX0gW2NyaXRlcmlhXSBtb25nb2RiIHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZGVsZXRlT25lID0gZnVuY3Rpb24oY3JpdGVyaWEpIHtcbiAgdGhpcy5vcCA9ICdkZWxldGVPbmUnO1xuXG4gIGlmIChRdWVyeS5jYW5NZXJnZShjcml0ZXJpYSkpIHtcbiAgICB0aGlzLm1lcmdlKGNyaXRlcmlhKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGBkZWxldGVPbmVgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5RdWVyeS5wcm90b3R5cGUuX2RlbGV0ZU9uZSA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcbiAgZGVsZXRlIG9wdGlvbnMuanVzdE9uZTtcblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnM7XG5cbiAgZGVidWcoJ2RlbGV0ZU9uZScsIHRoaXMuX2NvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsIGNvbmRzLCBvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5kZWxldGVPbmUoY29uZHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlIGFuZC9vciBleGVjdXRlIHRoaXMgcXVlcnkgYXMgYSBgZGVsZXRlTWFueSgpYCBvcGVyYXRpb24uIEFsd2F5cyBkZWxldGVzXG4gKiBfZXZlcnlfIGRvY3VtZW50IHRoYXQgbWF0Y2hlcyBgY3JpdGVyaWFgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgbXF1ZXJ5KGNvbGxlY3Rpb24pLmRlbGV0ZU1hbnkoeyBhcnRpc3Q6ICdBbm5lIE11cnJheScgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxRdWVyeX0gW2NyaXRlcmlhXSBtb25nb2RiIHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZGVsZXRlTWFueSA9IGZ1bmN0aW9uKGNyaXRlcmlhKSB7XG4gIHRoaXMub3AgPSAnZGVsZXRlTWFueSc7XG5cbiAgaWYgKFF1ZXJ5LmNhbk1lcmdlKGNyaXRlcmlhKSkge1xuICAgIHRoaXMubWVyZ2UoY3JpdGVyaWEpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYGRlbGV0ZU1hbnlgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5RdWVyeS5wcm90b3R5cGUuX2RlbGV0ZU1hbnkgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG4gIGRlbGV0ZSBvcHRpb25zLmp1c3RPbmU7XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zO1xuXG4gIGRlYnVnKCdkZWxldGVPbmUnLCB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBjb25kcywgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uZGVsZXRlTWFueShjb25kcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIElzc3VlcyBhIG1vbmdvZGIgW2ZpbmRBbmRNb2RpZnldKGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL2ZpbmRBbmRNb2RpZnkrQ29tbWFuZCkgdXBkYXRlIGNvbW1hbmQuXG4gKlxuICogRmluZHMgYSBtYXRjaGluZyBkb2N1bWVudCwgdXBkYXRlcyBpdCBhY2NvcmRpbmcgdG8gdGhlIGB1cGRhdGVgIGFyZywgcGFzc2luZyBhbnkgYG9wdGlvbnNgLCBhbmQgcmV0dXJucyB0aGUgZm91bmQgZG9jdW1lbnQgKGlmIGFueSkuXG4gKlxuICogIyMjIyBBdmFpbGFibGUgb3B0aW9uc1xuICpcbiAqIC0gYG5ld2A6IGJvb2wgLSB0cnVlIHRvIHJldHVybiB0aGUgbW9kaWZpZWQgZG9jdW1lbnQgcmF0aGVyIHRoYW4gdGhlIG9yaWdpbmFsLiBkZWZhdWx0cyB0byB0cnVlXG4gKiAtIGB1cHNlcnRgOiBib29sIC0gY3JlYXRlcyB0aGUgb2JqZWN0IGlmIGl0IGRvZXNuJ3QgZXhpc3QuIGRlZmF1bHRzIHRvIGZhbHNlLlxuICogLSBgc29ydGA6IGlmIG11bHRpcGxlIGRvY3MgYXJlIGZvdW5kIGJ5IHRoZSBjb25kaXRpb25zLCBzZXRzIHRoZSBzb3J0IG9yZGVyIHRvIGNob29zZSB3aGljaCBkb2MgdG8gdXBkYXRlXG4gKlxuICogIyMjIyBFeGFtcGxlczpcbiAqXG4gKiAgICAgYXdhaXQgcXVlcnkuZmluZE9uZUFuZFVwZGF0ZShjb25kaXRpb25zLCB1cGRhdGUsIG9wdGlvbnMpIC8vIGV4ZWN1dGVzXG4gKiAgICAgcXVlcnkuZmluZE9uZUFuZFVwZGF0ZShjb25kaXRpb25zLCB1cGRhdGUsIG9wdGlvbnMpICAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgYXdhaXQgcXVlcnkuZmluZE9uZUFuZFVwZGF0ZShjb25kaXRpb25zLCB1cGRhdGUpIC8vIGV4ZWN1dGVzXG4gKiAgICAgcXVlcnkuZmluZE9uZUFuZFVwZGF0ZShjb25kaXRpb25zLCB1cGRhdGUpICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgYXdhaXQgcXVlcnkuZmluZE9uZUFuZFVwZGF0ZSh1cGRhdGUpICAgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBxdWVyeS5maW5kT25lQW5kVXBkYXRlKHVwZGF0ZSkgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBhd2FpdCBxdWVyeS5maW5kT25lQW5kVXBkYXRlKCkgICAgICAgICAgICAgICAgICAgICAvLyBleGVjdXRlc1xuICogICAgIHF1ZXJ5LmZpbmRPbmVBbmRVcGRhdGUoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFF1ZXJ5fSBbcXVlcnldXG4gKiBAcGFyYW0ge09iamVjdH0gW2RvY11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9maW5kQW5kTW9kaWZ5K0NvbW1hbmRcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5maW5kT25lQW5kVXBkYXRlID0gZnVuY3Rpb24oY3JpdGVyaWEsIGRvYywgb3B0aW9ucykge1xuICB0aGlzLm9wID0gJ2ZpbmRPbmVBbmRVcGRhdGUnO1xuICB0aGlzLl92YWxpZGF0ZSgpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgZG9jID0gY3JpdGVyaWE7XG4gICAgY3JpdGVyaWEgPSBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKFF1ZXJ5LmNhbk1lcmdlKGNyaXRlcmlhKSkge1xuICAgIHRoaXMubWVyZ2UoY3JpdGVyaWEpO1xuICB9XG5cbiAgLy8gYXBwbHkgZG9jXG4gIGlmIChkb2MpIHtcbiAgICB0aGlzLl9tZXJnZVVwZGF0ZShkb2MpO1xuICB9XG5cbiAgb3B0aW9ucyAmJiB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYGZpbmRPbmVBbmRVcGRhdGVgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5RdWVyeS5wcm90b3R5cGUuX2ZpbmRPbmVBbmRVcGRhdGUgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zO1xuICBjb25zdCB1cGRhdGUgPSB0aGlzLl91cGRhdGVGb3JFeGVjKCk7XG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuXG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmZpbmRPbmVBbmRVcGRhdGUoY29uZHMsIHVwZGF0ZSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIElzc3VlcyBhIG1vbmdvZGIgW2ZpbmRBbmRNb2RpZnldKGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL2ZpbmRBbmRNb2RpZnkrQ29tbWFuZCkgcmVtb3ZlIGNvbW1hbmQuXG4gKlxuICogRmluZHMgYSBtYXRjaGluZyBkb2N1bWVudCwgcmVtb3ZlcyBpdCwgcmV0dXJuaW5nIHRoZSBmb3VuZCBkb2N1bWVudCAoaWYgYW55KS5cbiAqXG4gKiAjIyMjIEF2YWlsYWJsZSBvcHRpb25zXG4gKlxuICogLSBgc29ydGA6IGlmIG11bHRpcGxlIGRvY3MgYXJlIGZvdW5kIGJ5IHRoZSBjb25kaXRpb25zLCBzZXRzIHRoZSBzb3J0IG9yZGVyIHRvIGNob29zZSB3aGljaCBkb2MgdG8gdXBkYXRlXG4gKlxuICogIyMjIyBFeGFtcGxlczpcbiAqXG4gKiAgICAgYXdhaXQgQS53aGVyZSgpLmZpbmRPbmVBbmRSZW1vdmUoY29uZGl0aW9ucywgb3B0aW9ucykgLy8gZXhlY3V0ZXNcbiAqICAgICBBLndoZXJlKCkuZmluZE9uZUFuZFJlbW92ZShjb25kaXRpb25zLCBvcHRpb25zKSAgLy8gcmV0dXJuIFF1ZXJ5XG4gKiAgICAgYXdhaXQgQS53aGVyZSgpLmZpbmRPbmVBbmRSZW1vdmUoY29uZGl0aW9ucykgLy8gZXhlY3V0ZXNcbiAqICAgICBBLndoZXJlKCkuZmluZE9uZUFuZFJlbW92ZShjb25kaXRpb25zKSAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgYXdhaXQgQS53aGVyZSgpLmZpbmRPbmVBbmRSZW1vdmUoKSAgIC8vIGV4ZWN1dGVzXG4gKiAgICAgQS53aGVyZSgpLmZpbmRPbmVBbmRSZW1vdmUoKSAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIEEud2hlcmUoKS5maW5kT25lQW5kRGVsZXRlKCkgICAgICAgICAgIC8vIGFsaWFzIG9mIC5maW5kT25lQW5kUmVtb3ZlKClcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmRpdGlvbnNdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL2ZpbmRBbmRNb2RpZnkrQ29tbWFuZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZmluZE9uZUFuZFJlbW92ZSA9IFF1ZXJ5LnByb3RvdHlwZS5maW5kT25lQW5kRGVsZXRlID0gZnVuY3Rpb24oY29uZGl0aW9ucywgb3B0aW9ucykge1xuICB0aGlzLm9wID0gJ2ZpbmRPbmVBbmRSZW1vdmUnO1xuICB0aGlzLl92YWxpZGF0ZSgpO1xuXG4gIC8vIGFwcGx5IGNvbmRpdGlvbnNcbiAgaWYgKFF1ZXJ5LmNhbk1lcmdlKGNvbmRpdGlvbnMpKSB7XG4gICAgdGhpcy5tZXJnZShjb25kaXRpb25zKTtcbiAgfVxuXG4gIC8vIGFwcGx5IG9wdGlvbnNcbiAgb3B0aW9ucyAmJiB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYGZpbmRPbmVBbmRSZW1vdmVgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5RdWVyeS5wcm90b3R5cGUuX2ZpbmRPbmVBbmRSZW1vdmUgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucztcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5maW5kT25lQW5kRGVsZXRlKGNvbmRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQWRkIHRyYWNlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgcXVlcnkgaXMgZXhlY3V0ZWQuXG4gKiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCAobWV0aG9kLCBxdWVyeUluZm8sIHF1ZXJ5KSBhbmRcbiAqIHNob3VsZCByZXR1cm4gYSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZFxuICogd2l0aCAoZXJyLCByZXN1bHQsIG1pbGxpcykgd2hlbiB0aGUgcXVlcnkgaXMgY29tcGxldGUuXG4gKlxuICogcXVlcnlJbmZvIGlzIGFuIG9iamVjdCBjb250YWluaW5nOiB7XG4gKiAgIGNvbGxlY3Rpb25OYW1lOiA8bmFtZSBvZiB0aGUgY29sbGVjdGlvbj4sXG4gKiAgIGNvbmRpdGlvbnM6IDxxdWVyeSBjcml0ZXJpYT4sXG4gKiAgIG9wdGlvbnM6IDxjb21tZW50LCBmaWVsZHMsIHJlYWRQcmVmZXJlbmNlLCBldGM+LFxuICogICBkb2M6IFtkb2N1bWVudCB0byB1cGRhdGUsIGlmIGFwcGxpY2FibGVdXG4gKiB9XG4gKlxuICogTk9URTogRG9lcyBub3QgdHJhY2Ugc3RyZWFtIHF1ZXJpZXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhY2VGdW5jdGlvblxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5zZXRUcmFjZUZ1bmN0aW9uID0gZnVuY3Rpb24odHJhY2VGdW5jdGlvbikge1xuICB0aGlzLl90cmFjZUZ1bmN0aW9uID0gdHJhY2VGdW5jdGlvbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBxdWVyeVxuICpcbiAqICMjIyMgRXhhbXBsZXM6XG4gKlxuICogICAgIHF1ZXJ5LmV4ZWMoKTtcbiAqICAgICBhd2FpdCBxdWVyeS5leGVjKCk7XG4gKiAgICAgcXVlcnkuZXhlYygndXBkYXRlJyk7XG4gKiAgICAgYXdhaXQgcXVlcnkuZXhlYygnZmluZCcpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBbb3BlcmF0aW9uXVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZXhlYyA9IGFzeW5jIGZ1bmN0aW9uIGV4ZWMob3ApIHtcbiAgaWYgKHR5cGVvZiBvcCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLm9wID0gb3A7XG4gIH1cblxuICBhc3NlcnQub2sodGhpcy5vcCwgJ01pc3NpbmcgcXVlcnkgdHlwZTogKGZpbmQsIGV0YyknKTtcblxuICBjb25zdCBmbk5hbWUgPSAnXycgKyB0aGlzLm9wO1xuXG4gIC8vIGJldHRlciBlcnJvciwgYmVjYXVzZSBkZWZhdWx0IHdvdWxkIGxpc3QgaXQgYXMgXCJ0aGlzW2ZuTmFtZV0gaXMgbm90IGEgZnVuY3Rpb25cIlxuICBpZiAodHlwZW9mIHRoaXNbZm5OYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHRoaXNbJHtmbk5hbWV9XSBpcyBub3QgYSBmdW5jdGlvbmApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXNbZm5OYW1lXSgpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcXVlcnkgcmV0dXJuaW5nIGEgYFByb21pc2VgIHdoaWNoIHdpbGwgYmVcbiAqIHJlc29sdmVkIHdpdGggZWl0aGVyIHRoZSBkb2Mocykgb3IgcmVqZWN0ZWQgd2l0aCB0aGUgZXJyb3IuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVqZWN0XVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnRoZW4gPSBhc3luYyBmdW5jdGlvbihyZXMsIHJlaikge1xuICByZXR1cm4gdGhpcy5leGVjKCkudGhlbihyZXMsIHJlaik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBjdXJzb3IgZm9yIHRoZSBnaXZlbiBgZmluZGAgcXVlcnkuXG4gKlxuICogQHRocm93cyBFcnJvciBpZiBvcGVyYXRpb24gaXMgbm90IGEgZmluZFxuICogQHJldHVybnMge0N1cnNvcn0gTW9uZ29EQiBkcml2ZXIgY3Vyc29yXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmN1cnNvciA9IGZ1bmN0aW9uKCkge1xuICBpZiAoJ2ZpbmQnICE9IHRoaXMub3ApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjdXJzb3IoKSBpcyBvbmx5IGF2YWlsYWJsZSBmb3IgZmluZCcpO1xuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucztcblxuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcbiAgaWYgKHRoaXMuJHVzZVByb2plY3Rpb24pIHtcbiAgICBvcHRpb25zLnByb2plY3Rpb24gPSB0aGlzLl9maWVsZHNGb3JFeGVjKCk7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5maWVsZHMgPSB0aGlzLl9maWVsZHNGb3JFeGVjKCk7XG4gIH1cblxuICBkZWJ1ZygnY3Vyc29yJywgdGhpcy5fY29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSwgY29uZHMsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmZpbmRDdXJzb3IoY29uZHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGZpZWxkIHNlbGVjdGlvbiBoYXMgYmVlbiBtYWRlLlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zZWxlY3RlZCA9IGZ1bmN0aW9uIHNlbGVjdGVkKCkge1xuICByZXR1cm4gISEodGhpcy5fZmllbGRzICYmIE9iamVjdC5rZXlzKHRoaXMuX2ZpZWxkcykubGVuZ3RoID4gMCk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgaW5jbHVzaXZlIGZpZWxkIHNlbGVjdGlvbiBoYXMgYmVlbiBtYWRlLlxuICpcbiAqICAgICBxdWVyeS5zZWxlY3RlZEluY2x1c2l2ZWx5KCkgLy8gZmFsc2VcbiAqICAgICBxdWVyeS5zZWxlY3QoJ25hbWUnKVxuICogICAgIHF1ZXJ5LnNlbGVjdGVkSW5jbHVzaXZlbHkoKSAvLyB0cnVlXG4gKiAgICAgcXVlcnkuc2VsZWN0ZWRFeGx1c2l2ZWx5KCkgLy8gZmFsc2VcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2VsZWN0ZWRJbmNsdXNpdmVseSA9IGZ1bmN0aW9uIHNlbGVjdGVkSW5jbHVzaXZlbHkoKSB7XG4gIGlmICghdGhpcy5fZmllbGRzKSByZXR1cm4gZmFsc2U7XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2ZpZWxkcyk7XG4gIGlmICgwID09PSBrZXlzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgaWYgKDAgPT09IHRoaXMuX2ZpZWxkc1trZXldKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuX2ZpZWxkc1trZXldICYmXG4gICAgICAgIHR5cGVvZiB0aGlzLl9maWVsZHNba2V5XSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdGhpcy5fZmllbGRzW2tleV0uJG1ldGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBleGNsdXNpdmUgZmllbGQgc2VsZWN0aW9uIGhhcyBiZWVuIG1hZGUuXG4gKlxuICogICAgIHF1ZXJ5LnNlbGVjdGVkRXhsdXNpdmVseSgpIC8vIGZhbHNlXG4gKiAgICAgcXVlcnkuc2VsZWN0KCctbmFtZScpXG4gKiAgICAgcXVlcnkuc2VsZWN0ZWRFeGx1c2l2ZWx5KCkgLy8gdHJ1ZVxuICogICAgIHF1ZXJ5LnNlbGVjdGVkSW5jbHVzaXZlbHkoKSAvLyBmYWxzZVxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zZWxlY3RlZEV4Y2x1c2l2ZWx5ID0gZnVuY3Rpb24gc2VsZWN0ZWRFeGNsdXNpdmVseSgpIHtcbiAgaWYgKCF0aGlzLl9maWVsZHMpIHJldHVybiBmYWxzZTtcblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5fZmllbGRzKTtcbiAgaWYgKDAgPT09IGtleXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoMCA9PT0gdGhpcy5fZmllbGRzW2tleV0pIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBNZXJnZXMgYGRvY2Agd2l0aCB0aGUgY3VycmVudCB1cGRhdGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX21lcmdlVXBkYXRlID0gZnVuY3Rpb24oZG9jKSB7XG4gIGlmICghdGhpcy5fdXBkYXRlRG9jKSB0aGlzLl91cGRhdGVEb2MgPSB7fTtcbiAgaWYgKGRvYyBpbnN0YW5jZW9mIFF1ZXJ5KSB7XG4gICAgaWYgKGRvYy5fdXBkYXRlRG9jKSB7XG4gICAgICB1dGlscy5tZXJnZUNsb25lKHRoaXMuX3VwZGF0ZURvYywgZG9jLl91cGRhdGVEb2MpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB1dGlscy5tZXJnZUNsb25lKHRoaXMuX3VwZGF0ZURvYywgZG9jKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGRlZmF1bHQgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX29wdGlvbnNGb3JFeGVjID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB1dGlscy5jbG9uZSh0aGlzLm9wdGlvbnMpO1xuICByZXR1cm4gb3B0aW9ucztcbn07XG5cbi8qKlxuICogUmV0dXJucyBmaWVsZHMgc2VsZWN0aW9uIGZvciB0aGlzIHF1ZXJ5LlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fZmllbGRzRm9yRXhlYyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdXRpbHMuY2xvbmUodGhpcy5fZmllbGRzKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIHVwZGF0ZSBkb2N1bWVudCB3aXRoIGNvcnJlY3RlZCAkc2V0IG9wZXJhdGlvbnMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl91cGRhdGVGb3JFeGVjID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHVwZGF0ZSA9IHV0aWxzLmNsb25lKHRoaXMuX3VwZGF0ZURvYyk7XG4gIGNvbnN0IG9wcyA9IHV0aWxzLmtleXModXBkYXRlKTtcbiAgY29uc3QgcmV0ID0ge307XG5cbiAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJ3cml0ZSkge1xuICAgICAgcmV0W29wXSA9IHVwZGF0ZVtvcF07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoJyQnICE9PSBvcFswXSkge1xuICAgICAgLy8gZml4IHVwICRzZXQgc3VnYXJcbiAgICAgIGlmICghcmV0LiRzZXQpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS4kc2V0KSB7XG4gICAgICAgICAgcmV0LiRzZXQgPSB1cGRhdGUuJHNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQuJHNldCA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXQuJHNldFtvcF0gPSB1cGRhdGVbb3BdO1xuICAgICAgaWYgKCF+b3BzLmluZGV4T2YoJyRzZXQnKSkgb3BzLnB1c2goJyRzZXQnKTtcbiAgICB9IGVsc2UgaWYgKCckc2V0JyA9PT0gb3ApIHtcbiAgICAgIGlmICghcmV0LiRzZXQpIHtcbiAgICAgICAgcmV0W29wXSA9IHVwZGF0ZVtvcF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldFtvcF0gPSB1cGRhdGVbb3BdO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2NvbXBpbGVkVXBkYXRlID0gcmV0O1xuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBNYWtlIHN1cmUgX3BhdGggaXMgc2V0LlxuICpcbiAqIEBwYXJtYW0ge1N0cmluZ30gbWV0aG9kXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9lbnN1cmVQYXRoID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gIGlmICghdGhpcy5fcGF0aCkge1xuICAgIGNvbnN0IG1zZyA9IG1ldGhvZCArICcoKSBtdXN0IGJlIHVzZWQgYWZ0ZXIgd2hlcmUoKSAnXG4gICAgICAgICAgICAgICAgICAgICArICd3aGVuIGNhbGxlZCB3aXRoIHRoZXNlIGFyZ3VtZW50cyc7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn07XG5cbi8qIVxuICogUGVybWlzc2lvbnNcbiAqL1xuXG5RdWVyeS5wZXJtaXNzaW9ucyA9IHJlcXVpcmUoJy4vcGVybWlzc2lvbnMnKTtcblxuUXVlcnkuX2lzUGVybWl0dGVkID0gZnVuY3Rpb24oYSwgYikge1xuICBjb25zdCBkZW5pZWQgPSBRdWVyeS5wZXJtaXNzaW9uc1tiXTtcbiAgaWYgKCFkZW5pZWQpIHJldHVybiB0cnVlO1xuICByZXR1cm4gdHJ1ZSAhPT0gZGVuaWVkW2FdO1xufTtcblxuUXVlcnkucHJvdG90eXBlLl92YWxpZGF0ZSA9IGZ1bmN0aW9uKGFjdGlvbikge1xuICBsZXQgZmFpbDtcbiAgbGV0IHZhbGlkYXRvcjtcblxuICBpZiAodW5kZWZpbmVkID09PSBhY3Rpb24pIHtcblxuICAgIHZhbGlkYXRvciA9IFF1ZXJ5LnBlcm1pc3Npb25zW3RoaXMub3BdO1xuICAgIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiB2YWxpZGF0b3IpIHJldHVybiB0cnVlO1xuXG4gICAgZmFpbCA9IHZhbGlkYXRvcih0aGlzKTtcblxuICB9IGVsc2UgaWYgKCFRdWVyeS5faXNQZXJtaXR0ZWQoYWN0aW9uLCB0aGlzLm9wKSkge1xuICAgIGZhaWwgPSBhY3Rpb247XG4gIH1cblxuICBpZiAoZmFpbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihmYWlsICsgJyBjYW5ub3QgYmUgdXNlZCB3aXRoICcgKyB0aGlzLm9wKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGBjb25kc2AgY2FuIGJlIG1lcmdlZCB1c2luZyBgbXF1ZXJ5KCkubWVyZ2UoKWBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZHNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuUXVlcnkuY2FuTWVyZ2UgPSBmdW5jdGlvbihjb25kcykge1xuICByZXR1cm4gY29uZHMgaW5zdGFuY2VvZiBRdWVyeSB8fCB1dGlscy5pc09iamVjdChjb25kcyk7XG59O1xuXG4vKipcbiAqIFNldCBhIHRyYWNlIGZ1bmN0aW9uIHRoYXQgd2lsbCBnZXQgY2FsbGVkIHdoZW5ldmVyIGFcbiAqIHF1ZXJ5IGlzIGV4ZWN1dGVkLlxuICpcbiAqIFNlZSBgc2V0VHJhY2VGdW5jdGlvbigpYCBmb3IgZGV0YWlscy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZHNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblF1ZXJ5LnNldEdsb2JhbFRyYWNlRnVuY3Rpb24gPSBmdW5jdGlvbih0cmFjZUZ1bmN0aW9uKSB7XG4gIFF1ZXJ5LnRyYWNlRnVuY3Rpb24gPSB0cmFjZUZ1bmN0aW9uO1xufTtcblxuLyohXG4gKiBFeHBvcnRzLlxuICovXG5cblF1ZXJ5LnV0aWxzID0gdXRpbHM7XG5RdWVyeS5lbnYgPSByZXF1aXJlKCcuL2VudicpO1xuUXVlcnkuQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbicpO1xuUXVlcnkuQmFzZUNvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2NvbGxlY3Rpb24vY29sbGVjdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gUXVlcnk7XG5cbi8vIFRPRE9cbi8vIHRlc3QgdXRpbHNcbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwidXRpbCIsInV0aWxzIiwiZGVidWciLCJRdWVyeSIsImNyaXRlcmlhIiwib3B0aW9ucyIsInByb3RvIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJvcCIsInVuZGVmaW5lZCIsIk9iamVjdCIsImFzc2lnbiIsIl9jb25kaXRpb25zIiwiY2xvbmUiLCJfZmllbGRzIiwiX3VwZGF0ZURvYyIsIl9wYXRoIiwiX2Rpc3RpbmN0RG9jIiwiX2NvbGxlY3Rpb24iLCJfdHJhY2VGdW5jdGlvbiIsInNldE9wdGlvbnMiLCJmaW5kIiwiJHdpdGhpbkNtZCIsImRlZmluZVByb3BlcnR5IiwiZ2V0Iiwic2V0IiwidiIsInRvQ29uc3RydWN0b3IiLCJDdXN0b21RdWVyeSIsImNhbGwiLCJpbmhlcml0cyIsInAiLCJpc09iamVjdCIsIm1ldGhvZHMiLCJrZXlzIiwibWV0aG9kIiwiaSIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsImlzQXJyYXkiLCJhcHBseSIsImNvbGxlY3Rpb24iLCJjb2xsIiwiQ29sbGVjdGlvbiIsImNvbGxhdGlvbiIsInZhbHVlIiwiJHdoZXJlIiwianMiLCJ3aGVyZSIsImFyZ3VtZW50cyIsInR5cGUiLCJtZXJnZSIsIlR5cGVFcnJvciIsImVxdWFscyIsInZhbCIsIl9lbnN1cmVQYXRoIiwicGF0aCIsImVxIiwib3IiLCJhcnJheSIsIiRvciIsInB1c2giLCJub3IiLCIkbm9yIiwiYW5kIiwiJGFuZCIsInNwbGl0IiwiZm9yRWFjaCIsIiRjb25kaXRpb25hbCIsImNvbmRzIiwibW9kIiwiJG1vZCIsImV4aXN0cyIsIiRleGlzdHMiLCJlbGVtTWF0Y2giLCJmbiIsIiRlbGVtTWF0Y2giLCJ3aXRoaW4iLCJfZ2VvQ29tcGFyaXNvbiIsImJveCIsInBvbHlnb24iLCJhcmVhIiwiY2VudGVyIiwiY2lyY2xlIiwiY29vcmRpbmF0ZXMiLCJnZW9tZXRyeSIsIiRib3giLCJmcm9tIiwic2hpZnQiLCIkcG9seWdvbiIsIkVycm9yIiwic3BoZXJpY2FsIiwid0tleSIsInJhZGl1cyIsIiR1bmlxdWVEb2NzIiwidW5pcXVlIiwibmVhciIsIm1heERpc3RhbmNlIiwiJG1heERpc3RhbmNlIiwibWluRGlzdGFuY2UiLCIkbWluRGlzdGFuY2UiLCJmb3JtYXQiLCIkZ2VvbWV0cnkiLCJpbnRlcnNlY3RzIiwic2VsZWN0IiwiYXJnIiwiX3ZhbGlkYXRlIiwiZmllbGRzIiwibGVuIiwiaXNBcmd1bWVudHNPYmplY3QiLCJmaWVsZCIsImluY2x1ZGUiLCJzdWJzdHJpbmciLCJzbGljZSIsIm51bUtleXMiLCJteUZpZWxkcyIsIiRzbGljZSIsInNvcnQiLCJfcHVzaEFyciIsImFzY2VuZCIsIk1hcCIsIl9wdXNoTWFwIiwiX3ZhbGlkU29ydFZhbHVlIiwiYXNjIiwiYXNjZW5kaW5nIiwiZGVzYyIsImRlc2NlbmRpbmciLCJvcHRzIiwicyIsIiRtZXRhIiwiU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJtYXAiLCJrZXkiLCJtYXhUaW1lIiwibWF4VGltZU1TIiwibXMiLCJoaW50IiwiayIsImoiLCJzbGF2ZU9rIiwicmVhZCIsInNldFJlYWRQcmVmZXJlbmNlIiwicHJlZiIsImRlcHJlY2F0aW9uV2FybmluZ0lzc3VlZCIsImNvbnNvbGUiLCJlcnJvciIsInJlYWRQcmVmZXJlbmNlIiwicmVhZFByZWYiLCJyZWFkQ29uY2VybiIsInIiLCJsZXZlbCIsInRhaWxhYmxlIiwid3JpdGVDb25jZXJuIiwidyIsImNvbmNlcm4iLCJ3dGltZW91dCIsIndUaW1lb3V0Iiwic291cmNlIiwiY2FuTWVyZ2UiLCJtZXJnZUNsb25lIiwiX2ZpbmQiLCJfb3B0aW9uc0ZvckV4ZWMiLCIkdXNlUHJvamVjdGlvbiIsInByb2plY3Rpb24iLCJfZmllbGRzRm9yRXhlYyIsImNvbGxlY3Rpb25OYW1lIiwiY3Vyc29yIiwiZmluZEN1cnNvciIsImZpbmRPbmUiLCJfZmluZE9uZSIsImNvdW50IiwiX2NvdW50IiwiZGlzdGluY3QiLCJfZGlzdGluY3QiLCJ1cGRhdGVNYW55IiwiZG9jIiwiX3VwZGF0ZSIsIl91cGRhdGVNYW55IiwiX3VwZGF0ZUV4ZWMiLCJ1cGRhdGVPbmUiLCJfdXBkYXRlT25lIiwicmVwbGFjZU9uZSIsIm92ZXJ3cml0ZSIsIl9yZXBsYWNlT25lIiwicXVlcnkiLCJfbWVyZ2VVcGRhdGUiLCJfdXBkYXRlRm9yRXhlYyIsImRlbGV0ZU9uZSIsIl9kZWxldGVPbmUiLCJqdXN0T25lIiwiZGVsZXRlTWFueSIsIl9kZWxldGVNYW55IiwiZmluZE9uZUFuZFVwZGF0ZSIsIl9maW5kT25lQW5kVXBkYXRlIiwidXBkYXRlIiwiZmluZE9uZUFuZFJlbW92ZSIsImZpbmRPbmVBbmREZWxldGUiLCJjb25kaXRpb25zIiwiX2ZpbmRPbmVBbmRSZW1vdmUiLCJzZXRUcmFjZUZ1bmN0aW9uIiwidHJhY2VGdW5jdGlvbiIsImV4ZWMiLCJvayIsImZuTmFtZSIsInRoZW4iLCJyZXMiLCJyZWoiLCJzZWxlY3RlZCIsInNlbGVjdGVkSW5jbHVzaXZlbHkiLCJzZWxlY3RlZEV4Y2x1c2l2ZWx5Iiwib3BzIiwicmV0IiwiJHNldCIsImluZGV4T2YiLCJfY29tcGlsZWRVcGRhdGUiLCJtc2ciLCJwZXJtaXNzaW9ucyIsIl9pc1Blcm1pdHRlZCIsImEiLCJiIiwiZGVuaWVkIiwiYWN0aW9uIiwiZmFpbCIsInZhbGlkYXRvciIsInNldEdsb2JhbFRyYWNlRnVuY3Rpb24iLCJlbnYiLCJCYXNlQ29sbGVjdGlvbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/mquery.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mquery/lib/permissions.js":
/*!************************************************!*\
  !*** ./node_modules/mquery/lib/permissions.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nconst denied = exports;\ndenied.distinct = function(self) {\n    if (self._fields && Object.keys(self._fields).length > 0) {\n        return \"field selection and slice\";\n    }\n    const keys = Object.keys(denied.distinct);\n    let err;\n    keys.every(function(option) {\n        if (self.options[option]) {\n            err = option;\n            return false;\n        }\n        return true;\n    });\n    return err;\n};\ndenied.distinct.select = denied.distinct.slice = denied.distinct.sort = denied.distinct.limit = denied.distinct.skip = denied.distinct.batchSize = denied.distinct.hint = denied.distinct.tailable = true;\n// aggregation integration\ndenied.findOneAndUpdate = denied.findOneAndRemove = function(self) {\n    const keys = Object.keys(denied.findOneAndUpdate);\n    let err;\n    keys.every(function(option) {\n        if (self.options[option]) {\n            err = option;\n            return false;\n        }\n        return true;\n    });\n    return err;\n};\ndenied.findOneAndUpdate.limit = denied.findOneAndUpdate.skip = denied.findOneAndUpdate.batchSize = denied.findOneAndUpdate.tailable = true;\ndenied.count = function(self) {\n    if (self._fields && Object.keys(self._fields).length > 0) {\n        return \"field selection and slice\";\n    }\n    const keys = Object.keys(denied.count);\n    let err;\n    keys.every(function(option) {\n        if (self.options[option]) {\n            err = option;\n            return false;\n        }\n        return true;\n    });\n    return err;\n};\ndenied.count.slice = denied.count.batchSize = denied.count.tailable = true;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9wZXJtaXNzaW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDO0FBRWZELE9BQU9FLFFBQVEsR0FBRyxTQUFTQyxJQUFJO0lBQzdCLElBQUlBLEtBQUtDLE9BQU8sSUFBSUMsT0FBT0MsSUFBSSxDQUFDSCxLQUFLQyxPQUFPLEVBQUVHLE1BQU0sR0FBRyxHQUFHO1FBQ3hELE9BQU87SUFDVDtJQUVBLE1BQU1ELE9BQU9ELE9BQU9DLElBQUksQ0FBQ04sT0FBT0UsUUFBUTtJQUN4QyxJQUFJTTtJQUVKRixLQUFLRyxLQUFLLENBQUMsU0FBU0MsTUFBTTtRQUN4QixJQUFJUCxLQUFLUSxPQUFPLENBQUNELE9BQU8sRUFBRTtZQUN4QkYsTUFBTUU7WUFDTixPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxPQUFPRjtBQUNUO0FBQ0FSLE9BQU9FLFFBQVEsQ0FBQ1UsTUFBTSxHQUN0QlosT0FBT0UsUUFBUSxDQUFDVyxLQUFLLEdBQ3JCYixPQUFPRSxRQUFRLENBQUNZLElBQUksR0FDcEJkLE9BQU9FLFFBQVEsQ0FBQ2EsS0FBSyxHQUNyQmYsT0FBT0UsUUFBUSxDQUFDYyxJQUFJLEdBQ3BCaEIsT0FBT0UsUUFBUSxDQUFDZSxTQUFTLEdBQ3pCakIsT0FBT0UsUUFBUSxDQUFDZ0IsSUFBSSxHQUNwQmxCLE9BQU9FLFFBQVEsQ0FBQ2lCLFFBQVEsR0FBRztBQUczQiwwQkFBMEI7QUFHMUJuQixPQUFPb0IsZ0JBQWdCLEdBQ3ZCcEIsT0FBT3FCLGdCQUFnQixHQUFHLFNBQVNsQixJQUFJO0lBQ3JDLE1BQU1HLE9BQU9ELE9BQU9DLElBQUksQ0FBQ04sT0FBT29CLGdCQUFnQjtJQUNoRCxJQUFJWjtJQUVKRixLQUFLRyxLQUFLLENBQUMsU0FBU0MsTUFBTTtRQUN4QixJQUFJUCxLQUFLUSxPQUFPLENBQUNELE9BQU8sRUFBRTtZQUN4QkYsTUFBTUU7WUFDTixPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxPQUFPRjtBQUNUO0FBQ0FSLE9BQU9vQixnQkFBZ0IsQ0FBQ0wsS0FBSyxHQUM3QmYsT0FBT29CLGdCQUFnQixDQUFDSixJQUFJLEdBQzVCaEIsT0FBT29CLGdCQUFnQixDQUFDSCxTQUFTLEdBQ2pDakIsT0FBT29CLGdCQUFnQixDQUFDRCxRQUFRLEdBQUc7QUFHbkNuQixPQUFPc0IsS0FBSyxHQUFHLFNBQVNuQixJQUFJO0lBQzFCLElBQUlBLEtBQUtDLE9BQU8sSUFBSUMsT0FBT0MsSUFBSSxDQUFDSCxLQUFLQyxPQUFPLEVBQUVHLE1BQU0sR0FBRyxHQUFHO1FBQ3hELE9BQU87SUFDVDtJQUVBLE1BQU1ELE9BQU9ELE9BQU9DLElBQUksQ0FBQ04sT0FBT3NCLEtBQUs7SUFDckMsSUFBSWQ7SUFFSkYsS0FBS0csS0FBSyxDQUFDLFNBQVNDLE1BQU07UUFDeEIsSUFBSVAsS0FBS1EsT0FBTyxDQUFDRCxPQUFPLEVBQUU7WUFDeEJGLE1BQU1FO1lBQ04sT0FBTztRQUNUO1FBQ0EsT0FBTztJQUNUO0lBRUEsT0FBT0Y7QUFDVDtBQUVBUixPQUFPc0IsS0FBSyxDQUFDVCxLQUFLLEdBQ2xCYixPQUFPc0IsS0FBSyxDQUFDTCxTQUFTLEdBQ3RCakIsT0FBT3NCLEtBQUssQ0FBQ0gsUUFBUSxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hdXRoLXJlZ2lzdGVyLy4vbm9kZV9tb2R1bGVzL21xdWVyeS9saWIvcGVybWlzc2lvbnMuanM/MzJhZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGRlbmllZCA9IGV4cG9ydHM7XG5cbmRlbmllZC5kaXN0aW5jdCA9IGZ1bmN0aW9uKHNlbGYpIHtcbiAgaWYgKHNlbGYuX2ZpZWxkcyAmJiBPYmplY3Qua2V5cyhzZWxmLl9maWVsZHMpLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gJ2ZpZWxkIHNlbGVjdGlvbiBhbmQgc2xpY2UnO1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRlbmllZC5kaXN0aW5jdCk7XG4gIGxldCBlcnI7XG5cbiAga2V5cy5ldmVyeShmdW5jdGlvbihvcHRpb24pIHtcbiAgICBpZiAoc2VsZi5vcHRpb25zW29wdGlvbl0pIHtcbiAgICAgIGVyciA9IG9wdGlvbjtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBlcnI7XG59O1xuZGVuaWVkLmRpc3RpbmN0LnNlbGVjdCA9XG5kZW5pZWQuZGlzdGluY3Quc2xpY2UgPVxuZGVuaWVkLmRpc3RpbmN0LnNvcnQgPVxuZGVuaWVkLmRpc3RpbmN0LmxpbWl0ID1cbmRlbmllZC5kaXN0aW5jdC5za2lwID1cbmRlbmllZC5kaXN0aW5jdC5iYXRjaFNpemUgPVxuZGVuaWVkLmRpc3RpbmN0LmhpbnQgPVxuZGVuaWVkLmRpc3RpbmN0LnRhaWxhYmxlID0gdHJ1ZTtcblxuXG4vLyBhZ2dyZWdhdGlvbiBpbnRlZ3JhdGlvblxuXG5cbmRlbmllZC5maW5kT25lQW5kVXBkYXRlID1cbmRlbmllZC5maW5kT25lQW5kUmVtb3ZlID0gZnVuY3Rpb24oc2VsZikge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGVuaWVkLmZpbmRPbmVBbmRVcGRhdGUpO1xuICBsZXQgZXJyO1xuXG4gIGtleXMuZXZlcnkoZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgaWYgKHNlbGYub3B0aW9uc1tvcHRpb25dKSB7XG4gICAgICBlcnIgPSBvcHRpb247XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gZXJyO1xufTtcbmRlbmllZC5maW5kT25lQW5kVXBkYXRlLmxpbWl0ID1cbmRlbmllZC5maW5kT25lQW5kVXBkYXRlLnNraXAgPVxuZGVuaWVkLmZpbmRPbmVBbmRVcGRhdGUuYmF0Y2hTaXplID1cbmRlbmllZC5maW5kT25lQW5kVXBkYXRlLnRhaWxhYmxlID0gdHJ1ZTtcblxuXG5kZW5pZWQuY291bnQgPSBmdW5jdGlvbihzZWxmKSB7XG4gIGlmIChzZWxmLl9maWVsZHMgJiYgT2JqZWN0LmtleXMoc2VsZi5fZmllbGRzKS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuICdmaWVsZCBzZWxlY3Rpb24gYW5kIHNsaWNlJztcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkZW5pZWQuY291bnQpO1xuICBsZXQgZXJyO1xuXG4gIGtleXMuZXZlcnkoZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgaWYgKHNlbGYub3B0aW9uc1tvcHRpb25dKSB7XG4gICAgICBlcnIgPSBvcHRpb247XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gZXJyO1xufTtcblxuZGVuaWVkLmNvdW50LnNsaWNlID1cbmRlbmllZC5jb3VudC5iYXRjaFNpemUgPVxuZGVuaWVkLmNvdW50LnRhaWxhYmxlID0gdHJ1ZTtcbiJdLCJuYW1lcyI6WyJkZW5pZWQiLCJleHBvcnRzIiwiZGlzdGluY3QiLCJzZWxmIiwiX2ZpZWxkcyIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJlcnIiLCJldmVyeSIsIm9wdGlvbiIsIm9wdGlvbnMiLCJzZWxlY3QiLCJzbGljZSIsInNvcnQiLCJsaW1pdCIsInNraXAiLCJiYXRjaFNpemUiLCJoaW50IiwidGFpbGFibGUiLCJmaW5kT25lQW5kVXBkYXRlIiwiZmluZE9uZUFuZFJlbW92ZSIsImNvdW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/permissions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mquery/lib/utils.js":
/*!******************************************!*\
  !*** ./node_modules/mquery/lib/utils.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*!\n * Module dependencies.\n */ const specialProperties = [\n    \"__proto__\",\n    \"constructor\",\n    \"prototype\"\n];\n/**\n * Clones objects\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @return {Object} the cloned object\n * @api private\n */ const clone = exports.clone = function clone(obj, options) {\n    if (obj === undefined || obj === null) return obj;\n    if (Array.isArray(obj)) return exports.cloneArray(obj, options);\n    if (obj.constructor) {\n        if (/ObjectI[dD]$/.test(obj.constructor.name)) {\n            return \"function\" == typeof obj.clone ? obj.clone() : new obj.constructor(obj.id);\n        }\n        if (obj.constructor.name === \"ReadPreference\") {\n            return new obj.constructor(obj.mode, clone(obj.tags, options));\n        }\n        if (\"Binary\" == obj._bsontype && obj.buffer && obj.value) {\n            return \"function\" == typeof obj.clone ? obj.clone() : new obj.constructor(obj.value(true), obj.sub_type);\n        }\n        if (\"Date\" === obj.constructor.name || \"Function\" === obj.constructor.name) return new obj.constructor(+obj);\n        if (\"RegExp\" === obj.constructor.name) return new RegExp(obj);\n        if (\"Buffer\" === obj.constructor.name) return Buffer.from(obj);\n    }\n    if (isObject(obj)) return exports.cloneObject(obj, options);\n    if (obj.valueOf) return obj.valueOf();\n};\n/*!\n * ignore\n */ exports.cloneObject = function cloneObject(obj, options) {\n    const minimize = options && options.minimize, ret = {}, keys = Object.keys(obj), len = keys.length;\n    let hasKeys = false, val, k = \"\", i = 0;\n    for(i = 0; i < len; ++i){\n        k = keys[i];\n        // Not technically prototype pollution because this wouldn't merge properties\n        // onto `Object.prototype`, but avoid properties like __proto__ as a precaution.\n        if (specialProperties.indexOf(k) !== -1) {\n            continue;\n        }\n        val = clone(obj[k], options);\n        if (!minimize || \"undefined\" !== typeof val) {\n            hasKeys || (hasKeys = true);\n            ret[k] = val;\n        }\n    }\n    return minimize ? hasKeys && ret : ret;\n};\nexports.cloneArray = function cloneArray(arr, options) {\n    const ret = [], l = arr.length;\n    let i = 0;\n    for(; i < l; i++)ret.push(clone(arr[i], options));\n    return ret;\n};\n/**\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */ exports.merge = function merge(to, from) {\n    const keys = Object.keys(from);\n    for (const key of keys){\n        if (specialProperties.indexOf(key) !== -1) {\n            continue;\n        }\n        if (\"undefined\" === typeof to[key]) {\n            to[key] = from[key];\n        } else {\n            if (exports.isObject(from[key])) {\n                merge(to[key], from[key]);\n            } else {\n                to[key] = from[key];\n            }\n        }\n    }\n};\n/**\n * Same as merge but clones the assigned values.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */ exports.mergeClone = function mergeClone(to, from) {\n    const keys = Object.keys(from);\n    for (const key of keys){\n        if (specialProperties.indexOf(key) !== -1) {\n            continue;\n        }\n        if (\"undefined\" === typeof to[key]) {\n            to[key] = clone(from[key]);\n        } else {\n            if (exports.isObject(from[key])) {\n                mergeClone(to[key], from[key]);\n            } else {\n                to[key] = clone(from[key]);\n            }\n        }\n    }\n};\n/**\n * Read pref helper (mongo 2.2 drivers support this)\n *\n * Allows using aliases instead of full preference names:\n *\n *     p   primary\n *     pp  primaryPreferred\n *     s   secondary\n *     sp  secondaryPreferred\n *     n   nearest\n *\n * @param {String} pref\n */ exports.readPref = function readPref(pref) {\n    switch(pref){\n        case \"p\":\n            pref = \"primary\";\n            break;\n        case \"pp\":\n            pref = \"primaryPreferred\";\n            break;\n        case \"s\":\n            pref = \"secondary\";\n            break;\n        case \"sp\":\n            pref = \"secondaryPreferred\";\n            break;\n        case \"n\":\n            pref = \"nearest\";\n            break;\n    }\n    return pref;\n};\n/**\n * Read Concern helper (mongo 3.2 drivers support this)\n *\n * Allows using string to specify read concern level:\n *\n *     local          3.2+\n *     available      3.6+\n *     majority       3.2+\n *     linearizable   3.4+\n *     snapshot       4.0+\n *\n * @param {String|Object} concern\n */ exports.readConcern = function readConcern(concern) {\n    if (\"string\" === typeof concern) {\n        switch(concern){\n            case \"l\":\n                concern = \"local\";\n                break;\n            case \"a\":\n                concern = \"available\";\n                break;\n            case \"m\":\n                concern = \"majority\";\n                break;\n            case \"lz\":\n                concern = \"linearizable\";\n                break;\n            case \"s\":\n                concern = \"snapshot\";\n                break;\n        }\n        concern = {\n            level: concern\n        };\n    }\n    return concern;\n};\n/**\n * Object.prototype.toString.call helper\n */ const _toString = Object.prototype.toString;\nexports.toString = function(arg) {\n    return _toString.call(arg);\n};\n/**\n * Determines if `arg` is an object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @return {Boolean}\n */ const isObject = exports.isObject = function(arg) {\n    return \"[object Object]\" == exports.toString(arg);\n};\n/**\n * Object.keys helper\n */ exports.keys = Object.keys;\n/**\n * Basic Object.create polyfill.\n * Only one argument is supported.\n *\n * Based on https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create\n */ exports.create = \"function\" == typeof Object.create ? Object.create : create;\nfunction create(proto) {\n    if (arguments.length > 1) {\n        throw new Error(\"Adding properties is not supported\");\n    }\n    function F() {}\n    F.prototype = proto;\n    return new F;\n}\n/**\n * inheritance\n */ exports.inherits = function(ctor, superCtor) {\n    ctor.prototype = exports.create(superCtor.prototype);\n    ctor.prototype.constructor = ctor;\n};\n/**\n * Check if this object is an arguments object\n *\n * @param {Any} v\n * @return {Boolean}\n */ exports.isArgumentsObject = function(v) {\n    return Object.prototype.toString.call(v) === \"[object Arguments]\";\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBOztDQUVDLEdBRUQsTUFBTUEsb0JBQW9CO0lBQUM7SUFBYTtJQUFlO0NBQVk7QUFFbkU7Ozs7Ozs7Q0FPQyxHQUVELE1BQU1DLFFBQVFDLGFBQWEsR0FBRyxTQUFTRCxNQUFNRSxHQUFHLEVBQUVDLE9BQU87SUFDdkQsSUFBSUQsUUFBUUUsYUFBYUYsUUFBUSxNQUMvQixPQUFPQTtJQUVULElBQUlHLE1BQU1DLE9BQU8sQ0FBQ0osTUFDaEIsT0FBT0QsUUFBUU0sVUFBVSxDQUFDTCxLQUFLQztJQUVqQyxJQUFJRCxJQUFJTSxXQUFXLEVBQUU7UUFDbkIsSUFBSSxlQUFlQyxJQUFJLENBQUNQLElBQUlNLFdBQVcsQ0FBQ0UsSUFBSSxHQUFHO1lBQzdDLE9BQU8sY0FBYyxPQUFPUixJQUFJRixLQUFLLEdBQ2pDRSxJQUFJRixLQUFLLEtBQ1QsSUFBSUUsSUFBSU0sV0FBVyxDQUFDTixJQUFJUyxFQUFFO1FBQ2hDO1FBRUEsSUFBSVQsSUFBSU0sV0FBVyxDQUFDRSxJQUFJLEtBQUssa0JBQWtCO1lBQzdDLE9BQU8sSUFBSVIsSUFBSU0sV0FBVyxDQUFDTixJQUFJVSxJQUFJLEVBQUVaLE1BQU1FLElBQUlXLElBQUksRUFBRVY7UUFDdkQ7UUFFQSxJQUFJLFlBQVlELElBQUlZLFNBQVMsSUFBSVosSUFBSWEsTUFBTSxJQUFJYixJQUFJYyxLQUFLLEVBQUU7WUFDeEQsT0FBTyxjQUFjLE9BQU9kLElBQUlGLEtBQUssR0FDakNFLElBQUlGLEtBQUssS0FDVCxJQUFJRSxJQUFJTSxXQUFXLENBQUNOLElBQUljLEtBQUssQ0FBQyxPQUFPZCxJQUFJZSxRQUFRO1FBQ3ZEO1FBRUEsSUFBSSxXQUFXZixJQUFJTSxXQUFXLENBQUNFLElBQUksSUFBSSxlQUFlUixJQUFJTSxXQUFXLENBQUNFLElBQUksRUFDeEUsT0FBTyxJQUFJUixJQUFJTSxXQUFXLENBQUMsQ0FB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QztBQUMvQztBQUVBOztDQUVDLEdBRURqRCxZQUFZLEdBQUcwQixPQUFPRCxJQUFJO0FBRTFCOzs7OztDQUtDLEdBRUR6QixjQUFjLEdBQUcsY0FBYyxPQUFPMEIsT0FBT3lCLE1BQU0sR0FDL0N6QixPQUFPeUIsTUFBTSxHQUNiQTtBQUVKLFNBQVNBLE9BQU9DLEtBQUs7SUFDbkIsSUFBSUMsVUFBVXpCLE1BQU0sR0FBRyxHQUFHO1FBQ3hCLE1BQU0sSUFBSTBCLE1BQU07SUFDbEI7SUFFQSxTQUFTQyxLQUFNO0lBQ2ZBLEVBQUVSLFNBQVMsR0FBR0s7SUFDZCxPQUFPLElBQUlHO0FBQ2I7QUFFQTs7Q0FFQyxHQUVEdkQsZ0JBQWdCLEdBQUcsU0FBU3lELElBQUksRUFBRUMsU0FBUztJQUN6Q0QsS0FBS1YsU0FBUyxHQUFHL0MsUUFBUW1ELE1BQU0sQ0FBQ08sVUFBVVgsU0FBUztJQUNuRFUsS0FBS1YsU0FBUyxDQUFDeEMsV0FBVyxHQUFHa0Q7QUFDL0I7QUFFQTs7Ozs7Q0FLQyxHQUVEekQseUJBQXlCLEdBQUcsU0FBUzRELENBQUM7SUFDcEMsT0FBT2xDLE9BQU9xQixTQUFTLENBQUNDLFFBQVEsQ0FBQ0UsSUFBSSxDQUFDVSxPQUFPO0FBQy9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hdXRoLXJlZ2lzdGVyLy4vbm9kZV9tb2R1bGVzL21xdWVyeS9saWIvdXRpbHMuanM/OTU1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBzcGVjaWFsUHJvcGVydGllcyA9IFsnX19wcm90b19fJywgJ2NvbnN0cnVjdG9yJywgJ3Byb3RvdHlwZSddO1xuXG4vKipcbiAqIENsb25lcyBvYmplY3RzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgb2JqZWN0IHRvIGNsb25lXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSB0aGUgY2xvbmVkIG9iamVjdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuY29uc3QgY2xvbmUgPSBleHBvcnRzLmNsb25lID0gZnVuY3Rpb24gY2xvbmUob2JqLCBvcHRpb25zKSB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGwpXG4gICAgcmV0dXJuIG9iajtcblxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKVxuICAgIHJldHVybiBleHBvcnRzLmNsb25lQXJyYXkob2JqLCBvcHRpb25zKTtcblxuICBpZiAob2JqLmNvbnN0cnVjdG9yKSB7XG4gICAgaWYgKC9PYmplY3RJW2REXSQvLnRlc3Qob2JqLmNvbnN0cnVjdG9yLm5hbWUpKSB7XG4gICAgICByZXR1cm4gJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygb2JqLmNsb25lXG4gICAgICAgID8gb2JqLmNsb25lKClcbiAgICAgICAgOiBuZXcgb2JqLmNvbnN0cnVjdG9yKG9iai5pZCk7XG4gICAgfVxuXG4gICAgaWYgKG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSAnUmVhZFByZWZlcmVuY2UnKSB7XG4gICAgICByZXR1cm4gbmV3IG9iai5jb25zdHJ1Y3RvcihvYmoubW9kZSwgY2xvbmUob2JqLnRhZ3MsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICBpZiAoJ0JpbmFyeScgPT0gb2JqLl9ic29udHlwZSAmJiBvYmouYnVmZmVyICYmIG9iai52YWx1ZSkge1xuICAgICAgcmV0dXJuICdmdW5jdGlvbicgPT0gdHlwZW9mIG9iai5jbG9uZVxuICAgICAgICA/IG9iai5jbG9uZSgpXG4gICAgICAgIDogbmV3IG9iai5jb25zdHJ1Y3RvcihvYmoudmFsdWUodHJ1ZSksIG9iai5zdWJfdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKCdEYXRlJyA9PT0gb2JqLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ0Z1bmN0aW9uJyA9PT0gb2JqLmNvbnN0cnVjdG9yLm5hbWUpXG4gICAgICByZXR1cm4gbmV3IG9iai5jb25zdHJ1Y3Rvcigrb2JqKTtcblxuICAgIGlmICgnUmVnRXhwJyA9PT0gb2JqLmNvbnN0cnVjdG9yLm5hbWUpXG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChvYmopO1xuXG4gICAgaWYgKCdCdWZmZXInID09PSBvYmouY29uc3RydWN0b3IubmFtZSlcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShvYmopO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KG9iaikpXG4gICAgcmV0dXJuIGV4cG9ydHMuY2xvbmVPYmplY3Qob2JqLCBvcHRpb25zKTtcblxuICBpZiAob2JqLnZhbHVlT2YpXG4gICAgcmV0dXJuIG9iai52YWx1ZU9mKCk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMuY2xvbmVPYmplY3QgPSBmdW5jdGlvbiBjbG9uZU9iamVjdChvYmosIG9wdGlvbnMpIHtcbiAgY29uc3QgbWluaW1pemUgPSBvcHRpb25zICYmIG9wdGlvbnMubWluaW1pemUsXG4gICAgICByZXQgPSB7fSxcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhvYmopLFxuICAgICAgbGVuID0ga2V5cy5sZW5ndGg7XG4gIGxldCBoYXNLZXlzID0gZmFsc2UsXG4gICAgICB2YWwsXG4gICAgICBrID0gJycsXG4gICAgICBpID0gMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBrID0ga2V5c1tpXTtcbiAgICAvLyBOb3QgdGVjaG5pY2FsbHkgcHJvdG90eXBlIHBvbGx1dGlvbiBiZWNhdXNlIHRoaXMgd291bGRuJ3QgbWVyZ2UgcHJvcGVydGllc1xuICAgIC8vIG9udG8gYE9iamVjdC5wcm90b3R5cGVgLCBidXQgYXZvaWQgcHJvcGVydGllcyBsaWtlIF9fcHJvdG9fXyBhcyBhIHByZWNhdXRpb24uXG4gICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmluZGV4T2YoaykgIT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YWwgPSBjbG9uZShvYmpba10sIG9wdGlvbnMpO1xuXG4gICAgaWYgKCFtaW5pbWl6ZSB8fCAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiB2YWwpKSB7XG4gICAgICBoYXNLZXlzIHx8IChoYXNLZXlzID0gdHJ1ZSk7XG4gICAgICByZXRba10gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1pbmltaXplXG4gICAgPyBoYXNLZXlzICYmIHJldFxuICAgIDogcmV0O1xufTtcblxuZXhwb3J0cy5jbG9uZUFycmF5ID0gZnVuY3Rpb24gY2xvbmVBcnJheShhcnIsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmV0ID0gW10sXG4gICAgICBsID0gYXJyLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKylcbiAgICByZXQucHVzaChjbG9uZShhcnJbaV0sIG9wdGlvbnMpKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogTWVyZ2VzIGBmcm9tYCBpbnRvIGB0b2Agd2l0aG91dCBvdmVyd3JpdGluZyBleGlzdGluZyBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b1xuICogQHBhcmFtIHtPYmplY3R9IGZyb21cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSh0bywgZnJvbSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgdG9ba2V5XSkge1xuICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGV4cG9ydHMuaXNPYmplY3QoZnJvbVtrZXldKSkge1xuICAgICAgICBtZXJnZSh0b1trZXldLCBmcm9tW2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU2FtZSBhcyBtZXJnZSBidXQgY2xvbmVzIHRoZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRvXG4gKiBAcGFyYW0ge09iamVjdH0gZnJvbVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5tZXJnZUNsb25lID0gZnVuY3Rpb24gbWVyZ2VDbG9uZSh0bywgZnJvbSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgdG9ba2V5XSkge1xuICAgICAgdG9ba2V5XSA9IGNsb25lKGZyb21ba2V5XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChleHBvcnRzLmlzT2JqZWN0KGZyb21ba2V5XSkpIHtcbiAgICAgICAgbWVyZ2VDbG9uZSh0b1trZXldLCBmcm9tW2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9ba2V5XSA9IGNsb25lKGZyb21ba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJlYWQgcHJlZiBoZWxwZXIgKG1vbmdvIDIuMiBkcml2ZXJzIHN1cHBvcnQgdGhpcylcbiAqXG4gKiBBbGxvd3MgdXNpbmcgYWxpYXNlcyBpbnN0ZWFkIG9mIGZ1bGwgcHJlZmVyZW5jZSBuYW1lczpcbiAqXG4gKiAgICAgcCAgIHByaW1hcnlcbiAqICAgICBwcCAgcHJpbWFyeVByZWZlcnJlZFxuICogICAgIHMgICBzZWNvbmRhcnlcbiAqICAgICBzcCAgc2Vjb25kYXJ5UHJlZmVycmVkXG4gKiAgICAgbiAgIG5lYXJlc3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZlxuICovXG5cbmV4cG9ydHMucmVhZFByZWYgPSBmdW5jdGlvbiByZWFkUHJlZihwcmVmKSB7XG4gIHN3aXRjaCAocHJlZikge1xuICAgIGNhc2UgJ3AnOlxuICAgICAgcHJlZiA9ICdwcmltYXJ5JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3BwJzpcbiAgICAgIHByZWYgPSAncHJpbWFyeVByZWZlcnJlZCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzJzpcbiAgICAgIHByZWYgPSAnc2Vjb25kYXJ5JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NwJzpcbiAgICAgIHByZWYgPSAnc2Vjb25kYXJ5UHJlZmVycmVkJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ24nOlxuICAgICAgcHJlZiA9ICduZWFyZXN0JztcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHByZWY7XG59O1xuXG5cbi8qKlxuICogUmVhZCBDb25jZXJuIGhlbHBlciAobW9uZ28gMy4yIGRyaXZlcnMgc3VwcG9ydCB0aGlzKVxuICpcbiAqIEFsbG93cyB1c2luZyBzdHJpbmcgdG8gc3BlY2lmeSByZWFkIGNvbmNlcm4gbGV2ZWw6XG4gKlxuICogICAgIGxvY2FsICAgICAgICAgIDMuMitcbiAqICAgICBhdmFpbGFibGUgICAgICAzLjYrXG4gKiAgICAgbWFqb3JpdHkgICAgICAgMy4yK1xuICogICAgIGxpbmVhcml6YWJsZSAgIDMuNCtcbiAqICAgICBzbmFwc2hvdCAgICAgICA0LjArXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25jZXJuXG4gKi9cblxuZXhwb3J0cy5yZWFkQ29uY2VybiA9IGZ1bmN0aW9uIHJlYWRDb25jZXJuKGNvbmNlcm4pIHtcbiAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgY29uY2Vybikge1xuICAgIHN3aXRjaCAoY29uY2Vybikge1xuICAgICAgY2FzZSAnbCc6XG4gICAgICAgIGNvbmNlcm4gPSAnbG9jYWwnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICBjb25jZXJuID0gJ2F2YWlsYWJsZSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbSc6XG4gICAgICAgIGNvbmNlcm4gPSAnbWFqb3JpdHknO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2x6JzpcbiAgICAgICAgY29uY2VybiA9ICdsaW5lYXJpemFibGUnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3MnOlxuICAgICAgICBjb25jZXJuID0gJ3NuYXBzaG90JztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbmNlcm4gPSB7IGxldmVsOiBjb25jZXJuIH07XG4gIH1cbiAgcmV0dXJuIGNvbmNlcm47XG59O1xuXG4vKipcbiAqIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCBoZWxwZXJcbiAqL1xuXG5jb25zdCBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuZXhwb3J0cy50b1N0cmluZyA9IGZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwoYXJnKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgYXJnYCBpcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl8U3RyaW5nfEZ1bmN0aW9ufFJlZ0V4cHxhbnl9IGFyZ1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5jb25zdCBpc09iamVjdCA9IGV4cG9ydHMuaXNPYmplY3QgPSBmdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuICdbb2JqZWN0IE9iamVjdF0nID09IGV4cG9ydHMudG9TdHJpbmcoYXJnKTtcbn07XG5cbi8qKlxuICogT2JqZWN0LmtleXMgaGVscGVyXG4gKi9cblxuZXhwb3J0cy5rZXlzID0gT2JqZWN0LmtleXM7XG5cbi8qKlxuICogQmFzaWMgT2JqZWN0LmNyZWF0ZSBwb2x5ZmlsbC5cbiAqIE9ubHkgb25lIGFyZ3VtZW50IGlzIHN1cHBvcnRlZC5cbiAqXG4gKiBCYXNlZCBvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGVcbiAqL1xuXG5leHBvcnRzLmNyZWF0ZSA9ICdmdW5jdGlvbicgPT0gdHlwZW9mIE9iamVjdC5jcmVhdGVcbiAgPyBPYmplY3QuY3JlYXRlXG4gIDogY3JlYXRlO1xuXG5mdW5jdGlvbiBjcmVhdGUocHJvdG8pIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBZGRpbmcgcHJvcGVydGllcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICBmdW5jdGlvbiBGKCkgeyB9XG4gIEYucHJvdG90eXBlID0gcHJvdG87XG4gIHJldHVybiBuZXcgRjtcbn1cblxuLyoqXG4gKiBpbmhlcml0YW5jZVxuICovXG5cbmV4cG9ydHMuaW5oZXJpdHMgPSBmdW5jdGlvbihjdG9yLCBzdXBlckN0b3IpIHtcbiAgY3Rvci5wcm90b3R5cGUgPSBleHBvcnRzLmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlKTtcbiAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIG9iamVjdCBpcyBhbiBhcmd1bWVudHMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtBbnl9IHZcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0cy5pc0FyZ3VtZW50c09iamVjdCA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuIl0sIm5hbWVzIjpbInNwZWNpYWxQcm9wZXJ0aWVzIiwiY2xvbmUiLCJleHBvcnRzIiwib2JqIiwib3B0aW9ucyIsInVuZGVmaW5lZCIsIkFycmF5IiwiaXNBcnJheSIsImNsb25lQXJyYXkiLCJjb25zdHJ1Y3RvciIsInRlc3QiLCJuYW1lIiwiaWQiLCJtb2RlIiwidGFncyIsIl9ic29udHlwZSIsImJ1ZmZlciIsInZhbHVlIiwic3ViX3R5cGUiLCJSZWdFeHAiLCJCdWZmZXIiLCJmcm9tIiwiaXNPYmplY3QiLCJjbG9uZU9iamVjdCIsInZhbHVlT2YiLCJtaW5pbWl6ZSIsInJldCIsImtleXMiLCJPYmplY3QiLCJsZW4iLCJsZW5ndGgiLCJoYXNLZXlzIiwidmFsIiwiayIsImkiLCJpbmRleE9mIiwiYXJyIiwibCIsInB1c2giLCJtZXJnZSIsInRvIiwia2V5IiwibWVyZ2VDbG9uZSIsInJlYWRQcmVmIiwicHJlZiIsInJlYWRDb25jZXJuIiwiY29uY2VybiIsImxldmVsIiwiX3RvU3RyaW5nIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJhcmciLCJjYWxsIiwiY3JlYXRlIiwicHJvdG8iLCJhcmd1bWVudHMiLCJFcnJvciIsIkYiLCJpbmhlcml0cyIsImN0b3IiLCJzdXBlckN0b3IiLCJpc0FyZ3VtZW50c09iamVjdCIsInYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/utils.js\n");

/***/ })

};
;